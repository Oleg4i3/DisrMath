<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Топологія: Сфера ➔ Площина (з вигнутими ребрами)</title>
    <style>
        body { margin: 0; background-color: #111; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            pointer-events: none;
        }
        #slider-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            box-sizing: border-box;
            
            /* --- ОНОВЛЕНО: Використовуємо Flexbox для розміщення кнопки --- */
            display: flex;
            align-items: center;
        }
        .slider {
            -webkit-appearance: none;
            /* --- ОНОВЛЕНО: Слайдер тепер займає вільне місце --- */
            flex-grow: 1; 
            height: 8px;
            background: #444;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        .slider:hover {
            opacity: 1;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ff00;
            border-radius: 50%;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ff00;
            border-radius: 50%;
            cursor: pointer;
        }

        /* --- НОВЕ: Стилі для кнопки Play/Pause --- */
        #play-pause-button {
            padding: 8px 12px;
            margin-right: 10px;
            background: #00ff00;
            color: #111;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-family: Arial, sans-serif;
            min-width: 60px; /* Для однакової ширини 'Play' / 'Pause' */
            text-align: center;
        }
        #play-pause-button:hover {
            background: #33ff33;
        }
    </style>
</head>
<body>
    <div id="info">Стереографічна проекція: граф куба з ребрами на поверхні</div>
    <div id="slider-container">
        <button id="play-pause-button">Pause</button>
        <input type="range" min="0" max="1000" value="0" class="slider" id="progress-slider">
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let sphereMesh, planeMesh, material;
        let slider, clock, playPauseButton; // --- ОНОВЛЕНО ---

        let graphGroup, graphVertices = [], graphEdges = [];
        const planarCoords = []; 
        const edgeIndices = [
            [0, 1], [1, 2], [2, 3], [3, 0],
            [4, 5], [5, 6], [6, 7], [7, 4],
            [0, 4], [1, 5], [2, 6], [3, 7]
        ];

        // --- КОНСТАНТИ АНІМАЦІЇ ---
        const initialRadius = 3;       
        const startingRadius = 1.5; 
        const finalPlaneRadius = 20;   
        const minTheta = 0.01;         
        const loopDuration = 10;        
        const transitionProgress = 0.995; 
        const EDGE_SEGMENTS = 20; 

        // --- СТАН АНІМАЦІЇ ---
        let manualControl = false; 
        let lastProgress = 0;      
        let animStartTime = 0;     
        let isPlaying = true; // --- НОВЕ: Стан Play/Pause ---

        // --- НОВЕ: Тимчасові вектори для оптимізації ---
        const v_start_rel = new THREE.Vector3();
        const v_end_rel = new THREE.Vector3();
        const axis = new THREE.Vector3();
        const point_on_arc_rel = new THREE.Vector3();

        function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(12, 10, 12);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const ambientLight = new THREE.AmbientLight(0x404040, 3);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
            directionalLight.position.set(10, 15, 10);
            scene.add(directionalLight);

            const gridHelper = new THREE.GridHelper(finalPlaneRadius * 2, finalPlaneRadius * 2, 0x888888, 0x444444);
            scene.add(gridHelper);

            material = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                wireframe: false,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6,
                roughness: 0.3,
                metalness: 0.1
            });

            let sphereGeo = new THREE.SphereGeometry(initialRadius, 64, 32, 0, Math.PI * 2, 0, Math.PI);
            sphereMesh = new THREE.Mesh(sphereGeo, material);
            scene.add(sphereMesh);

            let planeGeo = new THREE.CircleGeometry(finalPlaneRadius, 64);
            planeMesh = new THREE.Mesh(planeGeo, material);
            planeMesh.rotation.x = -Math.PI / 2;
            planeMesh.visible = false;
            scene.add(planeMesh);

            initGraph();

            slider = document.getElementById('progress-slider');
            
            // --- ОНОВЛЕНО: Обробники слайдера ---
            slider.addEventListener('input', () => {
                const progress = parseFloat(slider.value) / 1000.0;
                updateAnimation(progress); 
                lastProgress = progress; // Оновлюємо lastProgress під час перетягування
            });
            slider.addEventListener('pointerdown', () => {
                manualControl = true;
                if (isPlaying) { // Якщо грало, показуємо, що перетягування = пауза
                    playPauseButton.textContent = 'Play';
                }
            });
            slider.addEventListener('pointerup', () => {
                manualControl = false;
                lastProgress = parseFloat(slider.value) / 1000.0;
                animStartTime = clock.getElapsedTime();
                if (isPlaying) { // Якщо грало, повертаємо текст "Pause"
                    playPauseButton.textContent = 'Pause';
                }
            });

            // --- НОВЕ: Обробник кнопки Play/Pause ---
            playPauseButton = document.getElementById('play-pause-button');
            playPauseButton.addEventListener('click', togglePlayPause);
            // --- Кінець нового блоку ---

            window.addEventListener('resize', onWindowResize, false);
            
            updateAnimation(0);
        }

        // --- НОВА ФУНКЦІЯ ---
        function togglePlayPause() {
            isPlaying = !isPlaying;
            if (isPlaying) {
                // Відновлюємо відтворення
                playPauseButton.textContent = 'Pause';
                // Синхронізуємо час, щоб продовжити з поточної точки
                animStartTime = clock.getElapsedTime(); 
                // lastProgress вже встановлено (або з 'pointerup', або з попередньої паузи)
            } else {
                // Ставимо на паузу
                playPauseButton.textContent = 'Play';
                // Зберігаємо поточний прогрес, щоб знати, звідки відновити
                lastProgress = parseFloat(slider.value) / 1000.0; 
            }
        }

        function initGraph() {
            graphGroup = new THREE.Group();
            scene.add(graphGroup);

            const vertexGeo = new THREE.SphereGeometry(0.2, 16, 16); 
            const vertexMat = new THREE.MeshStandardMaterial({ color: 0xff0000 }); 

            const inner_s = 5; 
            const outer_b = 12; 
            
            const finalCoords = [
                new THREE.Vector2( inner_s,  inner_s), // v0
                new THREE.Vector2(-inner_s,  inner_s), // v1
                new THREE.Vector2(-inner_s, -inner_s), // v2
                new THREE.Vector2( inner_s, -inner_s), // v3
                new THREE.Vector2( outer_b,  outer_b), // v4
                new THREE.Vector2(-outer_b,  outer_b), // v5
                new THREE.Vector2(-outer_b, -outer_b), // v6
                new THREE.Vector2( outer_b, -outer_b)  // v7
            ];

            // 1. Створюємо вершини
            for (let i = 0; i < 8; i++) {
                const v = finalCoords[i];
                const r = v.length();
                const phi = Math.atan2(v.y, v.x); 
                const norm_r = r / finalPlaneRadius;
                
                planarCoords.push({ phi: phi, norm_r: norm_r });
                
                const vertexMesh = new THREE.Mesh(vertexGeo, vertexMat);
                graphVertices.push(vertexMesh);
                graphGroup.add(vertexMesh);
            }

            // 2. Створюємо ребра (Edges)
            const edgeMat = new THREE.LineBasicMaterial({ color: 0xffff00 }); 

            for (const indices of edgeIndices) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array((EDGE_SEGMENTS + 1) * 3);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const edge = new THREE.Line(geometry, edgeMat);
                graphEdges.push(edge);
                graphGroup.add(edge);
            }
        }

        function updateGraph(currentRadius, currentTheta) {
            if (!graphGroup) return; 

            const sphere_y_offset = -currentRadius * Math.cos(currentTheta);

            // 1. Оновлюємо позиції вершин
            for (let i = 0; i < graphVertices.length; i++) {
                const planar = planarCoords[i];
                const theta_p = planar.norm_r * currentTheta;
                const phi_p = planar.phi;                     

                const x_s = currentRadius * Math.sin(theta_p) * Math.cos(phi_p);
                const y_s = currentRadius * Math.cos(theta_p);
                const z_s = currentRadius * Math.sin(theta_p) * Math.sin(phi_p);

                graphVertices[i].position.set(x_s, y_s + sphere_y_offset, z_s);
            }
            
            // 2. Оновлюємо ребра
            const isFlat = (currentTheta < (minTheta + 0.001)); 

            for (let j = 0; j < graphEdges.length; j++) {
                const edge = graphEdges[j];
                const indices = edgeIndices[j];
                const pos = edge.geometry.attributes.position;
                
                const v_start_world = graphVertices[indices[0]].position;
                const v_end_world = graphVertices[indices[1]].position;

                if (isFlat) {
                    // --- ЛОГІКА ДЛЯ ПЛОЩИНИ: Прямі лінії ---
                    for (let i = 0; i <= EDGE_SEGMENTS; i++) {
                        const t = i / EDGE_SEGMENTS;
                        point_on_arc_rel.lerpVectors(v_start_world, v_end_world, t);
                        pos.setXYZ(i, point_on_arc_rel.x, point_on_arc_rel.y, point_on_arc_rel.z);
                    }
                } else {
                    // --- ЛОГІКА ДЛЯ СФЕРИ: Вигнуті дуги (Great Circle Arc) ---
                    const planar_start = planarCoords[indices[0]];
                    const planar_end = planarCoords[indices[1]];

                    let theta_s = planar_start.norm_r * currentTheta;
                    let phi_s = planar_start.phi;
                    v_start_rel.set(
                        currentRadius * Math.sin(theta_s) * Math.cos(phi_s),
                        currentRadius * Math.cos(theta_s),
                        currentRadius * Math.sin(theta_s) * Math.sin(phi_s)
                    );

                    let theta_e = planar_end.norm_r * currentTheta;
                    let phi_e = planar_end.phi;
                    v_end_rel.set(
                        currentRadius * Math.sin(theta_e) * Math.cos(phi_e),
                        currentRadius * Math.cos(theta_e),
                        currentRadius * Math.sin(theta_e) * Math.sin(phi_e)
                    );

                    const totalAngle = v_start_rel.angleTo(v_end_rel);
                    axis.crossVectors(v_start_rel, v_end_rel); 

                    if (totalAngle < 0.001 || axis.lengthSq() < 0.0001) {
                        for (let i = 0; i <= EDGE_SEGMENTS; i++) {
                            const t = i / EDGE_SEGMENTS;
                            point_on_arc_rel.lerpVectors(v_start_rel, v_end_rel, t).setLength(currentRadius);
                            pos.setXYZ(
                                i,
                                point_on_arc_rel.x,
                                point_on_arc_rel.y + sphere_y_offset, 
                                point_on_arc_rel.z
                            );
                        }
                    } else {
                        axis.normalize();
                        for (let i = 0; i <= EDGE_SEGMENTS; i++) {
                            const t = i / EDGE_SEGMENTS;
                            point_on_arc_rel.copy(v_start_rel).applyAxisAngle(axis, totalAngle * t);
                            pos.setXYZ(
                                i,
                                point_on_arc_rel.x,
                                point_on_arc_rel.y + sphere_y_offset, 
                                point_on_arc_rel.z
                            );
                        }
                    }
                }
                pos.needsUpdate = true; 
            }
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateAnimation(progress) {
            let currentRadius, currentTheta;

            if (progress < 0.5) {
                // --- ФАЗА 1: Сфера (зростає) -> Півсфера (0.0 -> 0.5) ---
                sphereMesh.visible = true;
                planeMesh.visible = false;

                let p = progress * 2; 
                currentTheta = THREE.MathUtils.lerp(Math.PI, Math.PI / 2, p);
                currentRadius = THREE.MathUtils.lerp(startingRadius, initialRadius, p); 

            } else if (progress < transitionProgress) { 
                // --- ФАЗА 2: Півсфера -> Площина (0.5 -> 0.995) ---
                sphereMesh.visible = true;
                planeMesh.visible = false;

                let p = (progress - 0.5) / (transitionProgress - 0.5); 
                currentTheta = THREE.MathUtils.lerp(Math.PI / 2, minTheta, p);
                const targetEdgeRadius = THREE.MathUtils.lerp(initialRadius, finalPlaneRadius, p);
                currentRadius = targetEdgeRadius / Math.sin(currentTheta);

            } else {
                // --- ФАЗА 3: Стрибок на площину (0.995 -> 1.0) ---
                sphereMesh.visible = false;
                planeMesh.visible = true;
                
                let p = 1.0; 
                currentTheta = THREE.MathUtils.lerp(Math.PI / 2, minTheta, p);
                const targetEdgeRadius = THREE.MathUtils.lerp(initialRadius, finalPlaneRadius, p);
                currentRadius = targetEdgeRadius / Math.sin(currentTheta);
            }

            // Оновлюємо геометрію сфери (якщо вона видима)
            if (sphereMesh.visible) {
                sphereMesh.geometry.dispose(); 
                sphereMesh.geometry = new THREE.SphereGeometry(
                    currentRadius, 
                    64, 32,
                    0, Math.PI * 2,
                    0, currentTheta
                );
                sphereMesh.position.y = -currentRadius * Math.cos(currentTheta);
            }

            // Оновлюємо граф (ЗАВЖДИ)
            updateGraph(currentRadius, currentTheta);
        }

        function animate() {
            requestAnimationFrame(animate);

            // --- ОНОВЛЕНО: Додано перевірку isPlaying ---
            if (!manualControl && isPlaying) {
                const timeSinceResume = clock.getElapsedTime() - animStartTime;
                const progress = (lastProgress + (timeSinceResume / loopDuration)) % 1.0;
                
                updateAnimation(progress);
                slider.value = progress * 1000; 
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Запуск
        init();
        animate();
    </script>
</body>
</html>