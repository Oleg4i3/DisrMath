<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Топологія: Сфера ➔ Площина</title>
    <style>
        body { margin: 0; background-color: #111; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            pointer-events: none;
        }
        #slider-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            box-sizing: border-box;
        }
        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #444;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        .slider:hover {
            opacity: 1;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ff00;
            border-radius: 50%;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ff00;
            border-radius: 50%;
            cursor: pointer;
        }
        #area-info {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            color: #00ff00;
            font-family: Arial, sans-serif;
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">Стереографічна проекція: граф куба з ребрами на поверхні</div>
  
    <div id="slider-container">
        <input type="range" min="0" max="1000" value="0" class="slider" id="progress-slider">
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let sphereMesh, planeMesh, material;
        let slider, clock, areaInfo;

        let graphGroup, graphVertices = [], graphEdges = [];
        const planarCoords = []; 
        const edgeIndices = [
            [0, 1], [1, 2], [2, 3], [3, 0],
            [4, 5], [5, 6], [6, 7], [7, 4],
            [0, 4], [1, 5], [2, 6], [3, 7]
        ];

        // --- КОНСТАНТИ АНІМАЦІЇ ---
        const initialRadius = 3;       
        const startingRadius = 1.5;
        const minTheta = 0.01;         
        const loopDuration = 80;        
        const transitionProgress = 0.995; 
        const EDGE_SEGMENTS = 20;

        // --- КОНСТАНТИ ДЛЯ СТАЛОЇ ПЛОЩІ ---
        const TARGET_AREA = 4 * Math.PI * initialRadius * initialRadius; // Площа повної сфери початкового радіуса
        const FINAL_PLANE_RADIUS = Math.sqrt(TARGET_AREA / Math.PI); // Радіус площини для сталої площі

        // --- СТАН АНІМАЦІЇ ---
        let manualControl = false; 
        let lastProgress = 0;      
        let animStartTime = 0;     

        // --- Тимчасові вектори для оптимізації ---
        const v_start_rel = new THREE.Vector3();
        const v_end_rel = new THREE.Vector3();
        const axis = new THREE.Vector3();
        const point_on_arc_rel = new THREE.Vector3();

        // Зберігаємо початкові координати для плоского випадку
        let finalCoords = [];

        function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);//75
            camera.position.set(3, 20, 12); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const ambientLight = new THREE.AmbientLight(0x404040, 3);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
            directionalLight.position.set(10, 15, 10);
            scene.add(directionalLight);

            // Оновлюємо gridHelper з новим радіусом
            const gridHelper = new THREE.GridHelper(FINAL_PLANE_RADIUS * 2, FINAL_PLANE_RADIUS * 2, 0x888888, 0x444444);
            scene.add(gridHelper);

            material = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                wireframe: false,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6,
                roughness: 0.3,
                metalness: 0.1
            });

            let sphereGeo = new THREE.SphereGeometry(initialRadius, 64, 32, 0, Math.PI * 2, 0, Math.PI);
            sphereMesh = new THREE.Mesh(sphereGeo, material);
            scene.add(sphereMesh);

            // Оновлюємо площину з новим радіусом
            let planeGeo = new THREE.CircleGeometry(FINAL_PLANE_RADIUS, 64);
            planeMesh = new THREE.Mesh(planeGeo, material);
            planeMesh.rotation.x = -Math.PI / 2;
            planeMesh.visible = false;
            scene.add(planeMesh);

            areaInfo = document.getElementById('area-info');

            initGraph();

            slider = document.getElementById('progress-slider');
            slider.addEventListener('input', () => {
                const progress = parseFloat(slider.value) / 1000.0;
                updateAnimation(progress); 
            });
            slider.addEventListener('pointerdown', () => {
                manualControl = true;
            });
            slider.addEventListener('pointerup', () => {
                manualControl = false;
                lastProgress = parseFloat(slider.value) / 1000.0;
                animStartTime = clock.getElapsedTime();
            });

            window.addEventListener('resize', onWindowResize, false);
            
            updateAnimation(0);
        }

        function initGraph() {
            graphGroup = new THREE.Group();
            scene.add(graphGroup);

            const vertexGeo = new THREE.SphereGeometry(0.2, 16, 16); 
            const vertexMat = new THREE.MeshStandardMaterial({ color: 0xff0000 }); 

            // Оновлюємо координати для нової площини
            const scaleFactor = FINAL_PLANE_RADIUS / 20; // 20 - старий радіус
            const inner_s = 5 * scaleFactor; 
            const outer_b = 12 * scaleFactor; 
            
            finalCoords = [
                new THREE.Vector2( inner_s,  inner_s), // v0
                new THREE.Vector2(-inner_s,  inner_s), // v1
                new THREE.Vector2(-inner_s, -inner_s), // v2
                new THREE.Vector2( inner_s, -inner_s), // v3
                new THREE.Vector2( outer_b,  outer_b), // v4
                new THREE.Vector2(-outer_b,  outer_b), // v5
                new THREE.Vector2(-outer_b, -outer_b), // v6
                new THREE.Vector2( outer_b, -outer_b)  // v7
            ];

            // 1. Створюємо вершини
            for (let i = 0; i < 8; i++) {
                const v = finalCoords[i];
                const r = v.length();
                const phi = Math.atan2(v.y, v.x); 
                const norm_r = r / FINAL_PLANE_RADIUS;
                
                planarCoords.push({ phi: phi, norm_r: norm_r });
                
                const vertexMesh = new THREE.Mesh(vertexGeo, vertexMat);
                graphVertices.push(vertexMesh);
                graphGroup.add(vertexMesh);
            }

            // 2. Створюємо ребра (Edges)
            const edgeMat = new THREE.LineBasicMaterial({ color: 0xffff00 }); 

            for (const indices of edgeIndices) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array((EDGE_SEGMENTS + 1) * 3);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const edge = new THREE.Line(geometry, edgeMat);
                graphEdges.push(edge);
                graphGroup.add(edge);
            }
        }

        function updateGraph(currentRadius, currentTheta, isFlat) {
            if (!graphGroup) return; 

            // Розрахунок зміщення центру сфери
            const sphere_y_offset = -currentRadius * Math.cos(currentTheta);

            // 1. Оновлюємо позиції вершин
            for (let i = 0; i < graphVertices.length; i++) {
                const planar = planarCoords[i];
                
                if (isFlat) {
                    // Для плоского випадку використовуємо прямі координати
                    const v = finalCoords[i];
                    graphVertices[i].position.set(v.x, 0, v.y);
                } else {
                    // Сферичний випадок
                    const theta_p = planar.norm_r * currentTheta;
                    const phi_p = planar.phi;                     

                    const x_s = currentRadius * Math.sin(theta_p) * Math.cos(phi_p);
                    const y_s = currentRadius * Math.cos(theta_p);
                    const z_s = currentRadius * Math.sin(theta_p) * Math.sin(phi_p);

                    graphVertices[i].position.set(x_s, y_s + sphere_y_offset, z_s);
                }
            }
            
            // 2. Оновлюємо ребра
            for (let j = 0; j < graphEdges.length; j++) {
                const edge = graphEdges[j];
                const indices = edgeIndices[j];
                const pos = edge.geometry.attributes.position;
                
                // Отримуємо світові позиції вершин
                const v_start_world = graphVertices[indices[0]].position;
                const v_end_world = graphVertices[indices[1]].position;

                if (isFlat) {
                    // Логіка для площини: прямі лінії
                    for (let i = 0; i <= EDGE_SEGMENTS; i++) {
                        const t = i / EDGE_SEGMENTS;
                        point_on_arc_rel.lerpVectors(v_start_world, v_end_world, t);
                        pos.setXYZ(i, point_on_arc_rel.x, point_on_arc_rel.y, point_on_arc_rel.z);
                    }
                } else {
                    // Логіка для сфери: вигнуті дуги
                    const planar_start = planarCoords[indices[0]];
                    const planar_end = planarCoords[indices[1]];

                    let theta_s = planar_start.norm_r * currentTheta;
                    let phi_s = planar_start.phi;
                    v_start_rel.set(
                        currentRadius * Math.sin(theta_s) * Math.cos(phi_s),
                        currentRadius * Math.cos(theta_s),
                        currentRadius * Math.sin(theta_s) * Math.sin(phi_s)
                    );

                    let theta_e = planar_end.norm_r * currentTheta;
                    let phi_e = planar_end.phi;
                    v_end_rel.set(
                        currentRadius * Math.sin(theta_e) * Math.cos(phi_e),
                        currentRadius * Math.cos(theta_e),
                        currentRadius * Math.sin(theta_e) * Math.sin(phi_e)
                    );

                    // Розраховуємо параметри дуги
                    const totalAngle = v_start_rel.angleTo(v_end_rel);
                    axis.crossVectors(v_start_rel, v_end_rel);

                    // Заповнюємо BufferAttribute
                    if (totalAngle < 0.001 || axis.lengthSq() < 0.0001) {
                        // Використовуємо просту інтерполяцію
                        for (let i = 0; i <= EDGE_SEGMENTS; i++) {
                            const t = i / EDGE_SEGMENTS;
                            point_on_arc_rel.lerpVectors(v_start_rel, v_end_rel, t).setLength(currentRadius);
                            pos.setXYZ(
                                i,
                                point_on_arc_rel.x,
                                point_on_arc_rel.y + sphere_y_offset,
                                point_on_arc_rel.z
                            );
                        }
                    } else {
                        // Стабільний випадок: обертаємо по дузі
                        axis.normalize();
                        for (let i = 0; i <= EDGE_SEGMENTS; i++) {
                            const t = i / EDGE_SEGMENTS;
                            point_on_arc_rel.copy(v_start_rel).applyAxisAngle(axis, totalAngle * t);
                            pos.setXYZ(
                                i,
                                point_on_arc_rel.x,
                                point_on_arc_rel.y + sphere_y_offset,
                                point_on_arc_rel.z
                            );
                        }
                    }
                }
                pos.needsUpdate = true;
            }
        }

        // Функція для обчислення площі сферичного сегмента
        function calculateSphericalSegmentArea(radius, theta) {
            // Площа сферичного сегмента: 2πR²(1 - cosθ)
            return 2 * Math.PI * radius * radius * (1 - Math.cos(theta));
        }

        // Функція для обчислення радіуса, що зберігає сталу площу
        function calculateRadiusForConstantArea(theta, targetArea) {
            // З формули площі сферичного сегмента: A = 2πR²(1 - cosθ)
            // Виводимо R: R = sqrt(A / (2π(1 - cosθ)))
            if (theta < minTheta) {
                return FINAL_PLANE_RADIUS; // Для площини використовуємо обчислений радіус
            }
            return Math.sqrt(targetArea / (2 * Math.PI * (1 - Math.cos(theta))));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateAnimation(progress) {
            let currentRadius, currentTheta;
            let currentArea = 0;
            let isFlat = false;

            if (progress < 0.5) {
                // --- ФАЗА 1: Сфера (зростає) -> Півсфера (0.0 -> 0.5) ---
                sphereMesh.visible = true;
                planeMesh.visible = false;
                isFlat = false;

                let p = progress * 2; 
                currentTheta = THREE.MathUtils.lerp(Math.PI, Math.PI / 2, p);
                
                // Обчислюємо радіус для сталої площі
                currentRadius = calculateRadiusForConstantArea(currentTheta, TARGET_AREA);

            } else if (progress < transitionProgress) { 
                // --- ФАЗА 2: Півсфера -> Площина (0.5 -> 0.995) ---
                sphereMesh.visible = true;
                planeMesh.visible = false;
                isFlat = false;

                let p = (progress - 0.5) / (transitionProgress - 0.5); 
                currentTheta = THREE.MathUtils.lerp(Math.PI / 2, minTheta, p);
                
                // Обчислюємо радіус для сталої площі
                currentRadius = calculateRadiusForConstantArea(currentTheta, TARGET_AREA);

            } else {
                // --- ФАЗА 3: Стрибок на площину (0.995 -> 1.0) ---
                sphereMesh.visible = false;
                planeMesh.visible = true;
                isFlat = true;
                
                currentTheta = minTheta;
                currentRadius = FINAL_PLANE_RADIUS;
                currentArea = TARGET_AREA; // Площа площини дорівнює цільовій площі
            }

            // Оновлюємо геометрію сфери (якщо вона видима)
            if (sphereMesh.visible) {
                sphereMesh.geometry.dispose(); 
                sphereMesh.geometry = new THREE.SphereGeometry(
                    currentRadius, 
                    64, 32,
                    0, Math.PI * 2,
                    0, currentTheta
                );
                sphereMesh.position.y = -currentRadius * Math.cos(currentTheta);
                
                // Обчислюємо поточну площу
                currentArea = calculateSphericalSegmentArea(currentRadius, currentTheta);
            }

            // Оновлюємо інформацію про площу
          //  areaInfo.textContent = `Площа поверхні: ${currentArea.toFixed(2)} (ціль: ${TARGET_AREA.toFixed(2)})`;

            // Оновлюємо граф
            updateGraph(currentRadius, currentTheta, isFlat);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!manualControl) {
                const timeSinceResume = clock.getElapsedTime() - animStartTime;
                const progress = (lastProgress + (timeSinceResume / loopDuration)) % 1.0;
                
                updateAnimation(progress);
                slider.value = progress * 1000; 
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Запуск
        init();
        animate();
    </script>
</body>
</html>