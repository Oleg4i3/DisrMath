<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="utf-8" />
    <title>Симулятор Label Propagation (незважений)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body{font-family:Inter,Arial,Helvetica,sans-serif;background:#f5f7fb;display:flex;justify-content:center;padding:18px}
        #main{width:100%;max-width:980px;background:#fff;border-radius:10px;padding:18px;border:1px solid #e6e9ef}
        h2{margin:0 0 12px;color:#222}
        #graph-container, #controls{margin-top:12px}
        svg{width:100%;height:520px;display:block}
        .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
        button{padding:8px 12px;border-radius:6px;border:none;background:#2563eb;color:white;cursor:pointer}
        button.secondary{background:#6b7280}
        button:disabled{opacity:0.5;cursor:not-allowed}
        .presets{display:flex;gap:8px;align-items:center}
        #info{margin-top:12px;background:#fbfdff;padding:10px;border-radius:8px;border:1px solid #eef2ff}
        pre{background:#f3f6ff;padding:10px;border-radius:6px;overflow:auto}
        .node text{pointer-events:none;font-size:11px;fill:#fff}
        .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    </style>
</head>
<body>
<div id="main">
    <h2>Симулятор Label Propagation (незважений)</h2>

    <div class="presets">
        <button id="preset-complex" class="secondary">Три кліки з мостами</button>
        <button id="preset-karate" class="secondary">Карате-клуб</button>
        <button id="preset-ba" class="secondary">Граф з хабами (BA)</button>
        <button id="preset-random" class="secondary">Випадковий</button>
    </div>

    <div id="graph-container">
        <svg id="graph-svg"></svg>
    </div>

    <div id="controls">
        <div class="controls">
            <button id="initBtn">Ініціалізувати (унікальні мітки)</button>
            <button id="stepBtn" disabled>Крок (ітерація)</button>
            <button id="runBtn">Запустити</button>
            <button id="stopBtn" disabled class="secondary">Стоп</button>
            <button id="resetBtn" class="secondary">Скинути</button>
            <div style="margin-left:12px">Ітерація: <span id="iter">0</span></div>
            <div style="margin-left:12px">Зміни в останній ітерації: <span id="changes">0</span></div>
        </div>
    </div>

    <div id="info">
        <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
                <b>Інструкції:</b> Подвійний клік на порожньому місці — додати вершину. Клік на вершині → вибрати; клік на іншій вершині — створити ребро. Видалити вершину — вибрати і натиснути Delete. Подвійний клік по ребру — видалити.
            </div>
            <div class="legend"><small>Кольори — мітки (спільноти). Схожі мітки мають однаковий колір.</small></div>
        </div>
        <details style="margin-top:10px"><summary>Результат</summary><pre id="commOut">Спільноти ще не побудовані.</pre></details>
    
	<section id="theory" style="margin-top:16px;background:#fff8e6;padding:14px;border-radius:8px;border:1px solid #fff0d0">
    <h3>Теоретична довідка — Label Propagation (незважений)</h3>
    <div>
        <p><strong>Коротко:</strong> алгоритм поширює мітки по графу: кожна вершина на кожній ітерації приймає найпоширенішу мітку серед своїх сусідів. Результат — поділ на спільноти (community), у яких вершини мають однакові мітки.</p>

        <h4>Формалізація (MathJax)</h4>
        <p>Нехай $G=(V,E)$ — неорієнтований граф, $|V|=n$. Матриця суміжності $A=(a_{ij})$ має елементи $a_{ij}\in\{0,1\}$ (незважений випадок). Позначимо мітки вершин у ітерації $t$ як $L^{(t)} = (L_1^{(t)},...,L_n^{(t)})$, де $L_i^{(t)}$ — ціла мітка.</p>

        <p>Оновлення для вершини $i$:</p>
        <p>$$
            L_i^{(t+1)} = \arg\max_\ell\; \sum_{j:\,(i,j)\in E} \mathbf{1}\{L_j^{(t)} = \ell\}.
        $$</p>
        <p>Тобто ми підраховуємо кількість сусідів із кожною міткою і обираємо мітку з максимальною частотою. У випадку нічиєї — tie-break рандомно.</p>

        <h4>Енергетична інтерпретація (аналог Potts/Ising)</h4>
        <p>Можна ввести функцію якості (яку ми прагнемо максимізувати):</p>
        <p>$$
            Q(L) = \sum_{(i,j)\in E} \delta(L_i, L_j),
        $$</p>
        <p>де $\delta(\cdot,\cdot)$ — індикатор тотожності. LPA локально збільшує $Q$ при кожному оновленні вершини (жадібний крок).</p>

        <h4>Властивості та збіжність</h4>
        <ul>
            <li>Алгоритм зазвичай сходиться швидко (кілька ітерацій для реальних графів).</li>
            <li>Збіжність гарантується у сенсі досягнення стану, коли жодна вершина не змінює мітку — бо $Q$ не зменшується при жадібних оновленнях і максимум скінченний.</li>
            <li>Немає гарантії знаходження глобального максимуму $Q$ — результати залежать від порядку оновлень і початкових міток.</li>
            <li>Стохастичність (рандомні tie-break, порядок оновлень) часто корисна — запускають кілька разів і беруть консенсус.</li>
        </ul>

        <h4>Модифікації</h4>
        <ul>
            <li><strong>Weighted LPA</strong>: підрахунок замінюється зваженим сумуванням $\sum_j a_{ij} \mathbf{1}\{L_j=\ell\}$.</li>
            <li><strong>Asynchronous vs Synchronous</strong>: у асинхронному варіанті оновлення відразу впливають на наступні вершини (поточні оновлення застосовуються одразу) — швидше, але більш стохастично. У синхронному — всі оновлення застосовуються одночасно після обчислення нового вектора міток.</li>
            <li><strong>Overlapping LPA (SLPA)</strong>: вершини зберігають розподіл міток замість єдиної мітки — дає перекриття спільнот.</li>
            <li><strong>Semi-supervised LPA</strong>: деякі вершини мають фіксовані (якорні) мітки — корисно для поширення маркерів компрометації.</li>
        </ul>

        <h4>Порівняння з іншими методами</h4>
        <table style="width:100%;border-collapse:collapse">
            <tr><th style="text-align:left">Метод</th><th style="text-align:left">Переваги</th><th style="text-align:left">Недоліки</th></tr>
            <tr><td><strong>Louvain</strong></td><td>Оптимізує модульність, добре для великих графів, ієрархічна структура</td><td>Може мати resolution limit, дорожчий в обчисленнях, детермінований</td></tr>
            <tr><td><strong>Spectral clustering</strong></td><td>Математично обґрунтований, хороший при чітких спектральних розривів</td><td>Потребує власних векторів (дорого для великих графів), нечіткий вибір кількості кластерів</td></tr>
            <tr><td><strong>Infomap</strong></td><td>Добре виявляє модулі на основі потоків; добре для направлених графів</td><td>Чутливий до випадковості, може бути повільнішим</td></tr>
            <tr><td><strong>Label Propagation</strong></td><td>Простий, лінійний за |E|, масштабований; не потребує числа кластерів</td><td>Стохастичний, нестабільний, може давати дрібні «шуми» чи неправильний розподіл</td></tr>
        </table>

        <h4>Практичні застосунки в ІТ та кібербезпеці</h4>
        <ul>
            <li>Виявлення ботнетів — заражені вузли схожою поведінкою утворюють маленькі щільні кластери.</li>
            <li>Лінії бічного руху (lateral movement) — нові або посилені зв'язки між кластерами показують підозрілу активність.</li>
            <li>Класифікація ролей хостів — у великих мережах LPA швидко знаходить сегменти за ролями (сервери, клієнти, IoT).</li>
            <li>Розширення міток відомих компрометацій (semi-supervised) — маркери зараження розповсюджуються по графу.</li>
        </ul>

        <h4>Обхідні поради</h4>
        <ol>
            <li>Запускайте LPA кілька разів і обчислюйте консенсус (стабільні кластери важливіші).</li>
            <li>Фільтруйте шум: видаляйте або зважуйте рідкісні зв'язки перед запуском.</li>
            <li>Поєднуйте з метриками centrality і аналізом міжкластерних зв'язків для підвищення точності аномалій.</li>
        </ol>

     </div>
</section>
	</div>
</div>

<script>
  window.MathJax = { tex: { inlineMath: [['$','$']], displayMath: [['$$','$$']] } };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<script>
// --- STATE ---
let nodes = [], links = [];
let label = new Map(); // nodeId -> label
let svg = d3.select('#graph-svg');
let width = svg.node().getBoundingClientRect().width;
let height = +svg.attr('height') || 520;
const color = d3.scaleOrdinal(d3.schemeTableau10);
let simulation;
let selectedNode = null, selectedLink = null;
let running = false;
let iterCount = 0;
let maxIter = 200;
let runInterval = null;

function setup() {
    svg.attr('viewBox', `0 0 ${width} ${height}`);

    simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d=>d.id).distance(80))
        .force('charge', d3.forceManyBody().strength(-350))
        .force('center', d3.forceCenter(width/2, height/2))
        .on('tick', ticked);

    svg.on('dblclick', (event)=>{ const [x,y] = d3.pointer(event); addNode(x,y); })
       .on('click', (event)=>{ if(event.target.tagName==='svg') clearSelection(); });

    d3.select('body').on('keydown', (event)=>{ if((event.key==='Delete' || event.key==='Backspace') && selectedNode) removeNode(selectedNode.id); });

    update();
}

function update(){
    // links
    const linkSel = svg.selectAll('line.link').data(links, d=>d.id || (d.source.id+'-'+d.target.id));
    linkSel.exit().remove();
    const linkEnter = linkSel.enter().append('line').attr('class','link').attr('stroke-width',2).attr('stroke','#999').on('dblclick', (event,d)=>{ event.stopPropagation(); removeLink(d); })
        .on('click', (event,d)=>{ event.stopPropagation(); selectedLink = d; selectedNode = null; update(); });

    // nodes
    const nodeSel = svg.selectAll('g.node').data(nodes, d=>d.id);
    nodeSel.exit().remove();
    const nodeEnter = nodeSel.enter().append('g').attr('class','node').call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended)).on('click', (event,d)=>{ event.stopPropagation(); nodeClicked(d); });
    nodeEnter.append('circle').attr('r',14).attr('stroke','#333').attr('stroke-width',1.5);
    nodeEnter.append('text').attr('dy','.35em').attr('text-anchor','middle').style('pointer-events','none').style('font-size','11px').style('fill','#fff');

    // update appearance
    svg.selectAll('g.node').select('circle').attr('fill', d=> label.has(d.id) ? color(label.get(d.id)) : '#6b7280').attr('stroke', d=> selectedNode===d ? '#ff7f0e' : '#333').attr('stroke-width', d=> selectedNode===d ? 3 : 1.5);
    svg.selectAll('g.node').select('text').text(d=>d.id);

    simulation.nodes(nodes);
    simulation.force('link').links(links);
    simulation.alpha(0.8).restart();
}

function ticked(){
    const r = 16;
    nodes.forEach(n => { n.x = Math.max(r, Math.min(width - r, n.x)); n.y = Math.max(r, Math.min(height - r, n.y)); });
    svg.selectAll('line.link').attr('x1', d=>d.source.x).attr('y1', d=>d.source.y).attr('x2', d=>d.target.x).attr('y2', d=>d.target.y);
    svg.selectAll('g.node').attr('transform', d=>`translate(${d.x},${d.y})`);
}

// --- INTERACTIONS ---
function addNode(x,y){ const newId = nodes.length? Math.max(...nodes.map(n=>n.id))+1:0; const n={id:newId,x,y}; nodes.push(n); clearLabels(); update(); }
function removeNode(id){ nodes = nodes.filter(n=>n.id!==id); links = links.filter(l=>l.source.id!==id && l.target.id!==id); clearSelection(); clearLabels(); update(); }
function addLink(a,b){ if(a===b) return; const exists = links.some(l=> (l.source.id===a && l.target.id===b) || (l.source.id===b && l.target.id===a)); if(exists) return; const s = nodes.find(n=>n.id===a); const t = nodes.find(n=>n.id===b); if(!s||!t) return; links.push({source:s, target:t}); clearLabels(); update(); }
function removeLink(link){ links = links.filter(l=>l!==link); clearSelection(); clearLabels(); update(); }
function nodeClicked(d){ if(selectedNode && selectedNode!==d){ addLink(selectedNode.id, d.id); selectedNode=null; } else selectedNode=d; selectedLink=null; update(); }
function clearSelection(){ selectedNode=null; selectedLink=null; update(); }
function dragstarted(event,d){ if(!event.active) simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; }
function dragged(event,d){ d.fx = event.x; d.fy = event.y; }
function dragended(event,d){ if(!event.active) simulation.alphaTarget(0); d.fx=null; d.fy=null; }

// --- LABEL PROPAGATION LOGIC (незважений) ---
function initLabels(){ label.clear(); nodes.forEach(n=> label.set(n.id, n.id)); iterCount = 0; d3.select('#iter').text(iterCount); d3.select('#changes').text(0); d3.select('#commOut').text(formatCommunities()); update(); d3.select('#stepBtn').property('disabled', false); }

function clearLabels(){ label.clear(); d3.select('#commOut').text('Спільноти ще не побудовані.'); d3.select('#iter').text(0); d3.select('#changes').text(0); d3.select('#stepBtn').property('disabled', true); }

function runLPIteration(){
    if(nodes.length===0) return 0;
    // build adjacency list (unweighted)
    const adj = new Map(nodes.map(n=>[n.id, new Set()]));
    links.forEach(l=>{ const s = typeof l.source==='object'? l.source.id : l.source; const t = typeof l.target==='object'? l.target.id : l.target; adj.get(s).add(t); adj.get(t).add(s); });

    const order = d3.shuffle(nodes.map(n=>n.id));
    let changes = 0;
    order.forEach(nodeId=>{
        const neigh = adj.get(nodeId);
        if(!neigh || neigh.size===0) return; // isolated node keeps its label
        // count labels among neighbors
        const counts = new Map();
        neigh.forEach(nbId=>{ const lab = label.get(nbId); if(lab===undefined) return; counts.set(lab, (counts.get(lab)||0)+1); });
        if(counts.size===0) return;
        // pick label with max count; tie-break randomly among maxima
        let maxCount = -1; let candidates = [];
        counts.forEach((cnt, lab)=>{ if(cnt>maxCount){ maxCount=cnt; candidates=[lab]; } else if(cnt===maxCount){ candidates.push(lab); } });
        const chosen = candidates[Math.floor(Math.random()*candidates.length)];
        if(label.get(nodeId) !== chosen){ label.set(nodeId, chosen); changes++; }
    });

    iterCount++;
    d3.select('#iter').text(iterCount);
    d3.select('#changes').text(changes);
    // update colors
    svg.selectAll('g.node').select('circle').attr('fill', d=> label.has(d.id) ? color(label.get(d.id)) : '#6b7280');
    d3.select('#commOut').text(formatCommunities());
    return changes;
}

function formatCommunities(){ if(label.size===0) return 'Спільноти ще не побудовані.'; const groups = new Map(); label.forEach((lab, id)=>{ if(!groups.has(lab)) groups.set(lab, []); groups.get(lab).push(id); });
    // sort groups by size descending
    const arr = [...groups.entries()].map(([lab, members])=>({lab, members: members.sort((a,b)=>a-b)})).sort((a,b)=>b.members.length - a.members.length);
    return arr.map(g=>`Спільнота ${g.lab}: {${g.members.join(', ')}}`).join('\n'); }

// control loop
function stepOnce(){ const changes = runLPIteration(); if(changes===0 || iterCount>=maxIter) { stopRun(); } }

function startRun(intervalMs=500){ if(running) return; running=true; d3.select('#runBtn').property('disabled', true); d3.select('#stopBtn').property('disabled', false); d3.select('#initBtn').property('disabled', true); d3.select('#stepBtn').property('disabled', true);
    runInterval = setInterval(()=>{ const changes = runLPIteration(); if(changes===0 || iterCount>=maxIter) stopRun(); }, intervalMs);
}
function stopRun(){ if(!running) return; running=false; clearInterval(runInterval); d3.select('#runBtn').property('disabled', false); d3.select('#stopBtn').property('disabled', true); d3.select('#initBtn').property('disabled', false); d3.select('#stepBtn').property('disabled', false); }

// --- PRESETS ---
function loadComplexPreset(){ resetGraph(); for(let i=0;i<=15;i++) nodes.push({id:i}); // three cliques
    for(let i=0;i<4;i++) for(let j=i+1;j<4;j++) addLink(i,j);
    for(let i=4;i<10;i++) for(let j=i+1;j<10;j++) addLink(i,j);
    for(let i=10;i<15;i++) for(let j=i+1;j<15;j++) addLink(i,j);
    addLink(3,4); addLink(9,10); addLink(8,11); addLink(14,15); addLink(15,2); update(); }

function loadKarate(){ resetGraph(); nodes = Array.from({length:34}, (_,i)=>({id:i})); const karateLinks = [[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[0,10],[0,11],[0,12],[0,13],[0,17],[0,19],[0,21],[1,2],[1,3],[1,7],[1,13],[1,17],[1,19],[1,21],[1,30],[2,3],[2,7],[2,8],[2,9],[2,13],[2,27],[2,28],[2,32],[3,7],[3,12],[3,13],[4,6],[4,10],[5,6],[5,10],[5,16],[6,16],[8,30],[8,32],[8,33],[9,33],[13,33],[14,32],[14,33],[15,32],[15,33],[18,32],[18,33],[19,33],[20,32],[20,33],[22,32],[22,33],[23,25],[23,27],[23,29],[23,32],[23,33],[24,25],[24,27],[24,31],[25,31],[26,29],[26,33],[27,33],[28,31],[28,33],[29,32],[29,33],[30,32],[30,33],[31,32],[31,33],[32,33]]; karateLinks.forEach(l=>addLink(l[0],l[1])); update(); }

function loadBarabasiAlbert(){ resetGraph(); const N = 35; const m0=2; for(let i=0;i<m0;i++) nodes.push({id:i}); for(let i=0;i<m0;i++) for(let j=i+1;j<m0;j++) addLink(i,j);
    for(let i=m0;i<N;i++){ nodes.push({id:i}); const targets=new Set(); const m=Math.floor(Math.random()*2)+1; const degreeList=[]; links.forEach(l=>{ if(l.source.id < i) degreeList.push(l.source.id); if(l.target.id < i) degreeList.push(l.target.id); }); while(targets.size < m && targets.size < i){ let targetId; if(degreeList.length>0 && Math.random()<0.95) targetId = degreeList[Math.floor(Math.random()*degreeList.length)]; else targetId = Math.floor(Math.random()*i); if(targetId !== i) targets.add(targetId); } targets.forEach(t=>addLink(i,t)); } update(); }

function loadRandom(){ resetGraph(); const numNodes = 25; for(let i=0;i<numNodes;i++) nodes.push({id:i}); const added = new Set(); for(let i=0;i<numNodes*1.8;i++){ const a=Math.floor(Math.random()*numNodes); const b=Math.floor(Math.random()*numNodes); if(a===b) continue; const k1=`${a}-${b}`, k2=`${b}-${a}`; if(added.has(k1)) continue; addLink(a,b); added.add(k1); added.add(k2); } update(); }

// --- UTIL ---
function resetGraph(){ nodes=[]; links=[]; clearLabels(); clearSelection(); update(); }

// --- UI wiring ---
document.getElementById('preset-complex').addEventListener('click', loadComplexPreset);
document.getElementById('preset-karate').addEventListener('click', loadKarate);
document.getElementById('preset-ba').addEventListener('click', loadBarabasiAlbert);
document.getElementById('preset-random').addEventListener('click', loadRandom);

document.getElementById('initBtn').addEventListener('click', initLabels);
document.getElementById('stepBtn').addEventListener('click', ()=>{ stepOnce(); });
document.getElementById('runBtn').addEventListener('click', ()=>{ if(label.size===0) initLabels(); startRun(350); });
document.getElementById('stopBtn').addEventListener('click', stopRun);
document.getElementById('resetBtn').addEventListener('click', resetGraph);

// --- start with complex preset ---
setup(); loadComplexPreset();

</script>
</body>
</html>
