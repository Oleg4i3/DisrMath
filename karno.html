<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–¢–æ–ø–æ–ª–æ–≥—ñ—è –ö–∞—Ä—Ç–∏ –ö–∞—Ä–Ω–æ: –¢–æ—Ä ‚ûî –ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body { margin: 0; background-color: #111; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        
        /* UI Elements */
        #top-bar {
            position: absolute;
            top: 10px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }
        
        #title-text {
            color: white;
            font-size: 18px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 15px;
        }

        #controls-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 12px;
            backdrop-filter: blur(5px);
            box-sizing: border-box;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 10;
        }

        .slider {
            -webkit-appearance: none;
            flex-grow: 1; 
            height: 6px;
            background: #555;
            border-radius: 3px;
            outline: none;
            transition: background .2s;
        }
        .slider:hover { background: #666; }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #00ff00;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,255,0,0.5);
        }
        
        button {
            padding: 8px 16px;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: transform 0.1s, background 0.2s;
        }
        button:hover { background: #33ff33; transform: scale(1.05); }
        button:active { transform: scale(0.95); }

        #info-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #2196F3;
            color: white;
            z-index: 20;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        #info-btn:hover { background: #42A5F5; }

        /* Modal Styles */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 100; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            background-color: rgba(0,0,0,0.85); 
            overflow-y: auto;
        }
        .modal-content {
            background-color: #1e1e1e;
            color: #ddd;
            margin: 5% auto; 
            padding: 30px;
            border: 1px solid #444;
            width: 80%; 
            max-width: 800px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.9);
            position: relative;
            line-height: 1.6;
        }
        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close-btn:hover { color: #fff; }
        
        h2 { color: #00ff00; margin-top: 0; }
        h3 { color: #2196F3; margin-bottom: 5px; }
        .highlight-blue { color: #5588ff; font-weight: bold; }
        .highlight-red { color: #ff5555; font-weight: bold; }
        hr { border: 0; border-top: 1px solid #444; margin: 20px 0; }
        
        .diagram-hint {
            background: #333;
            padding: 10px;
            border-left: 4px solid #00ff00;
            margin: 10px 0;
            font-style: italic;
            font-size: 0.9em;
        }
    </style>
</head>
<body>

    <div id="top-bar">
        <div id="title-text">–¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—è: –¢–æ—Ä ‚ûî –¶–∏–ª—ñ–Ω–¥—Ä ‚ûî –ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫ (–ö–∞—Ä—Ç–∞ –ö–∞—Ä–Ω–æ)</div>
    </div>

    <button id="info-btn">üìñ –¢–µ–æ—Ä—ñ—è / –î–æ–≤—ñ–¥–∫–∞</button>

    <div id="controls-container">
        <button id="play-pause-button">Pause</button>
        <input type="range" min="0" max="1000" value="0" class="slider" id="progress-slider">
    </div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <h2>–¢–æ–ø–æ–ª–æ–≥—ñ—è –ö–∞—Ä—Ç–∏ –ö–∞—Ä–Ω–æ</h2>
            
            <p>–ö–∞—Ä—Ç–∞ –ö–∞—Ä–Ω–æ ‚Äî —Ü–µ –Ω–µ –ø—Ä–æ—Å—Ç–æ –ø–ª–æ—Å–∫–∞ —Ç–∞–±–ª–∏—Ü—è. –¶–µ —Ä–æ–∑–≥–æ—Ä—Ç–∫–∞ –±–∞–≥–∞—Ç–æ–≤–∏–º—ñ—Ä–Ω–æ–≥–æ –∫—É–±–∞ –Ω–∞ –ø–ª–æ—â–∏–Ω—É. –î–ª—è —Ç–æ–≥–æ, —â–æ–± –∑–±–µ—Ä–µ–≥—Ç–∏ –≤–ª–∞—Å—Ç–∏–≤—ñ—Å—Ç—å —Å—É—Å—ñ–¥—Å—Ç–≤–∞ (–∫–æ–¥ –ì—Ä–µ—è), –∫–∞—Ä—Ç—É —Å–ª—ñ–¥ —Ä–æ–∑–≥–ª—è–¥–∞—Ç–∏ —è–∫ –æ–±'—î–∫—Ç –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω—ñ <strong>–¢–æ—Ä–∞</strong>.</p>

            <div class="diagram-hint">
                üí° <strong>–Ü–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤:</strong> –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –ø–æ–≤–∑—É–Ω–æ–∫ –∑–Ω–∏–∑—É, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏, —è–∫ –ø–ª–æ—Å–∫–∞ –∫–∞—Ä—Ç–∞ –∑–≥–æ—Ä—Ç–∞—î—Ç—å—Å—è –Ω–∞–∑–∞–¥ —É –¢–æ—Ä.
            </div>

            <h3>1. –ß–æ–º—É –∫—Ä–∞—ó –∑'—î–¥–Ω–∞–Ω—ñ? (–¶–∏–ª—ñ–Ω–¥—Ä)</h3>
            <p>–£ –∫–∞—Ä—Ç—ñ –ö–∞—Ä–Ω–æ –∫–ª—ñ—Ç–∏–Ω–∫–∞ –∫—Ä–∞–π–Ω—å–æ–≥–æ –ª—ñ–≤–æ–≥–æ —Å—Ç–æ–≤–ø—Ü—è –≤–≤–∞–∂–∞—î—Ç—å—Å—è —Å—É—Å—ñ–¥–Ω—å–æ—é –¥–æ –∫–ª—ñ—Ç–∏–Ω–∫–∏ –∫—Ä–∞–π–Ω—å–æ–≥–æ –ø—Ä–∞–≤–æ–≥–æ —Å—Ç–æ–≤–ø—Ü—è (–≤ —Ç–æ–º—É –∂ —Ä—è–¥–∫—É). </p>
            <ul>
                <li>–ù–∞ –ø–ª–æ—â–∏–Ω—ñ –≤–æ–Ω–∏ –¥–∞–ª–µ–∫—ñ –æ–¥–Ω–∞ –≤—ñ–¥ –æ–¥–Ω–æ—ó.</li>
                <li>–Ø–∫—â–æ –º–∏ —Å–∫–ª–µ—ó–º–æ –ª—ñ–≤–∏–π —ñ –ø—Ä–∞–≤–∏–π –∫—Ä–∞—ó –∫–∞—Ä—Ç–∏, –º–∏ –æ—Ç—Ä–∏–º–∞—î–º–æ <strong>–¶–∏–ª—ñ–Ω–¥—Ä</strong>. –ù–∞ –ø–æ–≤–µ—Ä—Ö–Ω—ñ —Ü–∏–ª—ñ–Ω–¥—Ä–∞ —Ü—ñ –∫–ª—ñ—Ç–∏–Ω–∫–∏ —Ç–æ—Ä–∫–∞—é—Ç—å—Å—è.</li>
            </ul>

            <hr>

            <h3>2. –ß–æ–º—É –≤–µ—Ä—Ö —ñ –Ω–∏–∑ –∑'—î–¥–Ω–∞–Ω—ñ? (–¢–æ—Ä)</h3>
            <p>–ê–Ω–∞–ª–æ–≥—ñ—á–Ω–æ, –≤–µ—Ä—Ö–Ω—ñ–π —Ä—è–¥–æ–∫ —î —Å—É—Å—ñ–¥–Ω—ñ–º –¥–æ –Ω–∏–∂–Ω—å–æ–≥–æ. </p>
            <ul>
                <li><span class="highlight-red">–ß–µ—Ä–≤–æ–Ω—ñ —Ç–æ—á–∫–∏</span> –Ω–∞ —Å–∏–º—É–ª—è—Ü—ñ—ó –ø–æ–∫–∞–∑—É—é—Ç—å –∫–ª—ñ—Ç–∏–Ω–∫–∏ –Ω–∞ –≤–µ—Ä—Ö–Ω—ñ–π —Ç–∞ –Ω–∏–∂–Ω—ñ–π –º–µ–∂—ñ.</li>
                <li>–ö–æ–ª–∏ –º–∏ –∑–≥–∏–Ω–∞—î–º–æ —Ü–∏–ª—ñ–Ω–¥—Ä —ñ —Å–∫–ª–µ—é—î–º–æ –π–æ–≥–æ –≤–µ—Ä—Ö–Ω—î —Ç–∞ –Ω–∏–∂–Ω—î –∫–æ–ª–æ, –º–∏ –æ—Ç—Ä–∏–º—É—î–º–æ <strong>–¢–æ—Ä</strong> (—Ñ–æ—Ä–º—É –±—É–±–ª–∏–∫–∞).</li>
                <li>–£ —Ü–µ–π –º–æ–º–µ–Ω—Ç —á–µ—Ä–≤–æ–Ω—ñ —Ç–æ—á–∫–∏ —Ñ—ñ–∑–∏—á–Ω–æ –∑—É—Å—Ç—Ä—ñ—á–∞—é—Ç—å—Å—è —ñ —Å—Ç–∞—é—Ç—å —Å—É—Å—ñ–¥–∞–º–∏.</li>
            </ul>

            <hr>

            <h3>3. –§–µ–Ω–æ–º–µ–Ω –∫—É—Ç—ñ–≤ (–°–∏–Ω—ñ —Ç–æ—á–∫–∏)</h3>
            <p>–ù–∞–π—Ü—ñ–∫–∞–≤—ñ—à–µ –≤—ñ–¥–±—É–≤–∞—î—Ç—å—Å—è –∑ —á–æ—Ç–∏—Ä–º–∞ –∫—É—Ç–∞–º–∏ –∫–∞—Ä—Ç–∏:</p>
            <ul>
                <li><span class="highlight-blue">–°–∏–Ω—ñ —Ç–æ—á–∫–∏</span> –ø–æ–∑–Ω–∞—á–∞—é—Ç—å —á–æ—Ç–∏—Ä–∏ –∫—É—Ç–æ–≤—ñ –∫–ª—ñ—Ç–∏–Ω–∫–∏ –∫–∞—Ä—Ç–∏ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 0000, 0010, 1000, 1010).</li>
                <li>–ù–∞ –ø–ª–æ—â–∏–Ω—ñ –≤–æ–Ω–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≤—ñ–¥–¥–∞–ª–µ–Ω—ñ.</li>
                <li>–ê–ª–µ –Ω–∞ –¢–æ—Ä—ñ –≤—Å—ñ —á–æ—Ç–∏—Ä–∏ –∫—É—Ç–∏ —Å—Ö–æ–¥—è—Ç—å—Å—è –≤ <strong>–æ–¥–Ω—É —Ç–æ—á–∫—É</strong> (–∞–±–æ —Ç—ñ—Å–Ω—É –æ–±–ª–∞—Å—Ç—å).</li>
            </ul>
            <p>–°–∞–º–µ —Ç–æ–º—É –≤ –º–µ—Ç–æ–¥—ñ –∫–∞—Ä—Ç –ö–∞—Ä–Ω–æ –º–∏ –º–æ–∂–µ–º–æ –æ–±'—î–¥–Ω—É–≤–∞—Ç–∏ —á–æ—Ç–∏—Ä–∏ –∫—É—Ç–æ–≤—ñ –æ–¥–∏–Ω–∏—Ü—ñ –≤ –æ–¥–Ω—É –≥—Ä—É–ø—É ‚Äî —Ç–æ–ø–æ–ª–æ–≥—ñ—á–Ω–æ –≤–æ–Ω–∏ —É—Ç–≤–æ—Ä—é—é—Ç—å —î–¥–∏–Ω–∏–π –∫–ª–∞—Å—Ç–µ—Ä –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω—ñ —Ç–æ—Ä–∞.</p>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';

        let scene, camera, renderer, controls;
        let torusMesh, cylinderMesh, rectMesh, material;
        let slider, clock, playPauseButton;
        
        // --- –ö–û–ù–°–¢–ê–ù–¢–ò –ê–ù–Ü–ú–ê–¶–Ü–á ---
        const R0 = 6; 
        const r0 = 4; 
        const finalWidth = 2 * Math.PI * r0;  
        const finalHeight = 2 * Math.PI * R0; 
        const minTheta = 0.01;         
        const loopDuration = 10;       
        
        // --- –ï–¢–ê–ü–ò –¢–†–ê–ù–°–§–û–†–ú–ê–¶–Ü–á ---
        const t_TorusToCyl_End = 0.49;    
        const t_Cyl_Start = 0.51;         
        const t_CylToRect_End = 0.99;     

        // --- –°–¢–ê–ù –ê–ù–Ü–ú–ê–¶–Ü–á ---
        let manualControl = false; 
        let lastProgress = 0;      
        let animStartTime = 0;     
        let isPlaying = true; 

        // --- –ó–º—ñ–Ω–Ω—ñ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∏—á–Ω–∏—Ö —Ñ—É–Ω–∫—Ü—ñ–π ---
        let current_R, u_start, u_end; 
        let current_r;
        let current_gap_u = 0.0;
        let current_gap_v = 0.0;
        
        // --- –ó–º—ñ–Ω–Ω—ñ –¥–ª—è –ö–∞—Ä—Ç–∏ –ö–∞—Ä–Ω–æ ---
        let kMapGroup;
        let kMapLines = []; 
        let kMapMarkers = []; 
        
        const kMapLineMat = new THREE.LineBasicMaterial({ color: 0xffa500, linewidth: 2 });
        const vertexMatRed = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 });
        const vertexMatBlue = new THREE.MeshStandardMaterial({ color: 0x3366ff, emissive: 0x112255 });

        const EDGE_SEGMENTS = 40; 
        const MAX_EDGE_SPLITS = 4; 
        const tempVec = new THREE.Vector3(); 
        const mod = (n, m) => ((n % m) + m) % m; 

        function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            // –¢–µ–º–Ω—ñ—à–∏–π —Ñ–æ–Ω –¥–ª—è –∫—Ä–∞—â–æ–≥–æ –∫–æ–Ω—Ç—Ä–∞—Å—Ç—É –∑ –ø–æ—è—Å–Ω–µ–Ω–Ω—è–º–∏
            scene.background = new THREE.Color(0x1a1a1a); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(finalWidth * 0.8, finalHeight * 0.8, finalHeight * 0.8);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 0, 0); 

            const ambientLight = new THREE.AmbientLight(0x404040, 3);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);
            
            // Grid
            const gridHelper = new THREE.GridHelper(
                Math.max(finalWidth, finalHeight) * 2, 
                20, 
                0x444444, 0x222222
            );
            gridHelper.position.y = -5; 
            scene.add(gridHelper);

            // –û—Å–Ω–æ–≤–Ω–∏–π –º–∞—Ç–µ—Ä—ñ–∞–ª –ø–æ–≤–µ—Ä—Ö–Ω—ñ (–Ω–∞–ø—ñ–≤–ø—Ä–æ–∑–æ—Ä–∏–π)
            material = new THREE.MeshStandardMaterial({
                color: 0x004400,
                wireframe: false,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6,
                roughness: 0.2,
                metalness: 0.1
            });

            torusMesh = new THREE.Mesh(new THREE.BufferGeometry(), material);
            scene.add(torusMesh);

            cylinderMesh = new THREE.Mesh(new THREE.BufferGeometry(), material);
            scene.add(cylinderMesh);

            const rectGeo = new THREE.PlaneGeometry(finalHeight, finalWidth);
            rectGeo.rotateX(-Math.PI / 2); 
            rectMesh = new THREE.Mesh(rectGeo, material);
            rectMesh.position.y = 0; 
            rectMesh.visible = false;
            scene.add(rectMesh);

            // --- –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –¢–Ü–õ–¨–ö–ò –ö–∞—Ä—Ç–∏ –ö–∞—Ä–Ω–æ ---
            initKarnaughMap();

            // --- –û–±—Ä–æ–±–Ω–∏–∫–∏ UI ---
            slider = document.getElementById('progress-slider');
            slider.addEventListener('input', () => {
                const progress = parseFloat(slider.value) / 1000.0;
                updateAnimation(progress); 
                lastProgress = progress;
            });
            slider.addEventListener('pointerdown', () => {
                manualControl = true;
                if (isPlaying) { playPauseButton.textContent = 'Play'; }
            });
            slider.addEventListener('pointerup', () => {
                manualControl = false;
                lastProgress = parseFloat(slider.value) / 1000.0;
                animStartTime = clock.getElapsedTime();
                if (isPlaying) { playPauseButton.textContent = 'Pause'; }
            });

            playPauseButton = document.getElementById('play-pause-button');
            playPauseButton.addEventListener('click', togglePlayPause);

            // --- Modal Logic ---
            const modal = document.getElementById("modal");
            const btn = document.getElementById("info-btn");
            const span = document.getElementsByClassName("close-btn")[0];

            btn.onclick = function() {
                modal.style.display = "block";
            }
            span.onclick = function() {
                modal.style.display = "none";
            }
            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = "none";
                }
            }
            // –í—ñ–¥–∫—Ä–∏–≤–∞—î–º–æ –º–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç—ñ
            setTimeout(() => { modal.style.display = "block"; }, 500);

            window.addEventListener('resize', onWindowResize, false);
            
            updateAnimation(0);
        }

        function togglePlayPause() {
            isPlaying = !isPlaying;
            if (isPlaying) {
                playPauseButton.textContent = 'Pause';
                animStartTime = clock.getElapsedTime(); 
            } else {
                playPauseButton.textContent = 'Play';
                lastProgress = parseFloat(slider.value) / 1000.0; 
            }
        }

        // --- –ë–ª–æ–∫: –ö–∞—Ä—Ç–∞ –ö–∞—Ä–Ω–æ ---
        function initKarnaughMap() {
            kMapGroup = new THREE.Group();
            kMapLines = [];
            kMapMarkers = [];
            scene.add(kMapGroup);
            
            // 1. –õ—ñ–Ω—ñ—ó —Å—ñ—Ç–∫–∏ (4x4)
            const lineDefs = [];
            for (let i = 0; i <= 4; i++) { // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ñ
                const u = i * 0.25;
                lineDefs.push({ start_uv: {u_norm: u, v_norm: 0.0}, end_uv: {u_norm: u, v_norm: 1.0} });
            }
            for (let i = 0; i <= 4; i++) { // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ñ
                const v = i * 0.25;
                lineDefs.push({ start_uv: {u_norm: 0.0, v_norm: v}, end_uv: {u_norm: 1.0, v_norm: v} });
            }
            
            for (const def of lineDefs) {
                const edgeGroup = new THREE.Group();
                edgeGroup.userData = def; 
                edgeGroup.userData.linePool = [];
                for (let i = 0; i < MAX_EDGE_SPLITS; i++) {
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array((EDGE_SEGMENTS + 1) * 3), 3));
                    const line = new THREE.Line(geometry, kMapLineMat);
                    line.visible = false;
                    edgeGroup.userData.linePool.push(line);
                    edgeGroup.add(line);
                }
                kMapLines.push(edgeGroup);
                kMapGroup.add(edgeGroup);
            }
            
            // 2. –ú–∞—Ä–∫–µ—Ä–∏
            const markerGeo = new THREE.SphereGeometry(0.6, 24, 24); 
            const cellCenter = 0.125; // –¶–µ–Ω—Ç—Ä –ø–µ—Ä—à–æ—ó –∫–ª—ñ—Ç–∏–Ω–∫–∏
            
            // –°–ò–ù–Ü: –ö—É—Ç–∏ (0,0), (3,0), (0,3), (3,3)
            const blueCoords = [
                { u: cellCenter, v: cellCenter }, 
                { u: 1.0 - cellCenter, v: cellCenter },
                { u: cellCenter, v: 1.0 - cellCenter }, 
                { u: 1.0 - cellCenter, v: 1.0 - cellCenter }
            ];
            
            // –ß–ï–†–í–û–ù–Ü: –°—É—Å—ñ–¥—Å—Ç–≤–æ –≤–µ—Ä—Ö-–Ω–∏–∑ (—Å–µ—Ä–µ–¥–∏–Ω–∞ —Ç–∞–±–ª–∏—Ü—ñ)
            // –ö–ª—ñ—Ç–∏–Ω–∫–∏ (1,0) —Ç–∞ (1,3)
            const redCoords = [
                { u: cellCenter + 0.25, v: cellCenter },            
                { u: cellCenter + 0.25, v: 1.0 - cellCenter }       
            ];

            for (const uv of blueCoords) {
                const mesh = new THREE.Mesh(markerGeo, vertexMatBlue); 
                mesh.userData = { uv: uv };
                kMapMarkers.push(mesh);
                kMapGroup.add(mesh);
            }
            for (const uv of redCoords) {
                const mesh = new THREE.Mesh(markerGeo, vertexMatRed); 
                mesh.userData = { uv: uv };
                kMapMarkers.push(mesh);
                kMapGroup.add(mesh);
            }
        }

        // --- –ì–µ–æ–º–µ—Ç—Ä–∏—á–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó ---
        function getCurrentSurfacePoint(u_norm, v_norm, progress, target) {
            const u = mod(u_norm, 1.0);
            const v = mod(v_norm, 1.0);

            if (progress < t_TorusToCyl_End) {
                torusCutFunc(u, v, target);
            } else if (progress < t_Cyl_Start) {
                cylinderFunc(u, v, target);
            } else if (progress < t_CylToRect_End) {
                cylinderCutFunc(u, v, target);
            } else {
                // –ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫
                const x = THREE.MathUtils.lerp(-finalHeight / 2, finalHeight / 2, u);
                const z = THREE.MathUtils.lerp(-finalWidth / 2, finalWidth / 2, v);
                target.set(x, 0, z);
            }
        }

        function updateLineGroup(edgeGroup, progress, start_uv, end_uv) {
            const u_seam_is_open = current_gap_u > 0.001;
            const v_seam_is_open = current_gap_v > 0.001;
            const linePool = edgeGroup.userData.linePool;

            let du = end_uv.u_norm - start_uv.u_norm;
            let dv = end_uv.v_norm - start_uv.v_norm;
            
            let u_prev = start_uv.u_norm;
            let v_prev = start_uv.v_norm;
            let linePoolIndex = 0;
            let currentLine = linePool[linePoolIndex];
            currentLine.visible = true;
            let currentPos = currentLine.geometry.attributes.position;
            let pointIndex = 0;
            
            getCurrentSurfacePoint(u_prev, v_prev, progress, tempVec);
            currentPos.setXYZ(pointIndex++, tempVec.x, tempVec.y, tempVec.z);

            for (let i = 1; i <= EDGE_SEGMENTS; i++) {
                const t = i / EDGE_SEGMENTS;
                const u_curr = start_uv.u_norm + du * t;
                const v_curr = start_uv.v_norm + dv * t;
                
                const u_boundary_crossed = Math.floor(u_curr) !== Math.floor(u_prev);
                const v_boundary_crossed = Math.floor(v_curr) !== Math.floor(v_prev);
                u_prev = u_curr;
                v_prev = v_curr;

                let split = false;
                if (u_boundary_crossed && u_seam_is_open) split = true;
                if (v_boundary_crossed && v_seam_is_open) split = true;

                getCurrentSurfacePoint(u_curr, v_curr, progress, tempVec);

                if (split) {
                    currentPos.needsUpdate = true;
                    for (let k = pointIndex; k <= EDGE_SEGMENTS; k++) currentPos.setXYZ(k, tempVec.x, tempVec.y, tempVec.z);

                    linePoolIndex++;
                    if (linePoolIndex >= linePool.length) break; 
                    currentLine = linePool[linePoolIndex];
                    currentLine.visible = true;
                    currentPos = currentLine.geometry.attributes.position;
                    pointIndex = 0;
                    currentPos.setXYZ(pointIndex++, tempVec.x, tempVec.y, tempVec.z);
                } else {
                    if (pointIndex <= EDGE_SEGMENTS) {
                         currentPos.setXYZ(pointIndex++, tempVec.x, tempVec.y, tempVec.z);
                    }
                }
            }
            currentPos.needsUpdate = true;
            for (let k = pointIndex; k <= EDGE_SEGMENTS; k++) currentPos.setXYZ(k, tempVec.x, tempVec.y, tempVec.z);
            for (let i = linePoolIndex + 1; i < linePool.length; i++) linePool[i].visible = false;
        }

        function updateKarnaughMap(progress) {
            if (!kMapGroup) return;
            
            // –õ—ñ–Ω—ñ—ó
            for (let j = 0; j < kMapLines.length; j++) {
                const edgeGroup = kMapLines[j];
                updateLineGroup(edgeGroup, progress, edgeGroup.userData.start_uv, edgeGroup.userData.end_uv);
            }
            
            // –ú–∞—Ä–∫–µ—Ä–∏
            for (const marker of kMapMarkers) {
                const { u, v } = marker.userData.uv;
                getCurrentSurfacePoint(u, v, progress, marker.position);
            }
        }
        
        // --- –ü–∞—Ä–∞–º–µ—Ç—Ä–∏—á–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó ---
        function torusCutFunc(u_norm, v_norm, target) {
            const u = THREE.MathUtils.lerp(u_start, u_end, u_norm);
            const v = THREE.MathUtils.lerp(-Math.PI, Math.PI, v_norm);
            target.x = (current_R + r0 * Math.cos(v)) * Math.cos(u);
            target.y = (current_R + r0) + (current_R + r0 * Math.cos(v)) * Math.sin(u);
            target.z = r0 * Math.sin(v);
        }
        function cylinderFunc(u_norm, v_norm, target) {
            const h = THREE.MathUtils.lerp(-finalHeight / 2, finalHeight / 2, u_norm);
            const v_angle = THREE.MathUtils.lerp(-Math.PI, Math.PI, v_norm);
            target.x = h;
            target.y = r0 - r0 * Math.cos(v_angle);
            target.z = r0 * Math.sin(v_angle);
        }
        function cylinderCutFunc(u_norm, v_norm, target) {
            const h = THREE.MathUtils.lerp(-finalHeight / 2, finalHeight / 2, u_norm);
            current_r = (Math.PI * r0) / (Math.PI - current_gap_v);
            const v_angle = THREE.MathUtils.lerp(-(Math.PI - current_gap_v), (Math.PI - current_gap_v), v_norm);
            target.x = h;
            target.y = current_r - current_r * Math.cos(v_angle);
            target.z = current_r * Math.sin(v_angle);
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updateAnimation(progress) {
            torusMesh.visible = false;
            cylinderMesh.visible = false;
            rectMesh.visible = false;
            current_gap_u = 0.0;
            current_gap_v = 0.0;
            let geom;
            const segmentsU = 80; 
            const segmentsV = 40; 

            if (progress < t_TorusToCyl_End) {
                torusMesh.visible = true;
                const p1 = progress / t_TorusToCyl_End; 
                current_gap_u = THREE.MathUtils.lerp(0, Math.PI - minTheta, p1);
                current_R = (Math.PI * R0) / (Math.PI - current_gap_u);
                u_start = (3 * Math.PI / 2) - (Math.PI - current_gap_u); 
                u_end = (3 * Math.PI / 2) + (Math.PI - current_gap_u);   
                geom = new ParametricGeometry(torusCutFunc, segmentsU, segmentsV);
                torusMesh.geometry.dispose();
                torusMesh.geometry = geom;
            } else if (progress < t_Cyl_Start) {
                cylinderMesh.visible = true;
                current_gap_u = Math.PI - minTheta;
                if (!cylinderMesh.geometry.attributes.position || manualControl) {
                     geom = new ParametricGeometry(cylinderFunc, segmentsU, segmentsV);
                     cylinderMesh.geometry.dispose();
                     cylinderMesh.geometry = geom;
                }
            } else if (progress < t_CylToRect_End) {
                cylinderMesh.visible = true;
                current_gap_u = Math.PI - minTheta;
                const p2 = (progress - t_Cyl_Start) / (t_CylToRect_End - t_Cyl_Start);
                current_gap_v = THREE.MathUtils.lerp(0, Math.PI - minTheta, p2);
                geom = new ParametricGeometry(cylinderCutFunc, segmentsU, segmentsV);
                cylinderMesh.geometry.dispose();
                cylinderMesh.geometry = geom;
            } else {
                rectMesh.visible = true;
                current_gap_u = Math.PI - minTheta;
                current_gap_v = Math.PI - minTheta;
            }

            // –ó–∞–≤–∂–¥–∏ –æ–Ω–æ–≤–ª—é—î–º–æ –ö–∞—Ä—Ç—É –ö–∞—Ä–Ω–æ
            updateKarnaughMap(progress);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!manualControl && isPlaying) {
                const timeSinceResume = clock.getElapsedTime() - animStartTime;
                const progress = (lastProgress + (timeSinceResume / loopDuration)) % 1.0;
                updateAnimation(progress);
                slider.value = progress * 1000; 
            }
            controls.update();
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>