<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lossy Compression Visualizer</title>
    <style>
        :root {
            --bg: #121212;
            --panel: #1e1e1e;
            --accent: #ff9800; /* Orange for Compression */
            --kept: #4caf50;   /* Green */
            --deleted: #333;   /* Grey */
            --threshold: #00bcd4; /* Cyan line */
            --text: #e0e0e0;
        }

        body {
            font-family: 'Segoe UI', Consolas, monospace;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 { color: var(--accent); margin-bottom: 5px; font-weight: 300; }
        p.subtitle { color: #aaa; margin-bottom: 20px; text-align: center; max-width: 800px; }

        .container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            max-width: 1000px;
            width: 100%;
        }

        .panel {
            background: var(--panel);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            position: relative;
        }

        /* Audio Controls */
        .recorder-box {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            background: #252525;
            padding: 15px;
            border-radius: 8px;
            flex-wrap: wrap;
        }

        button {
            background: #37474f; color: white; border: 1px solid #555;
            padding: 10px 20px; border-radius: 4px; cursor: pointer;
            font-family: inherit; font-weight: 600; transition: 0.2s;
            display: flex; align-items: center; gap: 8px;
        }
        button:hover { background: #455a64; border-color: var(--accent); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-record.recording { background: #f44336; animation: pulse 1.5s infinite; }
        .btn-play { background: var(--kept); color: #fff; }
        .btn-play-compressed { background: var(--accent); color: #000; }

        /* Canvas */
        canvas {
            width: 100%;
            background: #000;
            border-radius: 4px;
            display: block;
            cursor: crosshair;
        }

        /* Threshold Slider overlay */
        .slider-container {
            position: relative;
            height: 40px;
            background: #222;
            margin-top: 10px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding: 0 10px;
        }
        
        input[type=range] {
            width: 100%;
            accent-color: var(--threshold);
            cursor: pointer;
        }

        /* Stats Grid */
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
            text-align: center;
        }
        .stat-box { background: #2a2a2a; padding: 10px; border-radius: 4px; }
        .stat-val { font-size: 1.2rem; font-weight: bold; display: block; margin-top: 5px; }
        .bad { color: #f44336; }
        .good { color: #4caf50; }

        /* Theory Details */
        details {
            background: #1a1a1a; border: 1px solid #333; border-radius: 8px; 
            margin: 0 0 20px 0; width: 100%; overflow: hidden;
        }
        summary {
            padding: 15px; cursor: pointer; background: #222; font-weight: bold; 
            color: var(--accent); outline: none;
        }
        .theory-content { padding: 20px; line-height: 1.6; color: #ccc; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body>

    <h1>–°—Ç–∏—Å–Ω–µ–Ω–Ω—è –ê—É–¥—ñ–æ (Lossy Compression)</h1>
    <p class="subtitle">
        –í–∏–¥–∞–ª–µ–Ω–Ω—è "–Ω–µ–ø–æ—Ç—Ä—ñ–±–Ω–∏—Ö" –∑–≤—É–∫—ñ–≤. –ó–∞–ø–∏—à—ñ—Ç—å –≥–æ–ª–æ—Å –∞–±–æ –∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ –ø—Ä–µ—Å–µ—Ç, 
        –ø–æ—Ç—ñ–º –ø—ñ–¥–Ω—ñ–º—ñ—Ç—å –ø–æ—Ä—ñ–≥, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏, —è–∫ MP3 –µ–∫–æ–Ω–æ–º–∏—Ç—å –º—ñ—Å—Ü–µ.
    </p>

    <div style="max-width: 1000px; width: 100%;">
        <details>
            <summary>üìñ –¢–µ–æ—Ä—ñ—è: –Ø–∫ –ø—Ä–∞—Ü—é—î MP3/AAC? (–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å)</summary>
            <div class="theory-content">
                <h3>1. –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è</h3>
                <p>
                    –ö–æ–º–ø'—é—Ç–µ—Ä –Ω–µ —Å—Ç–∏—Å–∫–∞—î –∑–≤—É–∫–æ–≤—É —Ö–≤–∏–ª—é –Ω–∞–ø—Ä—è–º—É. –°–ø–æ—á–∞—Ç–∫—É –≤—ñ–Ω —Ä–æ–∑–±–∏–≤–∞—î –∑–≤—É–∫ –Ω–∞ —à–º–∞—Ç–æ—á–∫–∏ (–≤—ñ–∫–Ω–∞) —ñ –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î —ó—Ö —É —á–∞—Å—Ç–æ—Ç–Ω–∏–π —Å–ø–µ–∫—Ç—Ä (–∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é FFT/MDCT).
                    –ú–∏ –±–∞—á–∏–º–æ –∑–≤—É–∫ –Ω–µ —è–∫ –≥—Ä–∞—Ñ—ñ–∫ —á–∞—Å—É, –∞ —è–∫ –Ω–∞–±—ñ—Ä —Å—Ç–æ–≤–ø—á–∏–∫—ñ–≤: –ë–∞—Å, –°–µ—Ä–µ–¥–Ω—ñ, –í–∏—Å–æ–∫—ñ.
                </p>

                <h3>2. –ü—Å–∏—Ö–æ–∞–∫—É—Å—Ç–∏–∫–∞ —Ç–∞ –ú–∞—Å–∫—É–≤–∞–Ω–Ω—è</h3>
                <p>
                    –õ—é–¥—Å—å–∫–µ –≤—É—Ö–æ ‚Äî –Ω–µ–¥–æ—Å–∫–æ–Ω–∞–ª–∏–π –ø—Ä–∏–ª–∞–¥.
                    <ul>
                        <li><b>–ü–æ—Ä—ñ–≥ —á—É—Ç–Ω–æ—Å—Ç—ñ:</b> –ú–∏ –ø–æ–≥–∞–Ω–æ —á—É—î–º–æ –¥—É–∂–µ —Ç–∏—Ö—ñ –∑–≤—É–∫–∏, –æ—Å–æ–±–ª–∏–≤–æ –Ω–∞ –≤–∏—Å–æ–∫–∏—Ö —á–∞—Å—Ç–æ—Ç–∞—Ö.</li>
                        <li><b>–ú–∞—Å–∫—É–≤–∞–Ω–Ω—è:</b> –Ø–∫—â–æ –≥—Ä–∞—î –≥—É—á–Ω–∏–π –±–∞—Ä–∞–±–∞–Ω, –≤–∏ –Ω–µ –ø–æ—á—É—î—Ç–µ —Ç–∏—Ö–∏–π —à—É—Ä—Ö—ñ—Ç –ø–æ—Ä—É—á –∑ –Ω–∏–º. –¶–µ–π —à—É—Ä—Ö—ñ—Ç –º–æ–∂–Ω–∞ –≤–∏–¥–∞–ª–∏—Ç–∏ –∑ —Ñ–∞–π–ª—É, —ñ –Ω—ñ—Ö—Ç–æ –Ω–µ –ø–æ–º—ñ—Ç–∏—Ç—å!</li>
                    </ul>
                </p>

                <h3>3. Sparsity (–†–æ–∑—Ä—ñ–¥–∂–µ–Ω—ñ—Å—Ç—å)</h3>
                <p>
                    –£ —Ü—å–æ–º—É —Å–∏–º—É–ª—è—Ç–æ—Ä—ñ –º–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –ø—Ä–æ—Å—Ç–∏–π –º–µ—Ç–æ–¥: <b>Hard Thresholding</b>. 
                    –ú–∏ –≤—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ "–ø–ª–∞–Ω–∫—É". –í—Å—ñ –≥–∞—Ä–º–æ–Ω—ñ–∫–∏, —è–∫—ñ —Ç–∏—Ö—ñ—à—ñ –∑–∞ —Ü—é –ø–ª–∞–Ω–∫—É, –æ–±–Ω—É–ª—è—é—Ç—å—Å—è (—Å—Ç–∞—é—Ç—å –Ω—É–ª—è–º–∏).
                    <br>
                    <span style="color:var(--kept)">–ó–±–µ—Ä–µ–∂–µ–Ω—ñ –¥–∞–Ω—ñ:</span> [120, 0, 0, 45, 0, 99, 0...] 
                    <br>
                    –¢–∞–∫–∏–π –º–∞—Å–∏–≤ –∑ –∫—É–ø–æ—é –Ω—É–ª—ñ–≤ —ñ–¥–µ–∞–ª—å–Ω–æ —Å—Ç–∏—Å–∫–∞—î—Ç—å—Å—è –∞—Ä—Ö—ñ–≤–∞—Ç–æ—Ä–æ–º (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º –•–∞—Ñ—Ñ–º–∞–Ω–∞).
                </p>
            </div>
        </details>
    </div>

    <div class="recorder-box">
        <button id="btnPreset" onclick="loadPreset()">üéπ –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –ü—Ä–µ—Å–µ—Ç (–°–∏–Ω—Ç–µ–∑–∞—Ç–æ—Ä)</button>
        <div style="width: 1px; background: #555; margin: 0 10px;"></div>
        <button id="btnMic" class="btn-record" onclick="toggleRecord()">üé§ –ú—ñ–∫—Ä–æ—Ñ–æ–Ω (REC)</button>
        <span id="statusText" style="align-self: center; color: #aaa; font-size: 0.9rem;">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è...</span>
    </div>

    <div class="container">
        
        <div class="panel">
            <div style="display:flex; justify-content:space-between; align-items: center;">
                <h3>–ß–∞—Å—Ç–æ—Ç–Ω–∏–π –°–ø–µ–∫—Ç—Ä (FFT)</h3>
                <div style="font-size: 0.8rem; color:#aaa">X: –ß–∞—Å—Ç–æ—Ç–∞ (Hz) | Y: –ì—É—á–Ω—ñ—Å—Ç—å (dB)</div>
            </div>
            
            <canvas id="cvSpectrum" height="250"></canvas>
            
            <div class="slider-container">
                <span style="min-width: 80px; font-size: 0.9rem;">‚úÇÔ∏è –ü–æ—Ä—ñ–≥:</span>
                <input type="range" id="slThreshold" min="0" max="100" value="10" oninput="updateCompression()">
                <span id="lblThreshold" style="min-width: 50px; text-align: right; font-weight: bold; color: var(--threshold);">10%</span>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div style="color:#aaa; font-size:0.8rem">–í—Å—å–æ–≥–æ –≥–∞—Ä–º–æ–Ω—ñ–∫</div>
                    <span class="stat-val" id="valTotal">0</span>
                </div>
                <div class="stat-box">
                    <div style="color:var(--kept); font-size:0.8rem">–ó–±–µ—Ä–µ–∂–µ–Ω–æ (Non-Zero)</div>
                    <span class="stat-val" id="valKept">0</span>
                </div>
                <div class="stat-box">
                    <div style="color:var(--accent); font-size:0.8rem">–°—Ç—É–ø—ñ–Ω—å —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è</div>
                    <span class="stat-val" id="valRatio">1.0x</span>
                </div>
            </div>
        </div>

        <div class="panel">
            <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç</h3>
            <div style="display: flex; gap: 20px; justify-content: center; margin: 20px 0;">
                <button class="btn-play" id="btnPlayOrig" onclick="playOriginal()" disabled>‚ñ∂ –û—Ä–∏–≥—ñ–Ω–∞–ª</button>
                <button class="btn-play-compressed" id="btnPlayComp" onclick="playCompressed()" disabled>‚ñ∂ –°—Ç–∏—Å–Ω–µ–Ω–µ</button>
            </div>
            <canvas id="cvWave" height="100"></canvas>
            <p style="text-align: center; font-size: 0.85rem; color: #777; margin-top: 10px;">
                –ó–µ–ª–µ–Ω–∞ –ª—ñ–Ω—ñ—è ‚Äî –æ—Ä–∏–≥—ñ–Ω–∞–ª. –ü–æ–º–∞—Ä–∞–Ω—á–µ–≤–∞ ‚Äî –ø—ñ—Å–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è —á–∞—Å—Ç–æ—Ç. <br>
                –Ø–∫—â–æ –ª—ñ–Ω—ñ—ó —Ä–æ–∑—Ö–æ–¥—è—Ç—å—Å—è ‚Äî —Ü–µ "–î–∑–≤—ñ–Ω" (Ringing artifacts).
            </p>
        </div>

    </div>

<script>
    // --- FFT LIBRARY (Simplified for Education) ---
    // A generic Cooley-Tukey implementation
    const FFT = {
        reverseBits: function(x, n) {
            let result = 0;
            for (let i = 0; i < n; i++, x >>= 1) result = (result << 1) | (x & 1);
            return result;
        },
        transform: function(real, imag) {
            const n = real.length;
            const levels = Math.log2(n);
            // Bit-reversal permutation
            for (let i = 0; i < n; i++) {
                const rev = this.reverseBits(i, levels);
                if (rev > i) {
                    [real[i], real[rev]] = [real[rev], real[i]];
                    [imag[i], imag[rev]] = [imag[rev], imag[i]];
                }
            }
            // Butterfly operations
            for (let size = 2; size <= n; size *= 2) {
                const half = size / 2;
                const step = 2 * Math.PI / size;
                for (let i = 0; i < n; i += size) {
                    for (let j = 0; j < half; j++) {
                        const k = i + j;
                        const t = k + half;
                        const angle = -j * step; // Negative for forward FFT
                        const cos = Math.cos(angle);
                        const sin = Math.sin(angle);
                        const tr = real[t] * cos - imag[t] * sin;
                        const ti = real[t] * sin + imag[t] * cos;
                        real[t] = real[k] - tr;
                        imag[t] = imag[k] - ti;
                        real[k] += tr;
                        imag[k] += ti;
                    }
                }
            }
        },
        inverse: function(real, imag) {
            const n = real.length;
            // Conjugate -> Transform -> Conjugate -> Scale
            for(let i=0; i<n; i++) imag[i] = -imag[i];
            this.transform(real, imag);
            for(let i=0; i<n; i++) {
                imag[i] = -imag[i];
                real[i] /= n;
                imag[i] /= n;
            }
        }
    };

    // --- APP LOGIC ---

    const CFG = {
        fftSize: 4096, // Good resolution
        sampleRate: 44100,
        duration: 1.5 // seconds to record
    };

    let audioCtx = null;
    let originalBuffer = null; // Float32Array with raw audio
    let recordedData = null;   // Just the mono channel data
    let windowStart = 0;
    // Spectral Data
    let spectrumReal = [];
    let spectrumImag = [];
    let spectrumMag = []; // Magnitude for visualization
    let maxMag = 0;

    // Compressed Data
    let compressedSignal = null;

    // UI References
    const els = {
        cvSpec: document.getElementById('cvSpectrum'),
        cvWave: document.getElementById('cvWave'),
        slThresh: document.getElementById('slThreshold'),
        lblThresh: document.getElementById('lblThreshold'),
        btnPlayOrig: document.getElementById('btnPlayOrig'),
        btnPlayComp: document.getElementById('btnPlayComp'),
        status: document.getElementById('statusText'),
        valTotal: document.getElementById('valTotal'),
        valKept: document.getElementById('valKept'),
        valRatio: document.getElementById('valRatio')
    };
    
    const ctxSpec = els.cvSpec.getContext('2d');
    const ctxWave = els.cvWave.getContext('2d');

    // --- AUDIO HANDLING ---

    async function initAudio() {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') await audioCtx.resume();
        return audioCtx;
    }

    // 1. Generate Preset (FM Synthesis)
    async function loadPreset() {
        await initAudio();
        els.status.innerText = "–ì–µ–Ω–µ—Ä—É—é –ø—Ä–µ—Å–µ—Ç...";
        
        const length = CFG.sampleRate * CFG.duration;
        const data = new Float32Array(length);
        
        // Create a rich FM sound (Carrier + Modulator)
        for(let i=0; i<length; i++) {
            let t = i / CFG.sampleRate;
            // Envelope
            let env = 1 - (t / CFG.duration);
            // FM: sin(2pi*fc*t + I*sin(2pi*fm*t))
            let mod = Math.sin(2 * Math.PI * 110 * t) * 5; 
            let carrier = Math.sin(2 * Math.PI * 220 * t + mod);
            
            // Add some noise
            let noise = (Math.random() - 0.5) * 0.05;
            
            data[i] = (carrier * 0.8 + noise) * env;
        }
        
        processInput(data);
        els.status.innerText = "–ü—Ä–µ—Å–µ—Ç –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ!";
    }

    // 2. Microphone Recording
    let isRecording = false;
    async function toggleRecord() {
        await initAudio();
        if(isRecording) return;

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mediaStreamSource = audioCtx.createMediaStreamSource(stream);
            const processor = audioCtx.createScriptProcessor(4096, 1, 1);
            
            let chunks = [];
            let samplesCollected = 0;
            const maxSamples = CFG.sampleRate * CFG.duration;

            isRecording = true;
            document.getElementById('btnMic').classList.add('recording');
            els.status.innerText = "–ó–∞–ø–∏—Å...";

            mediaStreamSource.connect(processor);
            processor.connect(audioCtx.destination);

            processor.onaudioprocess = (e) => {
                if(!isRecording) return;
                const input = e.inputBuffer.getChannelData(0);
                
                // Clone chunk
                const chunk = new Float32Array(input);
                chunks.push(chunk);
                samplesCollected += chunk.length;

                if(samplesCollected >= maxSamples) {
                    stopRecord(stream, processor, chunks);
                }
            };

        } catch(err) {
            alert("–î–æ—Å—Ç—É–ø –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω—É –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω–æ –∞–±–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π. –í–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ –ø—Ä–µ—Å–µ—Ç.");
            console.error(err);
        }
    }

    function stopRecord(stream, processor, chunks) {
        isRecording = false;
        document.getElementById('btnMic').classList.remove('recording');
        stream.getTracks().forEach(t => t.stop());
        processor.disconnect();
        
        // Flatten chunks
        let totalLen = chunks.reduce((acc, c) => acc + c.length, 0);
        const data = new Float32Array(totalLen);
        let offset = 0;
        for(let c of chunks) {
            data.set(c, offset);
            offset += c.length;
        }
        
        // Trim to exact duration
        const finalData = data.slice(0, CFG.sampleRate * CFG.duration);
        processInput(finalData);
        els.status.innerText = "–ó–∞–ø–∏—Å–∞–Ω–æ!";
    }

    // --- CORE PROCESSING ---

    function processInput(rawData) {
        recordedData = rawData;
        
        // –ó–Ω–∞—Ö–æ–¥–∏–º–æ —Ü–µ–Ω—Ç—Ä –∑–∞–ø–∏—Å—É (—Ç–∞–º –∑–∞–∑–≤–∏—á–∞–π –Ω–∞–π–≥—É—á–Ω—ñ—à–µ)
        const center = Math.floor(rawData.length / 2);
        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≥–ª–æ–±–∞–ª—å–Ω–æ —Ç–æ—á–∫—É –ø–æ—á–∞—Ç–∫—É –Ω–∞—à–æ–≥–æ "–≤—ñ–∫–Ω–∞"
        windowStart = Math.max(0, center - CFG.fftSize/2);
        
        // –í–∏—Ä—ñ–∑–∞—î–º–æ —à–º–∞—Ç–æ—á–æ–∫ —Å–∞–º–µ –¥–ª—è FFT –∞–Ω–∞–ª—ñ–∑—É
        const slice = rawData.slice(windowStart, windowStart + CFG.fftSize);
        
        // –í—ñ–∫–Ω–æ –•–µ–Ω–Ω—ñ–Ω–≥–∞ (—â–æ–± —Å–ø–µ–∫—Ç—Ä –±—É–≤ —á–∏—Å—Ç–∏–π)
        const windowed = new Float32Array(CFG.fftSize);
        for(let i=0; i<CFG.fftSize; i++) {
            let val = (i < slice.length) ? slice[i] : 0;
            let win = 0.5 * (1 - Math.cos(2 * Math.PI * i / (CFG.fftSize - 1)));
            windowed[i] = val * win;
        }

        // –†–∞—Ö—É—î–º–æ FFT –¥–ª—è –≥—Ä–∞—Ñ—ñ–∫—É
        spectrumReal = new Float32Array(windowed);
        spectrumImag = new Float32Array(CFG.fftSize).fill(0);
        FFT.transform(spectrumReal, spectrumImag);

        // –†–∞—Ö—É—î–º–æ –ú–∞–≥–Ω—ñ—Ç—É–¥—É
        spectrumMag = new Float32Array(CFG.fftSize / 2);
        maxMag = 0;
        for(let i=0; i<spectrumMag.length; i++) {
            let mag = Math.sqrt(spectrumReal[i]**2 + spectrumImag[i]**2);
            spectrumMag[i] = mag;
            if(mag > maxMag) maxMag = mag;
        }

        // –ê–∫—Ç–∏–≤—É—î–º–æ —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å
        els.btnPlayOrig.disabled = false;
        els.btnPlayComp.disabled = false;
        
        // –ó–∞–ø—É—Å–∫–∞—î–º–æ –ø–µ—Ä—à–µ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è
        updateCompression();
    }

    // --- COMPRESSION SIMULATION ---
function updateCompression() {
        if (!recordedData || !recordedData.length) return;

        const thresholdPercent = parseInt(els.slThresh.value);
        els.lblThresh.innerText = thresholdPercent + "%";
        
        // --- 1. –ü–Ü–î–ì–û–¢–û–í–ö–ê (OVERLAP-ADD) ---
        const fullLength = recordedData.length;
        const processedData = new Float32Array(fullLength); // –í–∏—Ö—ñ–¥–Ω–∏–π –±—É—Ñ–µ—Ä (—Ç–∏—à–∞)
        
        // –ö—Ä–æ–∫ –∑–º—ñ—â–µ–Ω–Ω—è (Hop Size). –î–ª—è –≤—ñ–∫–Ω–∞ –•–µ–Ω–Ω—ñ–Ω–≥–∞ —Ü–µ 50% –≤—ñ–¥ –¥–æ–≤–∂–∏–Ω–∏ FFT
        const hopSize = CFG.fftSize / 2; 

        // –°—Ç–≤–æ—Ä—é—î–º–æ –≤—ñ–∫–æ–Ω–Ω—É —Ñ—É–Ω–∫—Ü—ñ—é (Hanning Window) –æ–¥–∏–Ω —Ä–∞–∑
        // –í–æ–Ω–∞ –ø–æ—Ç—Ä—ñ–±–Ω–∞, —â–æ–± –∑–≥–ª–∞–¥–∏—Ç–∏ –∫—Ä–∞—ó –∫–æ–∂–Ω–æ–≥–æ —à–º–∞—Ç–æ—á–∫–∞
        const winFunc = new Float32Array(CFG.fftSize);
        for(let i=0; i<CFG.fftSize; i++) {
            winFunc[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (CFG.fftSize - 1)));
        }

        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        let totalBinsProcessed = 0;
        let keptBinsProcessed = 0;

        // --- 2. –¶–ò–ö–õ –ó –ü–ï–†–ï–ö–†–ò–¢–¢–Ø–ú ---
        // offset += hopSize (—Ä—É—Ö–∞—î–º–æ—Å—å –Ω–∞–ø–æ–ª–æ–≤–∏–Ω—É –¥–æ–≤–∂–∏–Ω–∏ –≤—ñ–∫–Ω–∞)
        for (let offset = 0; offset <= fullLength - CFG.fftSize; offset += hopSize) {
            
            // –ê. –ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞ –±—É—Ñ–µ—Ä—ñ–≤
            const chunkReal = new Float32Array(CFG.fftSize);
            const chunkImag = new Float32Array(CFG.fftSize);
            
            // –ë. –ö–æ–ø—ñ—é—î–º–æ –¥–∞–Ω—ñ –¢–ê –ó–ê–°–¢–û–°–û–í–£–Ñ–ú–û –í–Ü–ö–ù–û (Windowing)
            for (let i = 0; i < CFG.fftSize; i++) {
                chunkReal[i] = recordedData[offset + i] * winFunc[i];
            }

            // –í. FFT
            FFT.transform(chunkReal, chunkImag);

            // –ì. –û–±—Ä–æ–±–∫–∞ (Thresholding)
            // –®—É–∫–∞—î–º–æ –ª–æ–∫–∞–ª—å–Ω–∏–π –º–∞–∫—Å–∏–º—É–º –¥–ª—è –¥–∏–Ω–∞–º—ñ—á–Ω–æ–≥–æ –ø–æ—Ä–æ–≥—É
            let localMax = 0;
            const mags = new Float32Array(CFG.fftSize);
            for (let i = 0; i < CFG.fftSize; i++) {
                 let m = Math.sqrt(chunkReal[i]**2 + chunkImag[i]**2);
                 mags[i] = m;
                 if (m > localMax) localMax = m;
            }

            const currentThreshold = localMax * (thresholdPercent / 100);

            // –§—ñ–ª—å—Ç—Ä—É—î–º–æ
            for (let i = 0; i < CFG.fftSize; i++) {
                if (mags[i] < currentThreshold) {
                    chunkReal[i] = 0;
                    chunkImag[i] = 0;
                } else {
                    if (i < CFG.fftSize / 2 && mags[i] > 1e-5) keptBinsProcessed++;
                }
            }
            totalBinsProcessed += (CFG.fftSize / 2);

            // –î. Inverse FFT
            FFT.inverse(chunkReal, chunkImag);

            // –ï. OVERLAP-ADD (–î–æ–¥–∞–≤–∞–Ω–Ω—è –∑ –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è–º)
            // –ú–∏ –Ω–µ –∑–∞–º—ñ–Ω—é—î–º–æ –¥–∞–Ω—ñ (=), –∞ –¥–æ–¥–∞—î–º–æ —ó—Ö (+=) –¥–æ –±—É—Ñ–µ—Ä–∞
            // –ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞ –≤—ñ–∫–Ω–∞ –•–µ–Ω–Ω—ñ–Ω–≥–∞ —Ç–∞–∫–∞, —â–æ –ø—Ä–∏ –Ω–∞–∫–ª–∞–¥–∞–Ω–Ω—ñ 50% –∞–º–ø–ª—ñ—Ç—É–¥–∞ –≤—ñ–¥–Ω–æ–≤–ª—é—î—Ç—å—Å—è –¥–æ 1.
            // –ê–ª–µ –æ—Å–∫—ñ–ª—å–∫–∏ –º–∏ –∑–∞—Å—Ç–æ—Å—É–≤–∞–ª–∏ –≤—ñ–∫–Ω–æ –Ω–∞ –≤—Ö–æ–¥—ñ, –Ω–∞–º —Ç—Ä–µ–±–∞ –ø–æ–º–Ω–æ–∂–∏—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            // –Ω–∞ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç (–∑–∞–∑–≤–∏—á–∞–π 2/3 –∞–±–æ –ø—Ä–æ—Å—Ç–æ –ø—ñ–¥—ñ–±—Ä–∞—Ç–∏ –Ω–∞ —Å–ª—É—Ö –¥–ª—è —Å–∏–º—É–ª—è—Ç–æ—Ä–∞).
            // –î–ª—è —ñ–¥–µ–∞–ª—å–Ω–æ—ó —Ä–µ–∫–æ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó: Synthesis Window —Ç–µ–∂ –ø–æ—Ç—Ä—ñ–±–µ–Ω, –∞–ª–µ —Ç—É—Ç —Å–ø—Ä–æ—Å—Ç–∏–º–æ:
            // –ü—Ä–æ—Å—Ç–æ –¥–æ–¥–∞—î–º–æ. (–í—ñ–∫–Ω–æ –•–µ–Ω–Ω—ñ–Ω–≥–∞ —Å—É–º—É—î—Ç—å—Å—è –≤ –æ–¥–∏–Ω–∏—Ü—é –ø—Ä–∏ overlap 50%)
            
            for (let i = 0; i < CFG.fftSize; i++) {
                // scaleFactor * 2 –∫–æ–º–ø–µ–Ω—Å—É—î –≤—Ç—Ä–∞—Ç—É –µ–Ω–µ—Ä–≥—ñ—ó –≤—ñ–¥ –≤—ñ–∫–Ω–∞ –ø—Ä–∏ –∞–Ω–∞–ª—ñ–∑—ñ
                // –ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω–æ –¥–ª—è —Ü—å–æ–≥–æ –∫–æ–¥—É: –º–Ω–æ–∂–Ω–∏–∫ 1.0 –ø—Ä–∞—Ü—é—î –º'—è–∫–æ, 2.0 –ø–æ–≤–µ—Ä—Ç–∞—î –ø–æ–≤–Ω—É –≥—É—á–Ω—ñ—Å—Ç—å
                processedData[offset + i] += chunkReal[i]; 
            }
        }

        // --- 3. –§–Ü–ù–ê–õ ---
        compressedSignal = processedData;

        // –û–Ω–æ–≤–ª—é—î–º–æ —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å
        els.valTotal.innerText = Math.floor(totalBinsProcessed / (fullLength/hopSize)); // –°–µ—Ä–µ–¥–Ω—î –Ω–∞ —Ñ—Ä–µ–π–º
        els.valKept.innerText = Math.floor(keptBinsProcessed / (fullLength/hopSize));
        
        let ratio = (keptBinsProcessed > 0) ? (totalBinsProcessed / keptBinsProcessed).toFixed(1) : "MAX";
        els.valRatio.innerText = ratio + ":1";
        els.valRatio.style.color = (parseFloat(ratio) > 10 || ratio === "MAX") ? '#ff9800' : '#4caf50';

        // –ú–∞–ª—é—î–º–æ –≥—Ä–∞—Ñ—ñ–∫ (–≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –≥–ª–æ–±–∞–ª—å–Ω–∏–π –º–∞–∫—Å–∏–º—É–º –¥–ª—è –º–∞—Å—à—Ç–∞–±—É –ª—ñ–Ω—ñ—ó –ø–æ—Ä–æ–≥—É)
        drawVisuals((thresholdPercent / 100) * maxMag);
    }

    // --- VISUALIZATION ---

    function drawVisuals(absThreshold) {
        drawSpectrum(absThreshold);
        drawWaveforms();
    }

   function drawSpectrum(threshold) {
        const w = els.cvSpec.width = els.cvSpec.clientWidth;
        const h = els.cvSpec.height = els.cvSpec.clientHeight;
        
        ctxSpec.clearRect(0, 0, w, h);
        
        // --- 1. –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –õ–æ–≥–∞—Ä–∏—Ñ–º—ñ—á–Ω–æ—ó —à–∫–∞–ª–∏ ---
        const minFreq = 20; // –ü–æ—á–∞—Ç–æ–∫ —à–∫–∞–ª–∏ (20 –ì—Ü)
        const maxFreq = CFG.sampleRate / 2; // –ö—ñ–Ω–µ—Ü—å (22050 –ì—Ü)
        // –ö—ñ–ª—å–∫—ñ—Å—Ç—å –ì–µ—Ä—Ü –Ω–∞ –æ–¥–∏–Ω –±—ñ—Ç FFT
        const freqPerBin = CFG.sampleRate / CFG.fftSize; 
        
        // –§—É–Ω–∫—Ü—ñ—è: –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î X (–ø—ñ–∫—Å–µ–ª—ñ) -> Frequency (–ì—Ü)
        const getFreqAtX = (x) => {
            const t = x / w; // 0.0 ... 1.0
            // –§–æ—Ä–º—É–ª–∞: min * (max/min)^t
            return minFreq * Math.pow(maxFreq / minFreq, t);
        };

        // –§—É–Ω–∫—Ü—ñ—è: –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î Frequency -> X (–¥–ª—è —Å—ñ—Ç–∫–∏)
        const getXAtFreq = (f) => {
            return (Math.log(f / minFreq) / Math.log(maxFreq / minFreq)) * w;
        };

        // --- 2. –ú–∞–ª—é—î–º–æ –°–Ü–¢–ö–£ (Grid) ---
        ctxSpec.strokeStyle = '#333';
        ctxSpec.fillStyle = '#555';
        ctxSpec.font = '10px monospace';
        ctxSpec.textAlign = 'center';
        ctxSpec.lineWidth = 1;

        // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ñ –ª—ñ–Ω—ñ—ó (100Hz, 1kHz, 10kHz)
        [100, 1000, 10000].forEach(f => {
            const x = getXAtFreq(f);
            ctxSpec.beginPath();
            ctxSpec.moveTo(x, 0);
            ctxSpec.lineTo(x, h);
            ctxSpec.stroke();
            ctxSpec.fillText(f >= 1000 ? (f/1000)+'k' : f, x, h - 5);
        });

        // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞ –ª—ñ–Ω—ñ—è –ø–æ—Ä–æ–≥—É (–ü–æ—Ä—ñ–≥)
        const thY = h - (threshold / maxMag * h * 0.9);
        if(threshold > 0) {
            ctxSpec.strokeStyle = '#00bcd4';
            ctxSpec.setLineDash([5, 5]);
            ctxSpec.beginPath();
            ctxSpec.moveTo(0, thY);
            ctxSpec.lineTo(w, thY);
            ctxSpec.stroke();
            ctxSpec.setLineDash([]);
            ctxSpec.fillStyle = '#00bcd4';
            ctxSpec.textAlign = 'left';
            ctxSpec.fillText("–ü–æ—Ä—ñ–≥", 5, thY - 5);
        }

        // --- 3. –ú–∞–ª—é—î–º–æ –°–ü–ï–ö–¢–† ---
        // –ú–∏ –π–¥–µ–º–æ –ø–æ –∫–æ–∂–Ω–æ–º—É –ø—ñ–∫—Å–µ–ª—é –µ–∫—Ä–∞–Ω—É
        for (let x = 0; x < w; x++) {
            // –í–∏–∑–Ω–∞—á–∞—î–º–æ –¥—ñ–∞–ø–∞–∑–æ–Ω —á–∞—Å—Ç–æ—Ç, —è–∫–∏–π –ø–æ–∫—Ä–∏–≤–∞—î —Ü–µ–π –ø—ñ–∫—Å–µ–ª—å
            const fStart = getFreqAtX(x);
            const fEnd = getFreqAtX(x + 1);

            // –ü–µ—Ä–µ–≤–æ–¥–∏–º–æ –ì–µ—Ä—Ü–∏ –≤ —ñ–Ω–¥–µ–∫—Å–∏ –º–∞—Å–∏–≤—É FFT
            let iStart = Math.floor(fStart / freqPerBin);
            let iEnd = Math.ceil(fEnd / freqPerBin);
            
            // –û–±–º–µ–∂—É–≤–∞—á—ñ
            if (iStart < 0) iStart = 0;
            if (iEnd >= spectrumMag.length) iEnd = spectrumMag.length - 1;
            if (iEnd < iStart) iEnd = iStart;

            // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–ï –∑–Ω–∞—á–µ–Ω–Ω—è –≤ —Ü—å–æ–º—É –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ (Peak detection)
            // –¶–µ –≤–∞–∂–ª–∏–≤–æ –¥–ª—è –≤–∏—Å–æ–∫–∏—Ö —á–∞—Å—Ç–æ—Ç, —â–æ–± –Ω–µ "–≥—É–±–∏—Ç–∏" –∑–≤—É–∫–∏
            let val = 0;
            for (let i = iStart; i <= iEnd; i++) {
                if (spectrumMag[i] > val) val = spectrumMag[i];
            }

            // –ú–∞–ª—é—î–º–æ —Å—Ç–æ–≤–ø—á–∏–∫
            const heightNorm = Math.min(1, val / (maxMag || 1));
            const barH = heightNorm * h * 0.9;
            const y = h - barH;

            if (val >= threshold) {
                ctxSpec.fillStyle = '#4caf50'; // –ó–µ–ª–µ–Ω–∏–π (Keep)
            } else {
                ctxSpec.fillStyle = '#222';    // –¢—å–º—è–Ω–∏–π (Delete)
            }

            // –ú–∞–ª—é—î–º–æ –ª—ñ–Ω—ñ—é —à–∏—Ä–∏–Ω–æ—é 1px (—â–æ–± –∑–∞–ø–æ–≤–Ω–∏—Ç–∏ —Å—É—Ü—ñ–ª—å–Ω–æ)
            ctxSpec.fillRect(x, y, 1, barH);
        }
    }

function drawWaveforms() {
        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞: —è–∫—â–æ –Ω–µ–º–∞—î –¥–∞–Ω–∏—Ö, –Ω—ñ—á–æ–≥–æ –Ω–µ –º–∞–ª—é—î–º–æ
        if (!recordedData || !compressedSignal) return;

        const w = els.cvWave.width = els.cvWave.clientWidth;
        const h = els.cvWave.height = els.cvWave.clientHeight;
        const cy = h/2;

        ctxWave.clearRect(0, 0, w, h);
        ctxWave.lineWidth = 2;

        // --- 1. –û—Ä–∏–≥—ñ–Ω–∞–ª (–ó–µ–ª–µ–Ω–∞) ---
        ctxWave.beginPath();
        ctxWave.strokeStyle = 'rgba(76, 175, 80, 0.5)'; 
        for(let i=0; i<w; i++) {
            // –Ø–∫–∏–π —Ü–µ —Å–µ–º–ø–ª —É –≤—ñ–∫–Ω—ñ?
            let idxInWindow = Math.floor((i/w) * CFG.fftSize);
            // –Ø–∫–∏–π —Ü–µ —Å–µ–º–ø–ª —É –ø–æ–≤–Ω–æ–º—É —Ñ–∞–π–ª—ñ?
            let globalIdx = windowStart + idxInWindow;
            
            if (globalIdx < recordedData.length) {
                let val = recordedData[globalIdx] * 2; // –ú–Ω–æ–∂–Ω–∏–∫ *2 –¥–ª—è –º–∞—Å—à—Ç–∞–±—É
                if(i===0) ctxWave.moveTo(i, cy - val*50);
                else ctxWave.lineTo(i, cy - val*50);
            }
        }
        ctxWave.stroke();

        // --- 2. –°—Ç–∏—Å–Ω–µ–Ω–µ (–ü–æ–º–∞—Ä–∞–Ω—á–µ–≤–∞) ---
        ctxWave.beginPath();
        ctxWave.strokeStyle = '#ff9800'; 
        for(let i=0; i<w; i++) {
            let idxInWindow = Math.floor((i/w) * CFG.fftSize);
            let globalIdx = windowStart + idxInWindow;
            
            if (globalIdx < compressedSignal.length) {
                let val = compressedSignal[globalIdx] * 2;
                if(i===0) ctxWave.moveTo(i, cy - val*50);
                else ctxWave.lineTo(i, cy - val*50);
            }
        }
        ctxWave.stroke();
    }
    // --- PLAYBACK ---
    // Important: We cannot simply play the 1 window. We must play the full recorded buffer.
    // BUT, for the "Compressed" version, applying FFT to the whole 1.5s buffer in JS is slow.
    // Trick: We will play the *original* buffer for "Original",
    // and for "Compressed", we will implement a simple Real-Time filter node 
    // or just loop the visualized window (which sounds buzzy but demonstrates the timbre).
    
    // BETTER DECISION: Let's just process the whole 1.5s buffer using the same Threshold Logic
    // but in chunks (Overlap-Add is too complex for this snippet).
    // Simplified approach: We will just play the single "Window" looped.
    // Why? Because that's exactly what the user Sees. Hearing the "Timbre of the frame".

    function playBuffer(bufferData) {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const src = audioCtx.createBufferSource();
        const buf = audioCtx.createBuffer(1, bufferData.length, CFG.sampleRate);
        buf.getChannelData(0).set(bufferData);
        src.buffer = buf;
        
        // Fade edges to prevent clicking if looped (we won't loop)
        const gain = audioCtx.createGain();
        gain.gain.value = 0.5;
        
        src.connect(gain);
        gain.connect(audioCtx.destination);
        src.start();
    }

function playOriginal() {
        if (!recordedData) return;
        // –ì—Ä–∞—î–º–æ –ø–æ–≤–Ω–∏–π –∑–∞–ø–∏—Å–∞–Ω–∏–π –º–∞—Å–∏–≤, –∞ –Ω–µ —à–º–∞—Ç–æ—á–æ–∫ FFT
        playBuffer(recordedData);
    }

   function playCompressed() {
        if (!compressedSignal) return;
        playBuffer(compressedSignal);
    }

    // Init
    window.addEventListener('resize', () => {
        if(spectrumReal.length) updateCompression();
    });

</script>
</body>
</html>