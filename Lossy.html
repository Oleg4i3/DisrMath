<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lossy Compression Visualizer</title>
    <style>
        :root {
            --bg: #121212;
            --panel: #1e1e1e;
            --accent: #ff9800; /* Orange for Compression */
            --kept: #4caf50;   /* Green */
            --deleted: #333;   /* Grey */
            --threshold: #00bcd4; /* Cyan line */
            --text: #e0e0e0;
        }

        body {
            font-family: 'Segoe UI', Consolas, monospace;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 { color: var(--accent); margin-bottom: 5px; font-weight: 300; }
        p.subtitle { color: #aaa; margin-bottom: 20px; text-align: center; max-width: 800px; }

        .container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            max-width: 1000px;
            width: 100%;
        }

        .panel {
            background: var(--panel);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            position: relative;
        }

        /* Audio Controls */
        .recorder-box {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            background: #252525;
            padding: 15px;
            border-radius: 8px;
            flex-wrap: wrap;
        }

        button {
            background: #37474f; color: white; border: 1px solid #555;
            padding: 10px 20px; border-radius: 4px; cursor: pointer;
            font-family: inherit; font-weight: 600; transition: 0.2s;
            display: flex; align-items: center; gap: 8px;
        }
        button:hover { background: #455a64; border-color: var(--accent); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-record.recording { background: #f44336; animation: pulse 1.5s infinite; }
        .btn-play { background: var(--kept); color: #fff; }
        .btn-play-compressed { background: var(--accent); color: #000; }

        /* Canvas */
        canvas {
            width: 100%;
            background: #000;
            border-radius: 4px;
            display: block;
            cursor: crosshair;
        }

        /* Threshold Slider overlay */
        .slider-container {
            position: relative;
            height: 40px;
            background: #222;
            margin-top: 10px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding: 0 10px;
        }
        
        input[type=range] {
            width: 100%;
            accent-color: var(--threshold);
            cursor: pointer;
        }

        /* Checkboxes for Advanced Options */
        .options-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            padding: 10px;
            background: #252525;
            border-radius: 4px;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            user-select: none;
        }
        .checkbox-label input {
            accent-color: var(--accent);
            width: 16px;
            height: 16px;
        }

        /* Stats Grid */
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
            text-align: center;
        }
        .stat-box { background: #2a2a2a; padding: 10px; border-radius: 4px; }
        .stat-val { font-size: 1.2rem; font-weight: bold; display: block; margin-top: 5px; }
        .bad { color: #f44336; }
        .good { color: #4caf50; }

        /* Theory Details */
        details {
            background: #1a1a1a; border: 1px solid #333; border-radius: 8px; 
            margin: 0 0 20px 0; width: 100%; overflow: hidden;
        }
        summary {
            padding: 15px; cursor: pointer; background: #222; font-weight: bold; 
            color: var(--accent); outline: none;
        }
        .theory-content { padding: 20px; line-height: 1.6; color: #ccc; }
        .theory-content h3 { color: var(--threshold); margin-top: 20px; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .theory-content ul { margin: 10px 0; padding-left: 20px; }
        .theory-content li { margin-bottom: 8px; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body>

    <h1>–°—Ç–∏—Å–Ω–µ–Ω–Ω—è –ê—É–¥—ñ–æ (Lossy Compression)</h1>
    <p class="subtitle">
        –í–∏–¥–∞–ª–µ–Ω–Ω—è "–Ω–µ–ø–æ—Ç—Ä—ñ–±–Ω–∏—Ö" –∑–≤—É–∫—ñ–≤. –ó–∞–ø–∏—à—ñ—Ç—å –≥–æ–ª–æ—Å –∞–±–æ –∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ –ø—Ä–µ—Å–µ—Ç, 
        –ø–æ—Ç—ñ–º –ø—ñ–¥–Ω—ñ–º—ñ—Ç—å –ø–æ—Ä—ñ–≥, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏, —è–∫ –∫–æ–¥–µ–∫–∏ –∑–≤—É–∫—É –µ–∫–æ–Ω–æ–º–ª—è—Ç—å –º—ñ—Å—Ü–µ.
    </p>

    <div style="max-width: 1000px; width: 100%;">
   
   <details>
            <summary>üéì –õ–µ–∫—Ü—ñ–π–Ω–∏–π –º–∞—Ç–µ—Ä—ñ–∞–ª: –î–∏—Å–∫—Ä–µ—Ç–Ω–∞ –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è (MDCT —Ç–∞ –ü—Å–∏—Ö–æ–∞–∫—É—Å—Ç–∏–∫–∞)</summary>
            <div class="theory-content">
                <h3>1. –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–µ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è (DCT/MDCT)</h3>
                <p>
                    –£ —Å—É—á–∞—Å–Ω–∏—Ö –∞—É–¥—ñ–æ–∫–æ–¥–µ–∫–∞—Ö (MP3, AAC, Vorbis) –∑–∞–º—ñ—Å—Ç—å –∫–ª–∞—Å–∏—á–Ω–æ–≥–æ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –§—É—Ä'—î –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è <b>–ú–æ–¥–∏—Ñ—ñ–∫–æ–≤–∞–Ω–µ –î–∏—Å–∫—Ä–µ—Ç–Ω–µ –ö–æ—Å–∏–Ω—É—Å–Ω–µ –ü–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è (MDCT)</b>.
                </p>
                <p>
                    <b>–ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∞ —Å—É—Ç–Ω—ñ—Å—Ç—å:</b> –ë—É–¥—å-—è–∫–∏–π —Ü–∏—Ñ—Ä–æ–≤–∏–π —Å–∏–≥–Ω–∞–ª –º–æ–∂–Ω–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–∏ —è–∫ —Å—É–º—É –∫–æ—Å–∏–Ω—É—Å–æ—ó–¥ —Ä—ñ–∑–Ω–∏—Ö —á–∞—Å—Ç–æ—Ç. –ü—Ä–æ—Ü–µ—Å –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è ‚Äî —Ü–µ –ø–æ—à—É–∫ <b>–∫–æ—Ä–µ–ª—è—Ü—ñ—ó</b> (—Å–∫–∞–ª—è—Ä–Ω–æ–≥–æ –¥–æ–±—É—Ç–∫—É) –º—ñ–∂ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–º –≤—Ö—ñ–¥–Ω–æ–≥–æ —Å–∏–≥–Ω–∞–ª—É —Ç–∞ –Ω–∞–±–æ—Ä–æ–º <i>–±–∞–∑–∏—Å–Ω–∏—Ö —Ñ—É–Ω–∫—Ü—ñ–π</i>.
                </p>
                <div style="background:#222; padding:15px; border-left:3px solid var(--accent); font-family: 'Times New Roman', serif; font-size: 1.1rem; margin: 15px 0; text-align: center;">
                    X<sub>k</sub> = &sum;<sub>n=0</sub><sup>N-1</sup> x<sub>n</sub> &cdot; cos [&pi;/N (n + 0.5 + N/2)(k + 0.5)]
                </div>
                <p>
                    –î–µ:
                    <ul>
                        <li><b>x<sub>n</sub></b> ‚Äî –≤—Ö—ñ–¥–Ω–∏–π –≤–µ–∫—Ç–æ—Ä (–∞–º–ø–ª—ñ—Ç—É–¥–∏ —É —á–∞—Å—ñ).</li>
                        <li><b>cos[...]</b> ‚Äî –±–∞–∑–∏—Å–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è. –Ø–∫—â–æ —Ñ–æ—Ä–º–∞ —Å–∏–≥–Ω–∞–ª—É x<sub>n</sub> —Å—Ö–æ–∂–∞ –Ω–∞ –±–∞–∑–∏—Å–Ω—É –∫–æ—Å–∏–Ω—É—Å–æ—ó–¥—É k-—ó —á–∞—Å—Ç–æ—Ç–∏, –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç <b>X<sub>k</sub></b> –±—É–¥–µ –≤–µ–ª–∏–∫–∏–º.</li>
                        <li><b>Energy Compaction:</b> –û—Å–Ω–æ–≤–Ω–∞ –≤–ª–∞—Å—Ç–∏–≤—ñ—Å—Ç—å DCT ‚Äî –∑–¥–∞—Ç–Ω—ñ—Å—Ç—å –∫–æ–Ω—Ü–µ–Ω—Ç—Ä—É–≤–∞—Ç–∏ –µ–Ω–µ—Ä–≥—ñ—é —Å–∏–≥–Ω–∞–ª—É –≤ –Ω–µ–≤–µ–ª–∏–∫—ñ–π –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç—ñ–≤ (–Ω–∏–∑—å–∫–æ—á–∞—Å—Ç–æ—Ç–Ω–∏—Ö), –∑–∞–ª–∏—à–∞—é—á–∏ –≤–∏—Å–æ–∫–æ—á–∞—Å—Ç–æ—Ç–Ω—ñ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ –±–ª–∏–∑—å–∫–∏–º–∏ –¥–æ –Ω—É–ª—è.</li>
                    </ul>
                </p>

                <h3>2. –ü—Å–∏—Ö–æ—Ñ—ñ–∑–∏–∫–∞: –ó–∞–∫–æ–Ω –í–µ–±–µ—Ä–∞-–§–µ—Ö–Ω–µ—Ä–∞</h3>
                <p>
                    –°–ø—Ä–∏–π–Ω—è—Ç—Ç—è –≥—É—á–Ω–æ—Å—Ç—ñ –ª—é–¥–∏–Ω–æ—é –ø—ñ–¥–ø–æ—Ä—è–¥–∫–æ–≤—É—î—Ç—å—Å—è <b>–ó–∞–∫–æ–Ω—É –í–µ–±–µ—Ä–∞-–§–µ—Ö–Ω–µ—Ä–∞</b>: —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ñ—Å—Ç—å –≤—ñ–¥—á—É—Ç—Ç—è –ø—Ä–æ–ø–æ—Ä—Ü—ñ–π–Ω–∞ –ª–æ–≥–∞—Ä–∏—Ñ–º—É —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—ñ –ø–æ–¥—Ä–∞–∑–Ω–∏–∫–∞.
                    –°–∞–º–µ —Ç–æ–º—É:
                </p>
                <ul>
                    <li>–°–ø–µ–∫—Ç—Ä–æ–≥—Ä–∞–º–∏ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—é—Ç—å—Å—è —É <b>–ª–æ–≥–∞—Ä–∏—Ñ–º—ñ—á–Ω—ñ–π —à–∫–∞–ª—ñ</b> —á–∞—Å—Ç–æ—Ç (–≤—ñ—Å—å X) —Ç–∞ –¥–µ—Ü–∏–±–µ–ª–∞—Ö (–≤—ñ—Å—å Y).</li>
                    <li>–ú–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –ø–æ–Ω—è—Ç—Ç—è <b>–ö—Ä–∏—Ç–∏—á–Ω–∏—Ö —Å–º—É–≥ (Critical Bands)</b> –∞–±–æ —à–∫–∞–ª—É –ë–∞—Ä–∫—ñ–≤, –æ—Å–∫—ñ–ª—å–∫–∏ –≤—É—Ö–æ —ñ–Ω—Ç–µ–≥—Ä—É—î –µ–Ω–µ—Ä–≥—ñ—é –∑–≤—É–∫—É –≤ —Å–º—É–≥–∞—Ö, —à–∏—Ä–∏–Ω–∞ —è–∫–∏—Ö –∑—Ä–æ—Å—Ç–∞—î –∑ —á–∞—Å—Ç–æ—Ç–æ—é.</li>
                </ul>

                <h3>3. –ú–∞—Å–∫—É–≤–∞–Ω–Ω—è —Ç–∞ –§—É–Ω–∫—Ü—ñ—è –†–æ–∑—Ç—ñ–∫–∞–Ω–Ω—è</h3>
                <p>
                    –ú–∞—Å–∫—É–≤–∞–Ω–Ω—è ‚Äî —Ü–µ –Ω–µ–ª—ñ–Ω—ñ–π–Ω–∏–π –µ—Ñ–µ–∫—Ç, –ø—Ä–∏ —è–∫–æ–º—É –ø–æ—Ä—ñ–≥ —á—É—Ç–Ω–æ—Å—Ç—ñ $T_q$ –ª–æ–∫–∞–ª—å–Ω–æ –ø—ñ–¥–≤–∏—â—É—î—Ç—å—Å—è –≤ –ø—Ä–∏—Å—É—Ç–Ω–æ—Å—Ç—ñ —Å–∏–ª—å–Ω–æ–≥–æ —Å–∏–≥–Ω–∞–ª—É (–º–∞—Å–∫–µ—Ä–∞).
                    –ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–æ —Ü–µ –º–æ–¥–µ–ª—é—î—Ç—å—Å—è —è–∫ –∑–≥–æ—Ä—Ç–∫–∞ –µ–Ω–µ—Ä–≥–µ—Ç–∏—á–Ω–æ–≥–æ —Å–ø–µ–∫—Ç—Ä—É –∑ <b>—Ñ—É–Ω–∫—Ü—ñ—î—é —Ä–æ–∑—Ç—ñ–∫–∞–Ω–Ω—è (Spreading Function)</b>. 
                    <br><br>
                    <i>–£ —Å–∏–º—É–ª—è—Ç–æ—Ä—ñ –≤—ñ–∑—É–∞–ª—ñ–∑–æ–≤–∞–Ω–æ —Å–∞–º–µ —Ä–µ–∑—É–ª—å—Ç—É—é—á–∏–π –ø–æ—Ä—ñ–≥ –º–∞—Å–∫—É–≤–∞–Ω–Ω—è (–ø—É–Ω–∫—Ç–∏—Ä–Ω–∞ –ª—ñ–Ω—ñ—è). –í—Å—ñ —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ñ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ –ø—ñ–¥ —Ü—ñ—î—é –∫—Ä–∏–≤–æ—é –≤–≤–∞–∂–∞—é—Ç—å—Å—è –Ω–∞–¥–ª–∏—à–∫–æ–≤–æ—é —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—î—é.</i>
                </p>

                <h3>4. –ö–≤–∞–Ω—Ç—É–≤–∞–Ω–Ω—è —Ç–∞ –†–æ–∑—Ä—ñ–¥–∂–µ–Ω—ñ—Å—Ç—å (Sparsity)</h3>
                <p>
                    –ú–µ—Ç–∞ Lossy-–∫–æ–º–ø—Ä–µ—Å—ñ—ó ‚Äî –º–∞–∫—Å–∏–º—ñ–∑—É–≤–∞—Ç–∏ <b>—Ä–æ–∑—Ä—ñ–¥–∂–µ–Ω—ñ—Å—Ç—å</b> (sparsity) –≤–µ–∫—Ç–æ—Ä—É –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç—ñ–≤ –ø–µ—Ä–µ–¥ –µ–Ω—Ç—Ä–æ–ø—ñ–π–Ω–∏–º –∫–æ–¥—É–≤–∞–Ω–Ω—è–º. –ú–∏ –∑–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ –ø–æ—Ä–æ–≥–æ–≤—É —Ñ—É–Ω–∫—Ü—ñ—é (Thresholding function) $T_\lambda$:
                </p>
                
                <p><b>–ê) –ñ–æ—Ä—Å—Ç–∫–∏–π –ø–æ—Ä—ñ–≥ (Hard Thresholding):</b></p>
                <div style="background:#222; padding:10px; font-family: monospace; border-left: 2px solid var(--kept);">
                    y = x,  —è–∫—â–æ |x| > &lambda;<br>
                    y = 0,  —è–∫—â–æ |x| &le; &lambda;
                </div>
                <p><i>–ó–±–µ—Ä—ñ–≥–∞—î –µ–Ω–µ—Ä–≥—ñ—é –ø—ñ–∫—ñ–≤, –∞–ª–µ –≤–Ω–æ—Å–∏—Ç—å —Ä–æ–∑—Ä–∏–≤–∏ –¥—Ä—É–≥–æ–≥–æ —Ä–æ–¥—É (—Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ñ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–∏).</i></p>

                <p><b>–ë) –ú'—è–∫–∏–π –ø–æ—Ä—ñ–≥ (Soft Thresholding):</b></p>
                <div style="background:#222; padding:10px; font-family: monospace; border-left: 2px solid var(--threshold);">
                    y = sign(x) &cdot; (|x| - &lambda;),  —è–∫—â–æ |x| > &lambda;<br>
                    y = 0,                      —è–∫—â–æ |x| &le; &lambda;
                </div>
                <p><i>–ó–∞–±–µ–∑–ø–µ—á—É—î –Ω–µ–ø–µ—Ä–µ—Ä–≤–Ω—ñ—Å—Ç—å —Ñ—É–Ω–∫—Ü—ñ—ó –≤—ñ–¥–≥—É–∫—É, –∑–º–µ–Ω—à—É—é—á–∏ –¥–∏—Å–ø–µ—Ä—Å—ñ—é —à—É–º—É –∫–≤–∞–Ω—Ç—É–≤–∞–Ω–Ω—è, –∞–ª–µ –¥–µ—â–æ –∑–∞–Ω–∏–∂—É—î –∑–∞–≥–∞–ª—å–Ω—É –µ–Ω–µ—Ä–≥—ñ—é —Å–∏–≥–Ω–∞–ª—É.</i></p>
            </div>
        </details>
   
   
    </div>

    <div class="recorder-box">
        <button id="btnPreset" onclick="loadPreset()">üéπ –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –ü—Ä–µ—Å–µ—Ç (–°–∏–Ω—Ç–µ–∑–∞—Ç–æ—Ä)</button>
        <div style="width: 1px; background: #555; margin: 0 10px;"></div>
        <button id="btnMic" class="btn-record" onclick="toggleRecord()">üé§ –ú—ñ–∫—Ä–æ—Ñ–æ–Ω (REC)</button>
        <span id="statusText" style="align-self: center; color: #aaa; font-size: 0.9rem;">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è...</span>
    </div>

    <div class="container">
        
        <div class="panel">
            <div style="display:flex; justify-content:space-between; align-items: center;">
                <h3>–ß–∞—Å—Ç–æ—Ç–Ω–∏–π –°–ø–µ–∫—Ç—Ä (FFT)</h3>
                <div style="font-size: 0.8rem; color:#aaa">X: –ß–∞—Å—Ç–æ—Ç–∞ (Hz) | Y: –ì—É—á–Ω—ñ—Å—Ç—å (dB)</div>
            </div>
            
            <canvas id="cvSpectrum" height="250"></canvas>
            
            <div class="slider-container">
                <span style="min-width: 80px; font-size: 0.9rem;">‚úÇÔ∏è –ü–æ—Ä—ñ–≥:</span>
                <input type="range" id="slThreshold" min="0" max="100" value="10" oninput="updateCompression()">
                <span id="lblThreshold" style="min-width: 50px; text-align: right; font-weight: bold; color: var(--threshold);">10%</span>
            </div>

            <div class="options-container">
                <label class="checkbox-label" title="–Ø–∫—â–æ —É–≤—ñ–º–∫–Ω–µ–Ω–æ, —Ç–∏—Ö—ñ –∑–≤—É–∫–∏ –ø–ª–∞–≤–Ω–æ –ø—Ä–∏–≥–ª—É—à—É—é—Ç—å—Å—è, –∞ –Ω–µ —Ä—ñ–∑–∫–æ –æ–±—Ä—ñ–∑–∞—é—Ç—å—Å—è">
                    <input type="checkbox" id="chkSoft" onchange="updateCompression()"> –ú'—è–∫–∏–π –ø–æ—Ä—ñ–≥ (Soft)
                </label>
                <label class="checkbox-label" title="–Ø–∫—â–æ —É–≤—ñ–º–∫–Ω–µ–Ω–æ, –ø–æ—Ä—ñ–≥ –ø—ñ–¥–Ω—ñ–º–∞—î—Ç—å—Å—è –Ω–∞–≤–∫–æ–ª–æ –≥—É—á–Ω–∏—Ö –∑–≤—É–∫—ñ–≤ (–ø—Å–∏—Ö–æ–∞–∫—É—Å—Ç–∏–∫–∞)">
                    <input type="checkbox" id="chkMasking" onchange="updateCompression()"> –ú–∞—Å–∫—É–≤–∞–Ω–Ω—è (Masking)
                </label>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div style="color:#aaa; font-size:0.8rem">–í—Å—å–æ–≥–æ –≥–∞—Ä–º–æ–Ω—ñ–∫</div>
                    <span class="stat-val" id="valTotal">0</span>
                </div>
                <div class="stat-box">
                    <div style="color:var(--kept); font-size:0.8rem">–ó–±–µ—Ä–µ–∂–µ–Ω–æ (–≤ —Å–µ—Ä–µ–¥–Ω—å–æ–º—É)</div>
                    <span class="stat-val" id="valKept">0</span>
                </div>
                <div class="stat-box">
                    <div style="color:var(--accent); font-size:0.8rem">–°—Ç—É–ø—ñ–Ω—å —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è</div>
                    <span class="stat-val" id="valRatio">1.0x</span>
                </div>
            </div>
        </div>

        <div class="panel">
            <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç</h3>
            <div style="display: flex; gap: 20px; justify-content: center; margin: 20px 0;">
                <button class="btn-play" id="btnPlayOrig" onclick="playOriginal()" disabled>‚ñ∂ –û—Ä–∏–≥—ñ–Ω–∞–ª</button>
                <button class="btn-play-compressed" id="btnPlayComp" onclick="playCompressed()" disabled>‚ñ∂ –°—Ç–∏—Å–Ω–µ–Ω–µ</button>
            </div>
            <canvas id="cvWave" height="100"></canvas>
            <p style="text-align: center; font-size: 0.85rem; color: #777; margin-top: 10px;">
                –ó–µ–ª–µ–Ω–∞ –ª—ñ–Ω—ñ—è ‚Äî –æ—Ä–∏–≥—ñ–Ω–∞–ª. –ü–æ–º–∞—Ä–∞–Ω—á–µ–≤–∞ ‚Äî –ø—ñ—Å–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è —á–∞—Å—Ç–æ—Ç. <br>
            </p>
        </div>

    </div>

<script>
    // --- FFT LIBRARY (Simplified for Education) ---
    // A generic Cooley-Tukey implementation
    const FFT = {
        reverseBits: function(x, n) {
            let result = 0;
            for (let i = 0; i < n; i++, x >>= 1) result = (result << 1) | (x & 1);
            return result;
        },
        transform: function(real, imag) {
            const n = real.length;
            const levels = Math.log2(n);
            // Bit-reversal permutation
            for (let i = 0; i < n; i++) {
                const rev = this.reverseBits(i, levels);
                if (rev > i) {
                    [real[i], real[rev]] = [real[rev], real[i]];
                    [imag[i], imag[rev]] = [imag[rev], imag[i]];
                }
            }
            // Butterfly operations
            for (let size = 2; size <= n; size *= 2) {
                const half = size / 2;
                const step = 2 * Math.PI / size;
                for (let i = 0; i < n; i += size) {
                    for (let j = 0; j < half; j++) {
                        const k = i + j;
                        const t = k + half;
                        const angle = -j * step; // Negative for forward FFT
                        const cos = Math.cos(angle);
                        const sin = Math.sin(angle);
                        const tr = real[t] * cos - imag[t] * sin;
                        const ti = real[t] * sin + imag[t] * cos;
                        real[t] = real[k] - tr;
                        imag[t] = imag[k] - ti;
                        real[k] += tr;
                        imag[k] += ti;
                    }
                }
            }
        },
        inverse: function(real, imag) {
            const n = real.length;
            // Conjugate -> Transform -> Conjugate -> Scale
            for(let i=0; i<n; i++) imag[i] = -imag[i];
            this.transform(real, imag);
            for(let i=0; i<n; i++) {
                imag[i] = -imag[i];
                real[i] /= n;
                imag[i] /= n;
            }
        }
    };

    // --- APP LOGIC ---

    const CFG = {
        fftSize: 4096, // Good resolution
        sampleRate: 44100,
        duration: 1.5 // seconds to record
    };

    let audioCtx = null;
    let originalBuffer = null; // Float32Array with raw audio
    let recordedData = null;   // Just the mono channel data
    let windowStart = 0;
    // Spectral Data
    let spectrumReal = [];
    let spectrumImag = [];
    let spectrumMag = []; // Magnitude for visualization
    let maxMag = 0;

    // Compressed Data
    let compressedSignal = null;

    // UI References
    const els = {
        cvSpec: document.getElementById('cvSpectrum'),
        cvWave: document.getElementById('cvWave'),
        slThresh: document.getElementById('slThreshold'),
        lblThresh: document.getElementById('lblThreshold'),
        chkSoft: document.getElementById('chkSoft'),
        chkMasking: document.getElementById('chkMasking'),
        btnPlayOrig: document.getElementById('btnPlayOrig'),
        btnPlayComp: document.getElementById('btnPlayComp'),
        status: document.getElementById('statusText'),
        valTotal: document.getElementById('valTotal'),
        valKept: document.getElementById('valKept'),
        valRatio: document.getElementById('valRatio')
    };
    
    const ctxSpec = els.cvSpec.getContext('2d');
    const ctxWave = els.cvWave.getContext('2d');

    // --- AUDIO HANDLING ---

    async function initAudio() {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') await audioCtx.resume();
        return audioCtx;
    }

    // 1. Generate Preset (FM Synthesis)
    async function loadPreset() {
        await initAudio();
        els.status.innerText = "–ì–µ–Ω–µ—Ä—É—é –ø—Ä–µ—Å–µ—Ç...";
        
        const length = CFG.sampleRate * CFG.duration;
        const data = new Float32Array(length);
        
        // Create a rich FM sound (Carrier + Modulator)
        for(let i=0; i<length; i++) {
            let t = i / CFG.sampleRate;
            // Envelope
            let env = 1 - (t / CFG.duration);
            // FM: sin(2pi*fc*t + I*sin(2pi*fm*t))
            let mod = Math.sin(2 * Math.PI * 110 * t) * 5; 
            let carrier = Math.sin(2 * Math.PI * 220 * t + mod);
            
            // Add some noise
            let noise = (Math.random() - 0.5) * 0.05;
            
            data[i] = (carrier * 0.8 + noise) * env;
        }
        
        processInput(data);
        els.status.innerText = "–ü—Ä–µ—Å–µ—Ç –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ!";
    }

    // 2. Microphone Recording
    let isRecording = false;
    async function toggleRecord() {
        await initAudio();
        if(isRecording) return;

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mediaStreamSource = audioCtx.createMediaStreamSource(stream);
            const processor = audioCtx.createScriptProcessor(4096, 1, 1);
            
            let chunks = [];
            let samplesCollected = 0;
            const maxSamples = CFG.sampleRate * CFG.duration;

            isRecording = true;
            document.getElementById('btnMic').classList.add('recording');
            els.status.innerText = "–ó–∞–ø–∏—Å...";

            mediaStreamSource.connect(processor);
            processor.connect(audioCtx.destination);

            processor.onaudioprocess = (e) => {
                if(!isRecording) return;
                const input = e.inputBuffer.getChannelData(0);
                
                // Clone chunk
                const chunk = new Float32Array(input);
                chunks.push(chunk);
                samplesCollected += chunk.length;

                if(samplesCollected >= maxSamples) {
                    stopRecord(stream, processor, chunks);
                }
            };

        } catch(err) {
            alert("–î–æ—Å—Ç—É–ø –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω—É –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω–æ –∞–±–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π. –í–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ –ø—Ä–µ—Å–µ—Ç.");
            console.error(err);
        }
    }

    function stopRecord(stream, processor, chunks) {
        isRecording = false;
        document.getElementById('btnMic').classList.remove('recording');
        stream.getTracks().forEach(t => t.stop());
        processor.disconnect();
        
        // Flatten chunks
        let totalLen = chunks.reduce((acc, c) => acc + c.length, 0);
        const data = new Float32Array(totalLen);
        let offset = 0;
        for(let c of chunks) {
            data.set(c, offset);
            offset += c.length;
        }
        
        // Trim to exact duration
        const finalData = data.slice(0, CFG.sampleRate * CFG.duration);
        processInput(finalData);
        els.status.innerText = "–ó–∞–ø–∏—Å–∞–Ω–æ!";
    }

    // --- CORE PROCESSING ---

    function processInput(rawData) {
        recordedData = rawData;
        
        // –ó–Ω–∞—Ö–æ–¥–∏–º–æ —Ü–µ–Ω—Ç—Ä –∑–∞–ø–∏—Å—É (—Ç–∞–º –∑–∞–∑–≤–∏—á–∞–π –Ω–∞–π–≥—É—á–Ω—ñ—à–µ)
        const center = Math.floor(rawData.length / 2);
        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≥–ª–æ–±–∞–ª—å–Ω–æ —Ç–æ—á–∫—É –ø–æ—á–∞—Ç–∫—É –Ω–∞—à–æ–≥–æ "–≤—ñ–∫–Ω–∞"
        windowStart = Math.max(0, center - CFG.fftSize/2);
        
        // –í–∏—Ä—ñ–∑–∞—î–º–æ —à–º–∞—Ç–æ—á–æ–∫ —Å–∞–º–µ –¥–ª—è FFT –∞–Ω–∞–ª—ñ–∑—É
        const slice = rawData.slice(windowStart, windowStart + CFG.fftSize);
        
        // –í—ñ–∫–Ω–æ –•–µ–Ω–Ω—ñ–Ω–≥–∞ (—â–æ–± —Å–ø–µ–∫—Ç—Ä –±—É–≤ —á–∏—Å—Ç–∏–π)
        const windowed = new Float32Array(CFG.fftSize);
        for(let i=0; i<CFG.fftSize; i++) {
            let val = (i < slice.length) ? slice[i] : 0;
            let win = 0.5 * (1 - Math.cos(2 * Math.PI * i / (CFG.fftSize - 1)));
            windowed[i] = val * win;
        }

        // –†–∞—Ö—É—î–º–æ FFT –¥–ª—è –≥—Ä–∞—Ñ—ñ–∫—É
        spectrumReal = new Float32Array(windowed);
        spectrumImag = new Float32Array(CFG.fftSize).fill(0);
        FFT.transform(spectrumReal, spectrumImag);

        // –†–∞—Ö—É—î–º–æ –ú–∞–≥–Ω—ñ—Ç—É–¥—É
        spectrumMag = new Float32Array(CFG.fftSize / 2);
        maxMag = 0;
        for(let i=0; i<spectrumMag.length; i++) {
            let mag = Math.sqrt(spectrumReal[i]**2 + spectrumImag[i]**2);
            spectrumMag[i] = mag;
            if(mag > maxMag) maxMag = mag;
        }

        // –ê–∫—Ç–∏–≤—É—î–º–æ —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å
        els.btnPlayOrig.disabled = false;
        els.btnPlayComp.disabled = false;
        
        // –ó–∞–ø—É—Å–∫–∞—î–º–æ –ø–µ—Ä—à–µ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è
        updateCompression();
    }

    // Helper for Masking Curve calculation
    // UPDATED: Uses frequency-dependent spread to mimic Logarithmic/Bark scale behavior
    function calculateMaskingThresholds(magnitudes, baseThreshold) {
        const thresholds = new Float32Array(magnitudes.length).fill(baseThreshold);
        const len = magnitudes.length;
        
        // Iterate over every bin to find "Maskers"
        for (let i = 0; i < len; i++) {
            const mag = magnitudes[i];
            
            // If this frequency is strong (above base noise), it acts as a Masker
            if (mag > baseThreshold) {
                
                // CRITICAL CHANGE: Spread depends on frequency (i).
                // This simulates Critical Bands (Bark scale) where bandwidth increases with frequency.
                // It also ensures the "skirt" looks consistent on the Logarithmic X-axis visual.
                // i * 0.15 means spread is small at low index, huge at high index.
                const spread = Math.max(10, Math.floor(i * 0.15));
                
                for (let j = Math.max(0, i - spread); j <= Math.min(len - 1, i + spread); j++) {
                    if (i === j) continue;

                    const dist = Math.abs(i - j);
                    
                    // Simple linear or exponential falloff based on normalized distance
                    const normalizedDist = dist / spread;
                    const decay = Math.pow(0.1, normalizedDist); // Steep decay
                    
                    const maskLevel = mag * decay * 0.8; 
                    
                    if (maskLevel > thresholds[j]) {
                        thresholds[j] = maskLevel;
                    }
                }
            }
        }
        return thresholds;
    }

    // --- COMPRESSION SIMULATION ---
    function updateCompression() {
        if (!recordedData || !recordedData.length) return;

        const thresholdPercent = parseInt(els.slThresh.value);
        els.lblThresh.innerText = thresholdPercent + "%";
        
        const useSoft = els.chkSoft.checked;
        const useMasking = els.chkMasking.checked;
        
        // --- 1. –ü–Ü–î–ì–û–¢–û–í–ö–ê (OVERLAP-ADD) ---
        const fullLength = recordedData.length;
        const processedData = new Float32Array(fullLength); // –í–∏—Ö—ñ–¥–Ω–∏–π –±—É—Ñ–µ—Ä (—Ç–∏—à–∞)
        
        // –ö—Ä–æ–∫ –∑–º—ñ—â–µ–Ω–Ω—è (Hop Size). –î–ª—è –≤—ñ–∫–Ω–∞ –•–µ–Ω–Ω—ñ–Ω–≥–∞ —Ü–µ 50% –≤—ñ–¥ –¥–æ–≤–∂–∏–Ω–∏ FFT
        const hopSize = CFG.fftSize / 2; 

        // –°—Ç–≤–æ—Ä—é—î–º–æ –≤—ñ–∫–æ–Ω–Ω—É —Ñ—É–Ω–∫—Ü—ñ—é (Hanning Window) –æ–¥–∏–Ω —Ä–∞–∑
        const winFunc = new Float32Array(CFG.fftSize);
        for(let i=0; i<CFG.fftSize; i++) {
            winFunc[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (CFG.fftSize - 1)));
        }

        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        let totalBinsProcessed = 0;
        let keptBinsProcessed = 0;

        // --- 2. –¶–ò–ö–õ –ó –ü–ï–†–ï–ö–†–ò–¢–¢–Ø–ú ---
        // offset += hopSize (—Ä—É—Ö–∞—î–º–æ—Å—å –Ω–∞–ø–æ–ª–æ–≤–∏–Ω—É –¥–æ–≤–∂–∏–Ω–∏ –≤—ñ–∫–Ω–∞)
        for (let offset = 0; offset <= fullLength - CFG.fftSize; offset += hopSize) {
            
            // –ê. –ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞ –±—É—Ñ–µ—Ä—ñ–≤
            const chunkReal = new Float32Array(CFG.fftSize);
            const chunkImag = new Float32Array(CFG.fftSize);
            
            // –ë. –ö–æ–ø—ñ—é—î–º–æ –¥–∞–Ω—ñ –¢–ê –ó–ê–°–¢–û–°–û–í–£–Ñ–ú–û –í–Ü–ö–ù–û (Windowing)
            for (let i = 0; i < CFG.fftSize; i++) {
                chunkReal[i] = recordedData[offset + i] * winFunc[i];
            }

            // –í. FFT
            FFT.transform(chunkReal, chunkImag);

            // –ì. –û–±—Ä–æ–±–∫–∞ (Thresholding)
            // –®—É–∫–∞—î–º–æ –ª–æ–∫–∞–ª—å–Ω–∏–π –º–∞–∫—Å–∏–º—É–º –¥–ª—è –¥–∏–Ω–∞–º—ñ—á–Ω–æ–≥–æ –ø–æ—Ä–æ–≥—É
            let localMax = 0;
            const mags = new Float32Array(CFG.fftSize);
            for (let i = 0; i < CFG.fftSize; i++) {
                 let m = Math.sqrt(chunkReal[i]**2 + chunkImag[i]**2);
                 mags[i] = m;
                 if (m > localMax) localMax = m;
            }

            // Determine Threshold (Scalar or Array)
            let currentThresholds = null;
            let scalarThreshold = 0;

            if (useMasking) {
                // Base silence threshold is lower when masking is on
                const base = localMax * (thresholdPercent / 400); 
                currentThresholds = calculateMaskingThresholds(mags, base);
            } else {
                scalarThreshold = localMax * (thresholdPercent / 100);
            }

            // –§—ñ–ª—å—Ç—Ä—É—î–º–æ
            for (let i = 0; i < CFG.fftSize; i++) {
                const mag = mags[i];
                const thresh = useMasking ? currentThresholds[i] : scalarThreshold;

                if (mag < thresh) {
                    // Hard removal
                    chunkReal[i] = 0;
                    chunkImag[i] = 0;
                } else {
                    // Keep
                    if (useSoft) {
                        // Soft Thresholding: Shrink towards zero
                        const scale = (mag - thresh) / mag;
                        chunkReal[i] *= scale;
                        chunkImag[i] *= scale;
                    }
                    // Stats (only count meaningful spectrum part)
                    if (i < CFG.fftSize / 2 && mags[i] > 1e-5) keptBinsProcessed++;
                }
            }
            totalBinsProcessed += (CFG.fftSize / 2);

            // –î. Inverse FFT
            FFT.inverse(chunkReal, chunkImag);

            // –ï. OVERLAP-ADD
            for (let i = 0; i < CFG.fftSize; i++) {
                processedData[offset + i] += chunkReal[i]; 
            }
        }

        // --- 3. –§–Ü–ù–ê–õ ---
        compressedSignal = processedData;

        // –û–Ω–æ–≤–ª—é—î–º–æ —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å
        els.valTotal.innerText = Math.floor(totalBinsProcessed / (fullLength/hopSize)); // –°–µ—Ä–µ–¥–Ω—î –Ω–∞ —Ñ—Ä–µ–π–º
        els.valKept.innerText = Math.floor(keptBinsProcessed / (fullLength/hopSize))+1;
        
        let ratio = (keptBinsProcessed > 0) ? (totalBinsProcessed / keptBinsProcessed).toFixed(1) : "MAX";
        els.valRatio.innerText = ratio + ":1";
        els.valRatio.style.color = (parseFloat(ratio) > 10 || ratio === "MAX") ? '#ff9800' : '#4caf50';

        // Calculate Visualization Threshold Data for the Canvas
        // We need to calculate the curve based on the *Global* spectrumMag used for display
        let visThresholdData = null;
        if (useMasking) {
            const base = maxMag * (thresholdPercent / 400); // Match logic above
            visThresholdData = calculateMaskingThresholds(spectrumMag, base); // Array
        } else {
            visThresholdData = (thresholdPercent / 100) * maxMag; // Scalar
        }

        // –ú–∞–ª—é—î–º–æ –≥—Ä–∞—Ñ—ñ–∫ 
        drawVisuals(visThresholdData);
    }

    // --- VISUALIZATION ---

    function drawVisuals(thresholdData) {
        drawSpectrum(thresholdData);
        drawWaveforms();
    }

   function drawSpectrum(thresholdData) {
        const w = els.cvSpec.width = els.cvSpec.clientWidth;
        const h = els.cvSpec.height = els.cvSpec.clientHeight;
        
        ctxSpec.clearRect(0, 0, w, h);
        
        // --- 1. –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –õ–æ–≥–∞—Ä–∏—Ñ–º—ñ—á–Ω–æ—ó —à–∫–∞–ª–∏ ---
        const minFreq = 20; // –ü–æ—á–∞—Ç–æ–∫ —à–∫–∞–ª–∏ (20 –ì—Ü)
        const maxFreq = CFG.sampleRate / 2; // –ö—ñ–Ω–µ—Ü—å (22050 –ì—Ü)
        // –ö—ñ–ª—å–∫—ñ—Å—Ç—å –ì–µ—Ä—Ü –Ω–∞ –æ–¥–∏–Ω –±—ñ—Ç FFT
        const freqPerBin = CFG.sampleRate / CFG.fftSize; 
        
        // –§—É–Ω–∫—Ü—ñ—è: –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î X (–ø—ñ–∫—Å–µ–ª—ñ) -> Frequency (–ì—Ü)
        const getFreqAtX = (x) => {
            const t = x / w; // 0.0 ... 1.0
            // –§–æ—Ä–º—É–ª–∞: min * (max/min)^t
            return minFreq * Math.pow(maxFreq / minFreq, t);
        };

        // –§—É–Ω–∫—Ü—ñ—è: –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î Frequency -> X (–¥–ª—è —Å—ñ—Ç–∫–∏)
        const getXAtFreq = (f) => {
            return (Math.log(f / minFreq) / Math.log(maxFreq / minFreq)) * w;
        };

        // --- 2. –ú–∞–ª—é—î–º–æ –°–Ü–¢–ö–£ (Grid) ---
        ctxSpec.strokeStyle = '#333';
        ctxSpec.fillStyle = '#555';
        ctxSpec.font = '10px monospace';
        ctxSpec.textAlign = 'center';
        ctxSpec.lineWidth = 1;

        // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ñ –ª—ñ–Ω—ñ—ó (100Hz, 1kHz, 10kHz)
        [100, 1000, 10000].forEach(f => {
            const x = getXAtFreq(f);
            ctxSpec.beginPath();
            ctxSpec.moveTo(x, 0);
            ctxSpec.lineTo(x, h);
            ctxSpec.stroke();
            ctxSpec.fillText(f >= 1000 ? (f/1000)+'k' : f, x, h - 5);
        });

        // --- 2.5. –ú–∞–ª—é—î–º–æ –õ–Ü–ù–Ü–Æ –ü–û–†–û–ì–£ (Threshold) ---
        ctxSpec.strokeStyle = '#00bcd4';
        ctxSpec.lineWidth = 2;
        ctxSpec.setLineDash([5, 5]);
        ctxSpec.beginPath();

        const isArrayThreshold = (thresholdData instanceof Float32Array || Array.isArray(thresholdData));

        if (isArrayThreshold) {
            // Draw Curve (Masking)
            let started = false;
            for (let x = 0; x < w; x++) {
                const f = getFreqAtX(x);
                const binIndex = Math.floor(f / freqPerBin);
                if(binIndex < thresholdData.length) {
                    const thVal = thresholdData[binIndex];
                    // Clamp to canvas
                    let thY = h - (thVal / maxMag * h * 0.9);
                    if(thY < 0) thY = 0;
                    
                    if(!started) { ctxSpec.moveTo(x, thY); started = true; }
                    else { ctxSpec.lineTo(x, thY); }
                }
            }
            ctxSpec.stroke();
            // Reset Dash
            ctxSpec.setLineDash([]);
            ctxSpec.fillStyle = '#00bcd4';
            ctxSpec.textAlign = 'left';
            ctxSpec.fillText("–ü–æ—Ä—ñ–≥ (–ú–∞—Å–∫—É–≤–∞–Ω–Ω—è)", 5, 15);

        } else {
            // Draw Horizontal Line (Standard)
            const threshold = thresholdData;
            const thY = h - (threshold / maxMag * h * 0.9);
            if(threshold > 0) {
                ctxSpec.moveTo(0, thY);
                ctxSpec.lineTo(w, thY);
                ctxSpec.stroke();
                ctxSpec.setLineDash([]);
                ctxSpec.fillStyle = '#00bcd4';
                ctxSpec.textAlign = 'left';
                ctxSpec.fillText("–ü–æ—Ä—ñ–≥", 5, thY - 5);
            }
        }

        // --- 3. –ú–∞–ª—é—î–º–æ –°–ü–ï–ö–¢–† ---
        // –ú–∏ –π–¥–µ–º–æ –ø–æ –∫–æ–∂–Ω–æ–º—É –ø—ñ–∫—Å–µ–ª—é –µ–∫—Ä–∞–Ω—É
        for (let x = 0; x < w; x++) {
            // –í–∏–∑–Ω–∞—á–∞—î–º–æ –¥—ñ–∞–ø–∞–∑–æ–Ω —á–∞—Å—Ç–æ—Ç, —è–∫–∏–π –ø–æ–∫—Ä–∏–≤–∞—î —Ü–µ–π –ø—ñ–∫—Å–µ–ª—å
            const fStart = getFreqAtX(x);
            const fEnd = getFreqAtX(x + 1);

            // –ü–µ—Ä–µ–≤–æ–¥–∏–º–æ –ì–µ—Ä—Ü–∏ –≤ —ñ–Ω–¥–µ–∫—Å–∏ –º–∞—Å–∏–≤—É FFT
            let iStart = Math.floor(fStart / freqPerBin);
            let iEnd = Math.ceil(fEnd / freqPerBin);
            
            // –û–±–º–µ–∂—É–≤–∞—á—ñ
            if (iStart < 0) iStart = 0;
            if (iEnd >= spectrumMag.length) iEnd = spectrumMag.length - 1;
            if (iEnd < iStart) iEnd = iStart;

            // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–ï –∑–Ω–∞—á–µ–Ω–Ω—è –≤ —Ü—å–æ–º—É –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ (Peak detection)
            let val = 0;
            let binIndexForThreshold = iStart; // Approx bin for threshold check

            for (let i = iStart; i <= iEnd; i++) {
                if (spectrumMag[i] > val) {
                    val = spectrumMag[i];
                    binIndexForThreshold = i;
                }
            }

            // Check Threshold
            let currentThreshVal = 0;
            if(isArrayThreshold) {
                if(binIndexForThreshold < thresholdData.length) currentThreshVal = thresholdData[binIndexForThreshold];
            } else {
                currentThreshVal = thresholdData;
            }

            // –ú–∞–ª—é—î–º–æ —Å—Ç–æ–≤–ø—á–∏–∫
            const heightNorm = Math.min(1, val / (maxMag || 1));
            const barH = heightNorm * h * 0.9;
            const y = h - barH;

            if (val >= currentThreshVal) {
                ctxSpec.fillStyle = '#4caf50'; // –ó–µ–ª–µ–Ω–∏–π (Keep)
            } else {
                ctxSpec.fillStyle = '#222';    // –¢—å–º—è–Ω–∏–π (Delete)
            }

            // –ú–∞–ª—é—î–º–æ –ª—ñ–Ω—ñ—é —à–∏—Ä–∏–Ω–æ—é 1px (—â–æ–± –∑–∞–ø–æ–≤–Ω–∏—Ç–∏ —Å—É—Ü—ñ–ª—å–Ω–æ)
            ctxSpec.fillRect(x, y, 1, barH);
        }
    }

function drawWaveforms() {
        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞: —è–∫—â–æ –Ω–µ–º–∞—î –¥–∞–Ω–∏—Ö, –Ω—ñ—á–æ–≥–æ –Ω–µ –º–∞–ª—é—î–º–æ
        if (!recordedData || !compressedSignal) return;

        const w = els.cvWave.width = els.cvWave.clientWidth;
        const h = els.cvWave.height = els.cvWave.clientHeight;
        const cy = h/2;

        ctxWave.clearRect(0, 0, w, h);
        ctxWave.lineWidth = 2;

        // --- 1. –û—Ä–∏–≥—ñ–Ω–∞–ª (–ó–µ–ª–µ–Ω–∞) ---
        ctxWave.beginPath();
        ctxWave.strokeStyle = 'rgba(76, 175, 80, 0.5)'; 
        for(let i=0; i<w; i++) {
            // –Ø–∫–∏–π —Ü–µ —Å–µ–º–ø–ª —É –≤—ñ–∫–Ω—ñ?
            let idxInWindow = Math.floor((i/w) * CFG.fftSize);
            // –Ø–∫–∏–π —Ü–µ —Å–µ–º–ø–ª —É –ø–æ–≤–Ω–æ–º—É —Ñ–∞–π–ª—ñ?
            let globalIdx = windowStart + idxInWindow;
            
            if (globalIdx < recordedData.length) {
                let val = recordedData[globalIdx] * 2; // –ú–Ω–æ–∂–Ω–∏–∫ *2 –¥–ª—è –º–∞—Å—à—Ç–∞–±—É
                if(i===0) ctxWave.moveTo(i, cy - val*50);
                else ctxWave.lineTo(i, cy - val*50);
            }
        }
        ctxWave.stroke();

        // --- 2. –°—Ç–∏—Å–Ω–µ–Ω–µ (–ü–æ–º–∞—Ä–∞–Ω—á–µ–≤–∞) ---
        ctxWave.beginPath();
        ctxWave.strokeStyle = '#ff9800'; 
        for(let i=0; i<w; i++) {
            let idxInWindow = Math.floor((i/w) * CFG.fftSize);
            let globalIdx = windowStart + idxInWindow;
            
            if (globalIdx < compressedSignal.length) {
                let val = compressedSignal[globalIdx] * 2;
                if(i===0) ctxWave.moveTo(i, cy - val*50);
                else ctxWave.lineTo(i, cy - val*50);
            }
        }
        ctxWave.stroke();
    }
    // --- PLAYBACK ---
    // Important: We cannot simply play the 1 window. We must play the full recorded buffer.
    // BUT, for the "Compressed" version, applying FFT to the whole 1.5s buffer in JS is slow.
    // Trick: We will play the *original* buffer for "Original",
    // and for "Compressed", we will implement a simple Real-Time filter node 
    // or just loop the visualized window (which sounds buzzy but demonstrates the timbre).
    
    // BETTER DECISION: Let's just process the whole 1.5s buffer using the same Threshold Logic
    // but in chunks (Overlap-Add is too complex for this snippet).
    // Simplified approach: We will just play the single "Window" looped.
    // Why? Because that's exactly what the user Sees. Hearing the "Timbre of the frame".

    function playBuffer(bufferData) {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const src = audioCtx.createBufferSource();
        const buf = audioCtx.createBuffer(1, bufferData.length, CFG.sampleRate);
        buf.getChannelData(0).set(bufferData);
        src.buffer = buf;
        
        // Fade edges to prevent clicking if looped (we won't loop)
        const gain = audioCtx.createGain();
        gain.gain.value = 0.5;
        
        src.connect(gain);
        gain.connect(audioCtx.destination);
        src.start();
    }

function playOriginal() {
        if (!recordedData) return;
        // –ì—Ä–∞—î–º–æ –ø–æ–≤–Ω–∏–π –∑–∞–ø–∏—Å–∞–Ω–∏–π –º–∞—Å–∏–≤, –∞ –Ω–µ —à–º–∞—Ç–æ—á–æ–∫ FFT
        playBuffer(recordedData);
    }

   function playCompressed() {
        if (!compressedSignal) return;
        playBuffer(compressedSignal);
    }

    // Init
    window.addEventListener('resize', () => {
        if(spectrumReal.length) updateCompression();
    });

</script>
</body>
</html>