<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Симулятор Пошуку в Ширину (BFS) та в Глибину (DFS)</title>
    <style>
        :root {
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --bfs-color: #28a745;
            --dfs-color: #dc3545;
            --light-bg: #f4f7f9;
            --white-bg: #ffffff;
            --border-color: #e0e0e0;
            --text-color: #333;
            --comment-color: #555;
            --visited-color: #c5c5c5;
            --current-color: #ffc107;
            --path-color: #0056b3;
            --parent-color: #e67e22; /* Новий колір для стрілок "батько-нащадок" */
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            padding: 20px;
            background-color: var(--light-bg);
        }
        .main-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 40px;
            flex-wrap: wrap;
            width: 100%;
        }
        .simulator-container, .theory-container {
            background-color: var(--white-bg);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 25px;
            width: 100%;
            max-width: 600px;
        }
        h2 {
            text-align: center;
            color: var(--text-color);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
            margin-top: 0;
            margin-bottom: 5px;
        }
        .step-counter {
            text-align: center;
            font-size: 0.9em;
            color: #6c757d;
            margin-bottom: 15px;
            height: 1.2em;
        }
        h2.bfs-title { color: var(--bfs-color); }
        h2.dfs-title { color: var(--dfs-color); }
        .controls, .input-group {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .input-group label { display: flex; align-items: center; gap: 5px; }
        button {
            padding: 10px 18px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: var(--primary-color);
            color: white;
            transition: background-color 0.2s;
        }
        button:hover { background-color: var(--primary-hover); }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        input[type="number"] {
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 5px;
            text-align: center;
            width: 60px;
        }
        input[type="checkbox"] { transform: scale(1.2); margin-right: 5px; }
        .visualization {
            width: 100%;
            height: 400px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }
        .commentary {
            background-color: #f8f9fa;
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 5px;
            min-height: 50px;
            font-size: 1.1em;
            text-align: center;
            word-wrap: break-word;
            line-height: 1.5;
            margin-top: 15px;
            color: var(--comment-color);
        }
        svg { width: 100%; height: 100%; }

        .node circle { stroke: #333; stroke-width: 2px; fill: var(--white-bg); transition: fill 0.3s, stroke 0.3s; }
        .node text { text-anchor: middle; dominant-baseline: central; font-size: 16px; font-weight: bold; pointer-events: none; fill: #333; }
        .edge { stroke: #ccc; stroke-width: 3px; transition: stroke 0.3s, stroke-width 0.3s; }
        .node.visited circle { fill: var(--visited-color); }
        .node.current circle { fill: var(--current-color); stroke: #a67c00; }
        .node.path circle { fill: var(--path-color); stroke: var(--path-color); }
        .node.path text { fill: white; }
        
        /* Cтилі для ребер .path, .parent тепер задаються динамічно через .style */
        
        .ds-box { fill: #f8f9fa; stroke: #aaa; stroke-width: 1px; }
        .ds-text { text-anchor: middle; dominant-baseline: central; font-size: 16px; }
        .ds-label { font-size: 14px; font-weight: bold; text-anchor: start; }

        .theory-container { max-width: 1240px; }
        details { border: 1px solid var(--border-color); border-radius: 5px; padding: 15px; }
        summary { font-size: 1.2em; font-weight: bold; cursor: pointer; color: var(--primary-color); }
        details[open] summary { margin-bottom: 15px; }
        .theory-content h3 { margin-top: 20px; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .theory-content h4 { margin-top: 15px; }
        .theory-content p, .theory-content li { line-height: 1.7; color: var(--text-color); }
        .theory-content code { background-color: #e9ecef; padding: 2px 5px; border-radius: 3px; }
        .theory-content table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        .theory-content th, .theory-content td { border: 1px solid var(--border-color); padding: 10px; text-align: left; }
        .theory-content th { background-color: #f8f9fa; }
    </style>
</head>
<body>
<div class="input-group">
    <label>К-сть вершин:</label>
    <input type="number" id="node-count" value="12" min="5" max="20">
    <label>Старт:</label>
    <input type="number" id="start-node" value="1" min="1" max="20">
    <label>Фініш:</label>
    <input type="number" id="end-node" value="12" min="1" max="20">
    <label>
        <input type="checkbox" id="directed-graph-checkbox">
        Орієнтований
    </label>
    <button id="generate-graph-btn">Згенерувати Новий Граф</button>
</div>

<div class="main-container">
    <div class="simulator-container">
        <h2 class="bfs-title">Пошук в Ширину (BFS)</h2>
        <div class="step-counter" id="bfs-step-counter"></div>
        <div class="visualization">
            <svg id="bfs-svg"></svg>
        </div>
        <div class="controls">
            <button id="bfs-prev-btn" disabled>Крок назад</button>
            <button id="bfs-next-btn" disabled>Крок вперед</button>
        </div>
        <div class="commentary" id="bfs-commentary">Налаштуйте параметри та згенеруйте граф.</div>
    </div>

    <div class="simulator-container">
        <h2 class="dfs-title">Пошук в Глибину (DFS)</h2>
        <div class="step-counter" id="dfs-step-counter"></div>
        <div class="visualization">
            <svg id="dfs-svg"></svg>
        </div>
        <div class="controls">
            <button id="dfs-prev-btn" disabled>Крок назад</button>
            <button id="dfs-next-btn" disabled>Крок вперед</button>
        </div>
        <div class="commentary" id="dfs-commentary">Налаштуйте параметри та згенеруйте граф.</div>
    </div>
</div>

<div class="theory-container">
    <details>
        <summary>Теоретична довідка по BFS та DFS</summary>
        <div class="theory-content">
            <h3>Що таке пошук на графі?</h3>
            <p>
                Пошук на графі — це процес систематичного обходу всіх вершин і ребер графа. <b>Пошук в ширину (BFS)</b> та <b>пошук в глибину (DFS)</b> є двома фундаментальними алгоритмами для цього. Основна відмінність між ними полягає в порядку відвідування вершин.
            </p>

            <h3>Пошук в Ширину (Breadth-First Search, BFS)</h3>
            <p>
                BFS досліджує граф "шар за шаром". Він починається з початкової вершини, відвідує всіх її безпосередніх сусідів, потім сусідів цих сусідів і так далі. Це схоже на кола, що розходяться по воді від кинутого каменя.
            </p>
            <ul>
                <li><b>Структура даних:</b> Використовує <b>чергу (Queue)</b>, яка працює за принципом "перший прийшов — перший вийшов" (FIFO).</li>
                <li><b>Ключова властивість:</b> BFS завжди знаходить <b>найкоротший шлях</b> за кількістю ребер.</li>
            </ul>

            <h3>Пошук в Глибину (Depth-First Search, DFS)</h3>
            <p>
                DFS досліджує граф, рухаючись якомога далі по одному шляху, перш ніж повертатися назад. Він заглиблюється в одну гілку до кінця, потім повертається і досліджує наступну доступну гілку.
            </p>
            <ul>
                <li><b>Структура даних:</b> Використовує <b>стек (Stack)</b>, який працює за принципом "останній прийшов — перший вийшов" (LIFO). </li>
                <li><b>Ключова властивість:</b> DFS не гарантує знаходження найкоротшого шляху, але є дуже корисним для задач, пов'язаних з топологією графа, як-от пошук циклів або компонент зв'язності.</li>
            </ul>
            <hr>
            <h3>Порівняльна таблиця</h3>
            <table>
                <thead>
                    <tr>
                        <th>Характеристика</th>
                        <th>BFS (Пошук в ширину)</th>
                        <th>DFS (Пошук в глибину)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><b>Структура даних</b></td>
                        <td>Черга (Queue)</td>
                        <td>Стек (Stack) або рекурсія</td>
                    </tr>
                    <tr>
                        <td><b>Порядок обходу</b></td>
                        <td>Рівень за рівнем</td>
                        <td>Гілка за гілкою</td>
                    </tr>
                    <tr>
                        <td><b>Найкоротший шлях</b></td>
                        <td><b>Гарантує</b> (за кількістю ребер)</td>
                        <td>Не гарантує</td>
                    </tr>
                    <tr>
                        <td><b>Вимоги до пам'яті</b></td>
                        <td>Може бути великою (O(V)), бо зберігає цілі рівні</td>
                        <td>Зазвичай менша (O(H)), де H - макс. глибина пошуку</td>
                    </tr>
                </tbody>
            </table>
            <hr>
            <h3>Практичне застосування та критерії вибору</h3>
            <h4>Коли обирати BFS?</h4>
            <p>BFS є ідеальним вибором, коли потрібно знайти <b>найкоротший шлях</b> у незваженому графі. Його логіка "дослідження нарізно" гарантує, що перш ніж перейти на наступний "рівень" глибини, будуть перевірені всі вершини на поточному.</p>
            <ul>
                <li><b>Соціальні мережі:</b> Знайти мінімальну кількість "рукостискань" між двома людьми (теорія шести рукостискань).</li>
                <li><b>GPS-навігатори:</b> Пошук найменшої кількості поворотів або транзитних пунктів (якщо кожну ділянку вважати рівною).</li>
                <li><b>Web-краулери:</b> Пошукові системи використовують BFS для індексації сайтів, переходячи з головної сторінки на всі посилання першого рівня, потім другого і т.д.</li>
                <li><b>Пошук найближчих об'єктів:</b> Знайти найближчий ресторан на карті (всі ресторани в радіусі 1 км, потім 2 км і т.д.).</li>
            </ul>
            
            <h4>Коли обирати DFS?</h4>
            <p>DFS краще підходить, коли потрібно просто знайти <b>будь-який шлях</b> (не обов'язково найкоротший), перевірити зв'язність графа або дослідити всі можливі варіанти до кінця.</p>
             <ul>
                <li><b>Розв'язання лабіринтів:</b> DFS іде одним шляхом до глухого кута, повертається і пробує інший. Це природний спосіб знайти вихід.</li>
                <li><b>Топологічне сортування:</b> Упорядкування задач, що мають залежності (наприклад, перед встановленням програми потрібно встановити бібліотеки, від яких вона залежить).</li>
                <li><b>Пошук циклів у графі:</b> DFS легко виявляє цикли, що є критичним для багатьох алгоритмів.</li>
                <li><b>Генерація комбінаторних об'єктів:</b> Наприклад, знаходження всіх можливих розстановок у шахах.</li>
            </ul>
            <hr>
            <h3>Обмеження: незважені графи</h3>
            <p>Важливо розуміти, що і BFS, і DFS працюють коректно для <b>незважених графів</b> — тобто графів, де всі ребра вважаються рівноцінними (мають вагу 1). Якщо ребра мають різну "вартість" (наприклад, відстань між містами, час у дорозі, вартість квитка), ці алгоритми не знайдуть оптимальний шлях.</p>
            <p>Для роботи зі <b>зваженими графами</b> використовуються складніші алгоритми:</p>
            <ul>
                <li><b>Алгоритм Дейкстри:</b> Знаходить найкоротший (найлегший) шлях від однієї стартової вершини до всіх інших у графі з невід'ємними вагами ребер. Можна вважати, що BFS є окремим випадком алгоритму Дейкстри, де вага всіх ребер дорівнює 1.</li>
                <li><b>Алгоритм Флойда-Уоршелла:</b> Знаходить найкоротші шляхи між <b>усіма</b> парами вершин у графі. Він може працювати з ребрами, що мають від'ємну вагу (але не з циклами від'ємної ваги).</li>
            </ul>
        </div>
    </details>
</div>

<script>
// --- GLOBAL STATE ---
let graph = { nodes: [], edges: [], adj: new Map(), isDirected: false };
let bfsState = { steps: [], currentStep: -1 };
let dfsState = { steps: [], currentStep: -1 };
let physicsAnimationId = null;

// --- DOM ELEMENTS ---
const nodeCountInput = document.getElementById('node-count');
const startNodeInput = document.getElementById('start-node');
const endNodeInput = document.getElementById('end-node');
const generateBtn = document.getElementById('generate-graph-btn');
const directedCheckbox = document.getElementById('directed-graph-checkbox');

const bfsSVG = document.getElementById('bfs-svg');
const bfsPrevBtn = document.getElementById('bfs-prev-btn');
const bfsNextBtn = document.getElementById('bfs-next-btn');
const bfsCommentary = document.getElementById('bfs-commentary');
const bfsStepCounter = document.getElementById('bfs-step-counter');

const dfsSVG = document.getElementById('dfs-svg');
const dfsPrevBtn = document.getElementById('dfs-prev-btn');
const dfsNextBtn = document.getElementById('dfs-next-btn');
const dfsCommentary = document.getElementById('dfs-commentary');
const dfsStepCounter = document.getElementById('dfs-step-counter');

// --- CONSTANTS ---
const NODE_RADIUS = 15;

// ===================================================================
// MAIN CONTROL FUNCTIONS
// ===================================================================
function generateAndStart() {
    generateBtn.disabled = true;
    generateBtn.textContent = "Генерація...";
    
    generateGraphStructure(parseInt(nodeCountInput.value));
    
    runPhysicsLayout(() => {
        restartSearch();
        generateBtn.disabled = false;
        generateBtn.textContent = "Згенерувати Новий Граф";
    });
}

function restartSearch() {
    if (!graph.nodes || graph.nodes.length === 0) return;

    const n = graph.nodes.length;
    const startNode = parseInt(startNodeInput.value);
    const endNode = parseInt(endNodeInput.value);

    if (startNode > n || endNode > n || startNode < 1 || endNode < 1) {
        alert(`Стартова та фінішна вершини повинні бути в діапазоні від 1 до ${n}.`);
        return;
    }

    runBFS(startNode, endNode);
    runDFS(startNode, endNode);
}

function generateGraphStructure(n) {
    graph.nodes = [];
    graph.edges = [];
    graph.adj.clear();
    graph.isDirected = directedCheckbox.checked;
    const width = bfsSVG.clientWidth;
    const height = bfsSVG.clientHeight;

    for (let i = 1; i <= n; i++) {
        graph.nodes.push({ id: i, x: Math.random() * (width - 40) + 20, y: Math.random() * (height - 40) + 20, vx: 0, vy: 0 });
        graph.adj.set(i, []);
    }
    
    const visited = new Set([1]);
    let unvisited = Array.from({length: n-1}, (_, i) => i + 2);

    while(unvisited.length > 0) {
      const u = [...visited][Math.floor(Math.random() * visited.size)];
      const vIndex = Math.floor(Math.random() * unvisited.length);
      const v = unvisited[vIndex];
      visited.add(v);
      unvisited.splice(vIndex, 1);
      
      graph.edges.push([u, v]);
      graph.adj.get(u).push(v);
      if (!graph.isDirected) graph.adj.get(v).push(u);
    }
    
    const extraEdges = Math.floor(n / 4);
    for(let i=0; i<extraEdges; i++) {
        let u = Math.floor(Math.random() * n) + 1;
        let v = Math.floor(Math.random() * n) + 1;
        if(u !== v && !graph.adj.get(u).includes(v)) {
            graph.edges.push([u, v]);
            graph.adj.get(u).push(v);
            if (!graph.isDirected) graph.adj.get(v).push(u);
        }
    }
}

// ===================================================================
// ALGORITHMS (BFS & DFS)
// ===================================================================
function runBFS(start, end) {
    bfsState = { steps: [], currentStep: -1 };
    let queue = [start], visited = new Set([start]), parent = new Map();

    // *** ЗМІНЕНО: Додаємо 'parents' у кожен крок ***
    const saveStep = (current, commentary, path = null) => bfsState.steps.push({ 
        queue: [...queue], 
        visited: new Set(visited), 
        current, 
        path, 
        commentary, 
        parents: new Map(parent) 
    });
    saveStep(null, `Починаємо з вершини <b>${start}</b>. Додаємо її в чергу.`);

    let found = false;
    while (queue.length > 0) {
        let u = queue.shift();
        saveStep(u, `Беремо <b>${u}</b> з початку черги.`);

        if (u === end) {
            found = true;
            let path = [];
            for (let curr = end; curr !== undefined; curr = parent.get(curr)) path.unshift(curr);
            saveStep(u, `Знайдено ціль <b>${end}</b>! Відновлюємо шлях, рухаючись назад від <b>${end}</b> до <b>${start}</b>, слідуючи за "батьківськими" вершинами, які ми зберегли під час пошуку.`, path);
            break;
        }

        const neighbors = graph.adj.get(u).sort((a,b) => a-b);
        let neighborsAdded = [];
        for (const v of neighbors) {
            if (!visited.has(v)) {
                visited.add(v); parent.set(v, u); queue.push(v);
                neighborsAdded.push(v);
            }
        }
        
        if (neighborsAdded.length > 0) saveStep(u, `Додаємо невідвіданих сусідів <b>${u}</b> (${neighborsAdded.join(', ')}) в кінець черги. Зберігаємо <b>${u}</b> як їх "батька".`);
        else saveStep(u, `У вершини <b>${u}</b> немає невідвіданих сусідів.`);
    }
    
    if (!found) saveStep(null, `Черга порожня. Шлях до <b>${end}</b> з вершини <b>${start}</b> не існує.`);
    bfsState.currentStep = 0;
    updateBFSView();
}


/*


function runDFS(start, end) {
    dfsState = { steps: [], currentStep: -1 };
    let stack = [start];
    let visited = new Set();
    let parent = new Map();
    let inStack = new Set([start]); // Додаємо множину для відстеження вершин у стеку

    const saveStep = (current, commentary, path = null) => dfsState.steps.push({ 
        stack: [...stack], 
        visited: new Set(visited), 
        current, 
        path, 
        commentary, 
        parents: new Map(parent) 
    });
    
    // Крок 0: Ініціалізація
    saveStep(null, `Починаємо з вершини <b>${start}</b>. Додаємо її в стек.`);

    let found = false;
    
    while(stack.length > 0 && !found) {
        let u = stack.pop();
        inStack.delete(u); // Видаляємо з множини вершин у стеку

        // Пропускаємо вершину, якщо вона вже відвідана
        if(visited.has(u)) {
            saveStep(null, `Вершина <b>${u}</b> вже була відвідана. Пропускаємо.`);
            continue;
        }

        // Відвідуємо поточну вершину
        visited.add(u);
        saveStep(u, `Беремо <b>${u}</b> з вершини стека і позначаємо як відвідану.`);

        // Перевіряємо, чи знайшли ціль
        if (u === end) {
            found = true;
            let path = [];
            for (let curr = end; curr !== undefined; curr = parent.get(curr)) 
                path.unshift(curr);
            saveStep(u, `Знайдено ціль <b>${end}</b>! Відновлюємо шлях.`, path);
            break;
        }

        // Додаємо тільки невідвіданих сусідів, яких ще немає в стеку
        const neighbors = graph.adj.get(u).sort((a,b) => b-a);
        let neighborsAdded = [];
        
        for (const v of neighbors) {
            if (!visited.has(v) && !inStack.has(v)) {
                stack.push(v);
                inStack.add(v); // Додаємо в множину вершин у стеку
                parent.set(v, u);
                neighborsAdded.push(v);
            }
        }
        
        if(neighborsAdded.length > 0) {
            saveStep(u, `Додаємо невідвіданих сусідів <b>${u}</b> (${neighborsAdded.join(', ')}) на вершину стека. Зберігаємо <b>${u}</b> як їх "батька".`);
        } else {
            saveStep(u, `У вершини <b>${u}</b> немає невідвіданих сусідів для додавання.`);
        }
    }
    
    // Якщо цикл завершився і ціль не знайдена
    if (!found) {
        saveStep(null, `Стек порожній. Шлях до <b>${end}</b> з вершини <b>${start}</b> не існує.`);
    }
    
    dfsState.currentStep = 0;
    updateDFSView();
}*/

function runDFS(start, end) {
    dfsState = { steps: [], currentStep: -1 };
    let stack = [start];
    let visited = new Set();
    let parent = new Map();
    let inStack = new Set([start]);

    const saveStep = (current, commentary, path = null) => dfsState.steps.push({ 
        stack: [...stack], 
        visited: new Set(visited), 
        current, 
        path, 
        commentary, 
        parents: new Map(parent) 
    });
    
    // Крок 0: Ініціалізація
    saveStep(null, `Починаємо з вершини <b>${start}</b>. Додаємо її в стек.`);

    let found = false;
    
    while(stack.length > 0 && !found) {
        let u = stack.pop();
        inStack.delete(u);

        // Пропускаємо вершину, якщо вона вже відвідана
        if(visited.has(u)) {
            saveStep(null, `Вершина <b>${u}</b> вже була відвідана. Пропускаємо.`);
            continue;
        }

        // Відвідуємо поточну вершину
        visited.add(u);
        saveStep(u, `Беремо <b>${u}</b> з вершини стека і позначаємо як відвідану.`);

        // Перевіряємо, чи знайшли ціль
        if (u === end) {
            found = true;
            let path = [];
            for (let curr = end; curr !== undefined; curr = parent.get(curr)) 
                path.unshift(curr);
            saveStep(u, `Знайдено ціль <b>${end}</b>! Відновлюємо шлях.`, path);
            break;
        }

        // Додаємо тільки невідвіданих сусідів, яких ще немає в стеку
        const neighbors = graph.adj.get(u).sort((a,b) => b-a);
        let neighborsAdded = [];
        
        for (const v of neighbors) {
            if (!visited.has(v) && !inStack.has(v)) {
                // Перевіряємо, чи є ця вершина цільовою
                if (v === end) {
                    found = true;
                    parent.set(v, u);
                    let path = [];
                    for (let curr = end; curr !== undefined; curr = parent.get(curr)) 
                        path.unshift(curr);
                    // Додаємо цільову вершину в стек для коректного відображення
                    stack.push(v);
                    saveStep(u, `Знайдено цільову вершину <b>${end}</b> серед сусідів <b>${u}</b>. Відновлюємо шлях.`, path);
                    break;
                } else {
                    stack.push(v);
                    inStack.add(v);
                    parent.set(v, u);
                    neighborsAdded.push(v);
                }
            }
        }
        
        // Якщо знайшли ціль, виходимо з циклу
        if (found) break;
        
        if(neighborsAdded.length > 0) {
            saveStep(u, `Додаємо невідвіданих сусідів <b>${u}</b> (${neighborsAdded.join(', ')}) на вершину стека. Зберігаємо <b>${u}</b> як їх "батька".`);
        } else {
            saveStep(u, `У вершини <b>${u}</b> немає невідвіданих сусідів для додавання.`);
        }
    }
    
    // Якщо цикл завершився і ціль не знайдена
    if (!found) {
        saveStep(null, `Стек порожній. Шлях до <b>${end}</b> з вершини <b>${start}</b> не існує.`);
    }
    
    dfsState.currentStep = 0;
    updateDFSView();
}
function updateBFSView() {
    const step = bfsState.steps[bfsState.currentStep];
    if (!step) return;
    updateVisualization(bfsSVG, step, 'queue');
    bfsCommentary.innerHTML = step.commentary;
    bfsStepCounter.textContent = `Крок: ${bfsState.currentStep + 1} / ${bfsState.steps.length}`;
    bfsPrevBtn.disabled = bfsState.currentStep === 0;
    bfsNextBtn.disabled = bfsState.currentStep === bfsState.steps.length - 1;
}

function updateDFSView() {
    const step = dfsState.steps[dfsState.currentStep];
    if (!step) return;
    updateVisualization(dfsSVG, step, 'stack');
    dfsCommentary.innerHTML = step.commentary;
    dfsStepCounter.textContent = `Крок: ${dfsState.currentStep + 1} / ${dfsState.steps.length}`;
    dfsPrevBtn.disabled = dfsState.currentStep === 0;
    dfsNextBtn.disabled = dfsState.currentStep === dfsState.steps.length - 1;
}

// ===================================================================
// SHARED DRAWING & PHYSICS
// ===================================================================
function drawGraphLayout(svgElement) {
    svgElement.innerHTML = ''; 
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    // *** ЗМІНЕНО: Додано маркери 'arrowhead-path' (з var) та 'arrowhead-parent' ***
    defs.innerHTML = `
        <marker id="arrowhead" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#999" />
        </marker>
        <marker id="arrowhead-path" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--path-color)" />
        </marker>
        <marker id="arrowhead-parent" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--parent-color)" />
        </marker>`;
    svgElement.appendChild(defs);

    graph.edges.forEach(([u, v]) => {
        const nodeU = graph.nodes.find(n => n.id === u), nodeV = graph.nodes.find(n => n.id === v);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('data-u', u); line.setAttribute('data-v', v); line.classList.add('edge');
        
        // Базове налаштування - буде ПЕРЕЗАПИСАНО в updateVisualization
        if (graph.isDirected) {
            const [x1, y1, x2, y2] = getArrowCoords(nodeU, nodeV);
            line.setAttribute('x1', x1); line.setAttribute('y1', y1);
            line.setAttribute('x2', x2); line.setAttribute('y2', y2);
            line.setAttribute('marker-end', 'url(#arrowhead)');
        } else {
            line.setAttribute('x1', nodeU.x); line.setAttribute('y1', nodeU.y);
            line.setAttribute('x2', nodeV.x); line.setAttribute('y2', nodeV.y);
        }
        svgElement.appendChild(line);
    });

    graph.nodes.forEach(node => {
        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.setAttribute('data-id', node.id); group.classList.add('node');
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', node.x); circle.setAttribute('cy', node.y); circle.setAttribute('r', NODE_RADIUS);
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', node.x); text.setAttribute('y', node.y); text.textContent = node.id;
        group.appendChild(circle); group.appendChild(text);
        svgElement.appendChild(group);
    });
}

// *** НОВА ФУНКЦІЯ: Обчислює координати для лінії зі стрілкою (з відступом від вузла) ***
function getArrowCoords(startNode, endNode) {
    const dx = endNode.x - startNode.x, dy = endNode.y - startNode.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if (dist > 0) {
        const ratio = (dist - NODE_RADIUS - 2) / dist; // Відступ для стрілки
        return [startNode.x, startNode.y, startNode.x + dx * ratio, startNode.y + dy * ratio];
    } else {
        return [startNode.x, startNode.y, endNode.x, endNode.y];
    }
}

// *** ЗМІНЕНО: Повністю переписана логіка для малювання стрілок "батьків" ***
function updateVisualization(svgElement, step, dsType) {
    drawGraphLayout(svgElement); // Перемальовуємо базовий граф
    const { visited, current, path, parents } = step; // Отримуємо 'parents' з кроку
    
    // Створюємо сет *спрямованих* ребер, що належать фінальному шляху
    const pathEdges = new Set();
    if (path) {
        for(let i = 0; i < path.length - 1; i++) {
            pathEdges.add(`${path[i]}-${path[i+1]}`);
        }
    }

    // Оновлюємо кожне ребро відповідно до стану кроку
    svgElement.querySelectorAll('.edge').forEach(edge => {
        const u_id = parseInt(edge.getAttribute('data-u'));
        const v_id = parseInt(edge.getAttribute('data-v'));

        const nodeU = graph.nodes.find(n => n.id === u_id);
        const nodeV = graph.nodes.find(n => n.id === v_id);

        let marker = null;
        let strokeColor = null;
        let strokeWidth = null;
        let x1 = nodeU.x, y1 = nodeU.y, x2 = nodeV.x, y2 = nodeV.y; // За замовчуванням: проста лінія

        // 1. Перевірка на ФІНАЛЬНИЙ ШЛЯХ (найвищий пріоритет)
        if (pathEdges.has(`${u_id}-${v_id}`)) { // Шлях u -> v
            marker = 'url(#arrowhead-path)';
            strokeColor = 'var(--path-color)';
            strokeWidth = '5px';
            [x1, y1, x2, y2] = getArrowCoords(nodeU, nodeV);
        } else if (pathEdges.has(`${v_id}-${u_id}`)) { // Шлях v -> u (актуально для неорієнтованого)
            marker = 'url(#arrowhead-path)';
            strokeColor = 'var(--path-color)';
            strokeWidth = '5px';
            [x1, y1, x2, y2] = getArrowCoords(nodeV, nodeU);
        }
        // 2. Перевірка на "БАТЬКІВСЬКЕ" ребро (не на фінальному шляху)
        else if (parents.get(v_id) === u_id) { // Батько u -> нащадок v
            marker = 'url(#arrowhead-parent)';
            strokeColor = 'var(--parent-color)';
            strokeWidth = '4px';
            [x1, y1, x2, y2] = getArrowCoords(nodeU, nodeV);
        } else if (parents.get(u_id) === v_id) { // Батько v -> нащадок u (актуально для неорієнтованого)
            marker = 'url(#arrowhead-parent)';
            strokeColor = 'var(--parent-color)';
            strokeWidth = '4px';
            [x1, y1, x2, y2] = getArrowCoords(nodeV, nodeU);
        }
        // 3. Звичайне ОРІЄНТОВАНЕ ребро
        else if (graph.isDirected) {
            marker = 'url(#arrowhead)';
            [x1, y1, x2, y2] = getArrowCoords(nodeU, nodeV);
        }
        
        // Застосовуємо атрибути
        edge.setAttribute('x1', x1);
        edge.setAttribute('y1', y1);
        edge.setAttribute('x2', x2);
        edge.setAttribute('y2', y2);
        
        if (marker) edge.setAttribute('marker-end', marker);
        else edge.removeAttribute('marker-end');
        
        // Скидаємо стилі, якщо вони не задані, щоб CSS міг їх контролювати
        edge.style.stroke = strokeColor ? strokeColor : "";
        edge.style.strokeWidth = strokeWidth ? strokeWidth : "";
    });

    // Стилізація вузлів (залишилась без змін)
    svgElement.querySelectorAll('.node').forEach(group => {
        const nodeId = parseInt(group.getAttribute('data-id'));
        if (path && path.includes(nodeId)) group.classList.add('path');
        else if (nodeId === current) group.classList.add('current');
        else if (visited.has(nodeId)) group.classList.add('visited');
    });

    drawDataStructure(svgElement, dsType, dsType === 'queue' ? step.queue : step.stack);
}

function drawDataStructure(svg, type, items) {
    const BOX_SIZE = 30, PADDING = 10, SPACING = 5;
    const width = svg.clientWidth, height = svg.clientHeight;
    const dsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    if (type === 'queue') {
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', PADDING); label.setAttribute('y', height - PADDING - BOX_SIZE / 2);
        label.classList.add('ds-label'); label.textContent = "Черга →"; dsGroup.appendChild(label);
        items.forEach((item, i) => {
            const x = PADDING + 60 + i * (BOX_SIZE + SPACING), y = height - PADDING - BOX_SIZE;
            const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            box.setAttribute('x', x); box.setAttribute('y', y); box.setAttribute('width', BOX_SIZE); box.setAttribute('height', BOX_SIZE);
            box.classList.add('ds-box'); dsGroup.appendChild(box);
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x + BOX_SIZE / 2); text.setAttribute('y', y + BOX_SIZE / 2);
            text.classList.add('ds-text'); text.textContent = item; dsGroup.appendChild(text);
        });
    } else { // stack
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', width - PADDING - BOX_SIZE); label.setAttribute('y', height - PADDING * 2 - items.length * (BOX_SIZE + SPACING));
        label.classList.add('ds-label'); label.textContent = "Стек"; dsGroup.appendChild(label);
        items.forEach((item, i) => {
            const x = width - PADDING - BOX_SIZE, y = height - PADDING - (i + 1) * (BOX_SIZE + SPACING);
            const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            box.setAttribute('x', x); box.setAttribute('y', y); box.setAttribute('width', BOX_SIZE); box.setAttribute('height', BOX_SIZE);
            box.classList.add('ds-box'); dsGroup.appendChild(box);
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x + BOX_SIZE / 2); text.setAttribute('y', y + BOX_SIZE / 2);
            text.classList.add('ds-text'); text.textContent = item; dsGroup.appendChild(text);
        });
    }
    svg.appendChild(dsGroup);
}

function runPhysicsLayout(onComplete) {
    if (physicsAnimationId) cancelAnimationFrame(physicsAnimationId);
    let iterations = 150;
    function step() {
        physicsStep();
        drawGraphLayout(bfsSVG);
        drawGraphLayout(dfsSVG);
        if (--iterations > 0) physicsAnimationId = requestAnimationFrame(step);
        else onComplete();
    }
    step();
}

function physicsStep() {
    const REPULSION = 2000, SPRING_K = 0.05, SPRING_LEN = 100, DAMPING = 0.85;
    const width = bfsSVG.clientWidth, height = bfsSVG.clientHeight;
    graph.nodes.forEach(n => { n.fx = 0; n.fy = 0; });
    for (let i = 0; i < graph.nodes.length; i++) {
        for (let j = i + 1; j < graph.nodes.length; j++) {
            const n1 = graph.nodes[i], n2 = graph.nodes[j], dx = n1.x - n2.x, dy = n1.y - n2.y;
            const distSq = dx * dx + dy * dy;
            if (distSq > 1) {
                const dist = Math.sqrt(distSq), force = REPULSION / distSq;
                n1.fx += (dx / dist) * force; n1.fy += (dy / dist) * force;
                n2.fx -= (dx / dist) * force; n2.fy -= (dy / dist) * force;
            }
        }
    }
    graph.edges.forEach(([u, v]) => {
        const n1 = graph.nodes.find(n => n.id === u), n2 = graph.nodes.find(n => n.id === v);
        const dx = n1.x - n2.x, dy = n1.y - n2.y, dist = Math.sqrt(dx * dx + dy * dy);
        const force = SPRING_K * (dist - SPRING_LEN);
        n1.fx -= (dx / dist) * force; n1.fy -= (dy / dist) * force;
        n2.fx += (dx / dist) * force; n2.fy += (dy / dist) * force;
    });
    graph.nodes.forEach(n => {
        n.vx = (n.vx + n.fx) * DAMPING; n.vy = (n.vy + n.fy) * DAMPING;
        n.x += n.vx; n.y += n.vy;
        if (n.x < NODE_RADIUS) { n.x = NODE_RADIUS; n.vx *= -1; }
        if (n.x > width - NODE_RADIUS) { n.x = width - NODE_RADIUS; n.vx *= -1; }
        if (n.y < NODE_RADIUS) { n.y = NODE_RADIUS; n.vy *= -1; }
        if (n.y > height - NODE_RADIUS) { n.y = height - NODE_RADIUS; n.vy *= -1; }
    });
}

// --- EVENT LISTENERS ---
generateBtn.addEventListener('click', generateAndStart);
startNodeInput.addEventListener('change', restartSearch);
endNodeInput.addEventListener('change', restartSearch);
directedCheckbox.addEventListener('change', generateAndStart);

bfsNextBtn.addEventListener('click', () => { if (bfsState.currentStep < bfsState.steps.length - 1) { bfsState.currentStep++; updateBFSView(); }});
bfsPrevBtn.addEventListener('click', () => { if (bfsState.currentStep > 0) { bfsState.currentStep--; updateBFSView(); }});
dfsNextBtn.addEventListener('click', () => { if (dfsState.currentStep < dfsState.steps.length - 1) { dfsState.currentStep++; updateDFSView(); }});
dfsPrevBtn.addEventListener('click', () => { if (dfsState.currentStep > 0) { dfsState.currentStep--; updateDFSView(); }});

nodeCountInput.addEventListener('change', () => {
    const n = parseInt(nodeCountInput.value);
    startNodeInput.max = n; endNodeInput.max = n;
    if (parseInt(startNodeInput.value) > n) startNodeInput.value = 1;
    if (parseInt(endNodeInput.value) > n) endNodeInput.value = n;
});

window.addEventListener('load', generateAndStart);
</script>
</body>
</html>