<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Топологія: Тор (K3,3 / Карта Карно) ➔ Прямокутник</title>
    <style>
        body { margin: 0; background-color: #111; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            pointer-events: none;
        }
        #slider-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            box-sizing: border-box;
            display: flex;
            align-items: center;
        }
        .slider {
            -webkit-appearance: none;
            flex-grow: 1; 
            height: 8px;
            background: #444;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        .slider:hover { opacity: 1; }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ff00;
            border-radius: 50%;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ff00;
            border-radius: 50%;
            cursor: pointer;
        }
        #play-pause-button {
            padding: 8px 12px;
            margin-right: 10px;
            background: #00ff00;
            color: #111;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-family: Arial, sans-serif;
            min-width: 60px;
            text-align: center;
        }
        #play-pause-button:hover { background: #33ff33; }
        
        #controls-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 5px;
            color: white;
            font-family: Arial, sans-serif;
        }
        #controls-container label {
            margin-right: 5px;
        }
        #controls-container select {
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 3px;
            padding: 2px;
        }
    </style>
</head>
<body>
    <div id="info">Трансформація: Тор (K3,3 / Карта Карно) ➔ Циліндр ➔ Прямокутник</div>
    
    <div id="controls-container">
        <label for="overlay-select">Відображення:</label>
        <select id="overlay-select">
            <option value="none">Нічого</option>
            <option value="k33"selected>Граф K3,3</option>
            <option value="karnaugh" >Карта Карно</option>
        </select>
    </div>

    <div id="slider-container">
        <button id="play-pause-button">Pause</button>
        <input type="range" min="0" max="1000" value="0" class="slider" id="progress-slider">
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';

        let scene, camera, renderer, controls;
        let torusMesh, cylinderMesh, rectMesh, material;
        let slider, clock, playPauseButton;
        
        let currentOverlay = 'none'; 

        // --- КОНСТАНТИ АНІМАЦІЇ ---
        const R0 = 6; 
        const r0 = 4; 
        const finalWidth = 2 * Math.PI * r0;  
        const finalHeight = 2 * Math.PI * R0; 
        const minTheta = 0.01;         
        const loopDuration = 10;       
        
        // --- ЕТАПИ ТРАНСФОРМАЦІЇ ---
        const t_TorusToCyl_End = 0.49;    
        const t_Cyl_Start = 0.51;         
        const t_CylToRect_End = 0.99;     

        // --- СТАН АНІМАЦІЇ ---
        let manualControl = false; 
        let lastProgress = 0;      
        let animStartTime = 0;     
        let isPlaying = true; 

        // --- Змінні для параметричних функцій ---
        let current_R, u_start, u_end; 
        let current_r;
        let current_gap_u = 0.0;
        let current_gap_v = 0.0;
        
        // --- Змінні для графа K3,3 ---
        let k33GraphGroup;
        let k33Vertices = []; 
        let k33Edges = []; 
        let k33UVCoords = []; 
        let k33EdgeIndices = []; 
        
        // --- Змінні для Карти Карно ---
        let kMapGroup;
        let kMapLines = []; // Групи ліній
        let kMapMarkers = []; // Кульки (маркери)
        // --- ВИПРАВЛЕННЯ v15: Товщина ліній ---
        const kMapLineMat = new THREE.LineBasicMaterial({ color: 0xffa500, linewidth: 2 });
        // ---
        
        const EDGE_SEGMENTS = 40; 
        const MAX_EDGE_SPLITS = 4; 
        const tempVec = new THREE.Vector3(); 
        const vertexMatRed = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const vertexMatBlue = new THREE.MeshStandardMaterial({ color: 0x0000ff });
        // --- ВИПРАВЛЕННЯ v15: Товщина ліній ---
        const k33EdgeMat = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 });
        // ---
        const mod = (n, m) => ((n % m) + m) % m; 
        // --- Кінець блоку графа ---

        function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(finalWidth * 1.5, finalHeight * 0.4, finalHeight * 0.7);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            // --- ВИПРАВЛЕННЯ v15: Активуємо товщину ліній ---
            renderer.setPixelRatio(window.devicePixelRatio); 
            // ---

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 0, 0); 

            const ambientLight = new THREE.AmbientLight(0x404040, 3);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
            directionalLight.position.set(10, 15, 10);
            scene.add(directionalLight);
            
            const gridHelper = new THREE.GridHelper(
                Math.max(finalWidth, finalHeight) * 1.5, 
                20, 
                0x888888, 0x444444
            );
            gridHelper.position.y = -0.1; // Опущено підлогу
            scene.add(gridHelper);

            material = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                wireframe: false,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8,
                roughness: 0.3,
                metalness: 0.1
            });

            torusMesh = new THREE.Mesh(new THREE.BufferGeometry(), material);
            scene.add(torusMesh);

            cylinderMesh = new THREE.Mesh(new THREE.BufferGeometry(), material);
            scene.add(cylinderMesh);

            const rectGeo = new THREE.PlaneGeometry(finalHeight, finalWidth);
            rectGeo.rotateX(-Math.PI / 2); 
            rectMesh = new THREE.Mesh(rectGeo, material);
            rectMesh.position.y = 0; 
            rectMesh.visible = false;
            scene.add(rectMesh);

            // --- Ініціалізація шарів ---
            initK33Graph();
            initKarnaughMap();
            // ---

            // --- Обробники UI ---
            slider = document.getElementById('progress-slider');
            slider.addEventListener('input', () => {
                const progress = parseFloat(slider.value) / 1000.0;
                updateAnimation(progress); 
                lastProgress = progress;
            });
            slider.addEventListener('pointerdown', () => {
                manualControl = true;
                if (isPlaying) { playPauseButton.textContent = 'Play'; }
            });
            slider.addEventListener('pointerup', () => {
                manualControl = false;
                lastProgress = parseFloat(slider.value) / 1000.0;
                animStartTime = clock.getElapsedTime();
                if (isPlaying) { playPauseButton.textContent = 'Pause'; }
            });

            playPauseButton = document.getElementById('play-pause-button');
            playPauseButton.addEventListener('click', togglePlayPause);
            
            const overlaySelect = document.getElementById('overlay-select');
            overlaySelect.addEventListener('change', (e) => {
                currentOverlay = e.target.value;
                updateOverlayVisibility();
            });
            currentOverlay = overlaySelect.value;
            updateOverlayVisibility();
            // ---

            window.addEventListener('resize', onWindowResize, false);
            
            updateAnimation(0);
        }

        function togglePlayPause() {
            isPlaying = !isPlaying;
            if (isPlaying) {
                playPauseButton.textContent = 'Pause';
                animStartTime = clock.getElapsedTime(); 
            } else {
                playPauseButton.textContent = 'Play';
                lastProgress = parseFloat(slider.value) / 1000.0; 
            }
        }

        function updateOverlayVisibility() {
            if (k33GraphGroup) k33GraphGroup.visible = (currentOverlay === 'k33');
            if (kMapGroup) kMapGroup.visible = (currentOverlay === 'karnaugh');
        }
        
        
        function createLabelSprite(text, fontSize = 64, scale = 1.5) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = `Bold ${fontSize}px Arial`;
            const metrics = context.measureText(text);
            canvas.width = metrics.width;
            canvas.height = fontSize * 1.2; 
            context.font = `Bold ${fontSize}px Arial`;
            context.fillStyle = 'rgba(255, 255, 255, 0.9)';
            context.fillText(text, 0, fontSize);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            const material = new THREE.SpriteMaterial({ map: texture, depthTest: false });
            const sprite = new THREE.Sprite(material);
            const spriteScale = canvas.width / canvas.height;
            sprite.scale.set(scale * spriteScale, scale, 1.0);
            return sprite;
        }

        
        // --- Блок Графа K3,3 ---
        function initK33Graph() {
            k33GraphGroup = new THREE.Group();
            scene.add(k33GraphGroup);
            const vertexGeo = new THREE.SphereGeometry(0.5, 16, 16); 
            k33UVCoords.push({ u_norm: 0.8, v_norm: 0.8 }); // U1 (0)
            k33UVCoords.push({ u_norm: 0.2, v_norm: 0.5 }); // U2 (1)
            k33UVCoords.push({ u_norm: 0.5, v_norm: 0.2 }); // U3 (2)
            k33UVCoords.push({ u_norm: 0.5, v_norm: 0.8 }); // V1 (3)
            k33UVCoords.push({ u_norm: 0.8, v_norm: 0.5 }); // V2 (4)
            k33UVCoords.push({ u_norm: 0.2, v_norm: 0.2 }); // V3 (5)
            for (let i = 0; i < 6; i++) {
                const mat = (i < 3) ? vertexMatRed : vertexMatBlue; 
                const vertexMesh = new THREE.Mesh(vertexGeo, mat);
                const labelText = (i < 3) ? `U${i+1}` : `V${i-3+1}`;
                const label = createLabelSprite(labelText);
                label.position.set(0, 1.2, 0); 
                vertexMesh.add(label); 
                k33Vertices.push(vertexMesh);
                k33GraphGroup.add(vertexMesh);
            }
            k33EdgeIndices = [
                [0, 3], [0, 4], [0, 5],
                [1, 3], [1, 4], [1, 5],
                [2, 3], [2, 4], [2, 5]
            ];
            for (const indices of k33EdgeIndices) {
                const edgeGroup = new THREE.Group();
                edgeGroup.userData.edgeIndices = indices; 
                edgeGroup.userData.linePool = [];
                for (let i = 0; i < MAX_EDGE_SPLITS; i++) {
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array((EDGE_SEGMENTS + 1) * 3), 3));
                    const line = new THREE.Line(geometry, k33EdgeMat);
                    line.visible = false;
                    edgeGroup.userData.linePool.push(line);
                    edgeGroup.add(line);
                }
                k33Edges.push(edgeGroup);
                k33GraphGroup.add(edgeGroup);
            }
        }
        // --- Кінець блоку K3,3 ---


        // --- Блок: Карта Карно ---
        function initKarnaughMap() {
            kMapGroup = new THREE.Group();
            kMapLines = [];
            kMapMarkers = [];
            scene.add(kMapGroup);
            
            // --- 1. Створюємо Лінії (10 ліній) ---
            const lineDefs = [];
            for (let i = 0; i <= 4; i++) { // 5 Вертикальних
                const u = i * 0.25;
                lineDefs.push({ start_uv: {u_norm: u, v_norm: 0.0}, end_uv: {u_norm: u, v_norm: 1.0} });
            }
            for (let i = 0; i <= 4; i++) { // 5 Горизонтальних
                const v = i * 0.25;
                lineDefs.push({ start_uv: {u_norm: 0.0, v_norm: v}, end_uv: {u_norm: 1.0, v_norm: v} });
            }
            // Створюємо пул ліній
            for (const def of lineDefs) {
                const edgeGroup = new THREE.Group();
                edgeGroup.userData = def; 
                edgeGroup.userData.linePool = [];
                for (let i = 0; i < MAX_EDGE_SPLITS; i++) {
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array((EDGE_SEGMENTS + 1) * 3), 3));
                    const line = new THREE.Line(geometry, kMapLineMat);
                    line.visible = false;
                    edgeGroup.userData.linePool.push(line);
                    edgeGroup.add(line);
                }
                kMapLines.push(edgeGroup);
                kMapGroup.add(edgeGroup);
            }
            
            // --- 2. Створюємо Маркери (Кульки) ---
            const markerGeo = new THREE.SphereGeometry(0.4, 16, 16); 
            const cellCenter = 0.125; // 0.25 / 2
            
            // (u, v)
            const blueCoords = [
                { u: cellCenter, v: cellCenter }, // Кут (0,0)
                { u: 1.0 - cellCenter, v: cellCenter }, // Кут (3,0)
                { u: cellCenter, v: 1.0 - cellCenter }, // Кут (0,3)
                { u: 1.0 - cellCenter, v: 1.0 - cellCenter }  // Кут (3,3)
            ];
            
            // --- ВИПРАВЛЕННЯ v15: Тільки 2 червоні кульки ---
            // Комірки (1,0) та (1,3) - (u=0.375, v=0.125) та (u=0.375, v=0.875)
            const redCoords = [
                { u: cellCenter + 0.25, v: cellCenter },            // (1,0) - Верхній край
                { u: cellCenter + 0.25, v: 1.0 - cellCenter }       // (1,3) - Нижній край
            ];

            for (const uv of blueCoords) {
                const mesh = new THREE.Mesh(markerGeo, vertexMatBlue); 
                mesh.userData = { uv: uv };
                kMapMarkers.push(mesh);
                kMapGroup.add(mesh);
            }
            for (const uv of redCoords) {
                const mesh = new THREE.Mesh(markerGeo, vertexMatRed); 
                mesh.userData = { uv: uv };
                kMapMarkers.push(mesh);
                kMapGroup.add(mesh);
            }
        }
        // --- Кінець блоку Карно ---



        // --- Універсальна функція знаходження точки ---
        function getCurrentSurfacePoint(u_norm, v_norm, progress, target) {
            const u = mod(u_norm, 1.0);
            const v = mod(v_norm, 1.0);

            if (progress < t_TorusToCyl_End) {
                torusCutFunc(u, v, target);
            } else if (progress < t_Cyl_Start) {
                cylinderFunc(u, v, target);
            } else if (progress < t_CylToRect_End) {
                cylinderCutFunc(u, v, target);
            } else {
                // Прямокутник
                const x = THREE.MathUtils.lerp(-finalHeight / 2, finalHeight / 2, u);
                const z = THREE.MathUtils.lerp(-finalWidth / 2, finalWidth / 2, v);
                target.set(x, 0, z);
            }
        }

        // --- ВИПРАВЛЕННЯ v15: ЄДИНА КОРЕКТНА функція оновлення ребер ---
        function updateLineGroup(edgeGroup, progress, start_uv, end_uv, useShortestPath) {
            const u_seam_is_open = current_gap_u > 0.001;
            const v_seam_is_open = current_gap_v > 0.001;
            const linePool = edgeGroup.userData.linePool;

            let du = end_uv.u_norm - start_uv.u_norm;
            let dv = end_uv.v_norm - start_uv.v_norm;
            
            if (useShortestPath) {
                if (du > 0.5) du -= 1.0; else if (du < -0.5) du += 1.0;
                if (dv > 0.5) dv -= 1.0; else if (dv < -0.5) dv += 1.0;
            }

            let u_prev = start_uv.u_norm;
            let v_prev = start_uv.v_norm;
            let linePoolIndex = 0;
            let currentLine = linePool[linePoolIndex];
            currentLine.visible = true;
            let currentPos = currentLine.geometry.attributes.position;
            let pointIndex = 0;
            
            getCurrentSurfacePoint(u_prev, v_prev, progress, tempVec);
            currentPos.setXYZ(pointIndex++, tempVec.x, tempVec.y, tempVec.z);

            for (let i = 1; i <= EDGE_SEGMENTS; i++) {
                const t = i / EDGE_SEGMENTS;
                const u_curr = start_uv.u_norm + du * t;
                const v_curr = start_uv.v_norm + dv * t;
                
                // --- НОВА ЛОГІКА РОЗРИВУ ---
                const u_boundary_crossed = Math.floor(u_curr) !== Math.floor(u_prev);
                const v_boundary_crossed = Math.floor(v_curr) !== Math.floor(v_prev);
                u_prev = u_curr; // Оновлюємо *до* перевірки
                v_prev = v_curr;

                let split = false;
                if (u_boundary_crossed && u_seam_is_open) split = true;
                if (v_boundary_crossed && v_seam_is_open) split = true;

                getCurrentSurfacePoint(u_curr, v_curr, progress, tempVec); // Завжди отримуємо точку

                if (split) {
                    // 1. Завершуємо поточну лінію (невидимими точками)
                    currentPos.needsUpdate = true;
                    for (let k = pointIndex; k <= EDGE_SEGMENTS; k++) currentPos.setXYZ(k, tempVec.x, tempVec.y, tempVec.z);

                    // 2. Беремо нову лінію
                    linePoolIndex++;
                    if (linePoolIndex >= linePool.length) break; 
                    currentLine = linePool[linePoolIndex];
                    currentLine.visible = true;
                    currentPos = currentLine.geometry.attributes.position;
                    pointIndex = 0;

                    // 3. Додаємо поточну точку як *першу* в нову лінію
                    currentPos.setXYZ(pointIndex++, tempVec.x, tempVec.y, tempVec.z);

                } else {
                    // 4. Додаємо точку до поточної лінії
                    if (pointIndex <= EDGE_SEGMENTS) {
                         currentPos.setXYZ(pointIndex++, tempVec.x, tempVec.y, tempVec.z);
                    }
                }
                // ---
            }
            // Завершуємо останню активну лінію
            currentPos.needsUpdate = true;
            for (let k = pointIndex; k <= EDGE_SEGMENTS; k++) currentPos.setXYZ(k, tempVec.x, tempVec.y, tempVec.z);
            // Ховаємо невикористані
            for (let i = linePoolIndex + 1; i < linePool.length; i++) linePool[i].visible = false;
        }


        // --- Оновлення K3,3 ---
        function updateK33Graph(progress) {
            if (!k33GraphGroup || !k33GraphGroup.visible) return;
            // Оновлюємо вершини
            for (let i = 0; i < k33Vertices.length; i++) {
                const uv = k33UVCoords[i];
                getCurrentSurfacePoint(uv.u_norm, uv.v_norm, progress, k33Vertices[i].position);
            }
            // Оновлюємо ребра
            for (let j = 0; j < k33Edges.length; j++) {
                const edgeGroup = k33Edges[j];
                const indices = edgeGroup.userData.edgeIndices;
                const start_uv = k33UVCoords[indices[0]];
                const end_uv = k33UVCoords[indices[1]];
                // K3,3 ВИКОРИСТОВУЄ "найкоротший шлях"
                updateLineGroup(edgeGroup, progress, start_uv, end_uv, true);
            }
        }
        
        // --- Оновлення Карти Карно ---
        function updateKarnaughMap(progress) {
            if (!kMapGroup || !kMapGroup.visible) return;
            
            // 1. Оновлюємо лінії сітки
            for (let j = 0; j < kMapLines.length; j++) {
                const edgeGroup = kMapLines[j];
                // Сітка Карно НЕ використовує "найкоротший шлях"
                updateLineGroup(edgeGroup, progress, edgeGroup.userData.start_uv, edgeGroup.userData.end_uv, false);
            }
            
            // 2. Оновлюємо маркери (кульки)
            for (const marker of kMapMarkers) {
                const { u, v } = marker.userData.uv;
                getCurrentSurfacePoint(u, v, progress, marker.position);
            }
        }
        
        // --- Параметричні функції (без змін) ---
        function torusCutFunc(u_norm, v_norm, target) {
            const u = THREE.MathUtils.lerp(u_start, u_end, u_norm);
            const v = THREE.MathUtils.lerp(-Math.PI, Math.PI, v_norm);
            target.x = (current_R + r0 * Math.cos(v)) * Math.cos(u);
            target.y = (current_R + r0) + (current_R + r0 * Math.cos(v)) * Math.sin(u);
            target.z = r0 * Math.sin(v);
        }
        function cylinderFunc(u_norm, v_norm, target) {
            const h = THREE.MathUtils.lerp(-finalHeight / 2, finalHeight / 2, u_norm);
            const v_angle = THREE.MathUtils.lerp(-Math.PI, Math.PI, v_norm);
            target.x = h;
            target.y = r0 - r0 * Math.cos(v_angle);
            target.z = r0 * Math.sin(v_angle);
        }
        function cylinderCutFunc(u_norm, v_norm, target) {
            const h = THREE.MathUtils.lerp(-finalHeight / 2, finalHeight / 2, u_norm);
            current_r = (Math.PI * r0) / (Math.PI - current_gap_v);
            const v_angle = THREE.MathUtils.lerp(-(Math.PI - current_gap_v), (Math.PI - current_gap_v), v_norm);
            target.x = h;
            target.y = current_r - current_r * Math.cos(v_angle);
            target.z = current_r * Math.sin(v_angle);
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // --- ЛОГІКА АНІМАЦІЇ ---
        function updateAnimation(progress) {
            torusMesh.visible = false;
            cylinderMesh.visible = false;
            rectMesh.visible = false;
            current_gap_u = 0.0;
            current_gap_v = 0.0;
            let geom;
            const segmentsU = 80; 
            const segmentsV = 40; 

            if (progress < t_TorusToCyl_End) {
                torusMesh.visible = true;
                const p1 = progress / t_TorusToCyl_End; 
                current_gap_u = THREE.MathUtils.lerp(0, Math.PI - minTheta, p1);
                current_R = (Math.PI * R0) / (Math.PI - current_gap_u);
                u_start = (3 * Math.PI / 2) - (Math.PI - current_gap_u); 
                u_end = (3 * Math.PI / 2) + (Math.PI - current_gap_u);   
                geom = new ParametricGeometry(torusCutFunc, segmentsU, segmentsV);
                torusMesh.geometry.dispose();
                torusMesh.geometry = geom;
            } else if (progress < t_Cyl_Start) {
                cylinderMesh.visible = true;
                current_gap_u = Math.PI - minTheta;
                if (!cylinderMesh.geometry.attributes.position || manualControl) {
                     geom = new ParametricGeometry(cylinderFunc, segmentsU, segmentsV);
                     cylinderMesh.geometry.dispose();
                     cylinderMesh.geometry = geom;
                }
            } else if (progress < t_CylToRect_End) {
                cylinderMesh.visible = true;
                current_gap_u = Math.PI - minTheta;
                const p2 = (progress - t_Cyl_Start) / (t_CylToRect_End - t_Cyl_Start);
                current_gap_v = THREE.MathUtils.lerp(0, Math.PI - minTheta, p2);
                geom = new ParametricGeometry(cylinderCutFunc, segmentsU, segmentsV);
                cylinderMesh.geometry.dispose();
                cylinderMesh.geometry = geom;
            } else {
                rectMesh.visible = true;
                current_gap_u = Math.PI - minTheta;
                current_gap_v = Math.PI - minTheta;
            }

            // --- Оновлюємо потрібний шар ---
            if (currentOverlay === 'k33') {
                updateK33Graph(progress);
            } else if (currentOverlay === 'karnaugh') {
                updateKarnaughMap(progress);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!manualControl && isPlaying) {
                const timeSinceResume = clock.getElapsedTime() - animStartTime;
                const progress = (lastProgress + (timeSinceResume / loopDuration)) % 1.0;
                updateAnimation(progress);
                slider.value = progress * 1000; 
            }
            controls.update();
            renderer.render(scene, camera);
        }

        // Запуск
        init();
        animate();
    </script>
</body>
</html>