<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sets</title>
    
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

    <style>
        :root {
            --bg: #0f0f12; 
            --panel: #1b1b25;
            --text: #e0e0e0;
            --accent-a: #ff0055; 
            --accent-b: #00f2ff; 
            --accent-c: #39ff14; 
            --border: rgba(255, 255, 255, 0.1);
            --success: #00ff9d;
            --danger: #ff2e63;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding-bottom: 40px;
            user-select: none; /* Prevents text selection when clicking fast */
        }

        h1 {
            font-weight: 300;
            letter-spacing: 3px;
            text-transform: uppercase;
            text-shadow: 0 0 15px rgba(0, 242, 255, 0.5);
            margin: 25px 0;
            font-size: 2rem;
        }

        .main-container {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
            width: 95%;
            max-width: 1100px;
        }

        /* Canvas Area */
        .universe-frame {
            position: relative;
            background: #111;
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 0 40px rgba(0,0,0,0.6);
        }
        
        .universe-label {
            position: absolute;
            top: 10px;
            right: 15px;
            font-family: serif;
            font-style: italic;
            font-size: 1.5rem;
            color: #444;
            pointer-events: none;
        }

        canvas {
            display: block;
            cursor: pointer;
        }

        /* Controls Area */
        .controls-card {
            flex: 1;
            min-width: 320px;
            max-width: 450px;
            background: var(--panel);
            padding: 30px;
            border-radius: 16px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .mode-switch {
            display: flex;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 5px;
            margin-bottom: 20px;
        }

        .mode-btn {
            flex: 1;
            padding: 10px;
            border: none;
            background: transparent;
            color: var(--text);
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            font-weight: bold;
        }

        .mode-btn.active {
            background: var(--accent-b);
            color: var(--bg);
            box-shadow: 0 0 15px var(--accent-b);
        }

        .formula-box {
            background: rgba(0,0,0,0.4);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 15px;
            min-height: 70px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .formula-tex {
            font-size: 1.5rem;
            color: var(--accent-b);
        }

        .formula-desc {
            font-size: 0.85rem;
            color: #888;
            margin-top: 5px;
            font-style: italic;
        }

      /  .btn {
            padding: 15px 30px;
            font-size: 1.1rem;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(45deg, var(--accent-a), #ff4d88);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 0, 85, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 0, 85, 0.6);
        }

        .feedback {
            height: 25px;
            text-align: center;
            font-weight: bold;
        }

        /* Legend dots */
        .legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 5px;
            font-size: 0.85rem;
            color: #888;
        }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 5px; }

    </style>
</head>
<body>

    <h1>–û–ø–µ—Ä–∞—Ü—ñ—ó –Ω–∞–∂ –º–Ω–æ–∂–∏–Ω–∞–º–∏</h1>

    <div class="main-container">
        
        <div class="universe-frame">
            <div class="universe-label">$U$</div>
            <canvas id="vennCanvas" width="500" height="420"></canvas>
        </div>

        <div class="controls-card">
            <div class="mode-switch">
                <button class="mode-btn active" onclick="setMode('sandbox')">–ü—ñ—Å–æ—á–Ω–∏—Ü—è</button>
                <button class="mode-btn" onclick="setMode('challenge')">–ß–µ–ª–µ–Ω–¥–∂</button>
            </div>

            <div id="sandbox-controls">
                <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h3 style="margin:0; color: white;">–©–æ –≤–∏–±—Ä–∞–Ω–æ?</h3>
                    <button class="btn-outline" style="padding: 4px 12px; font-size: 0.75rem; border-radius: 4px;" onclick="clearSelection()">–°–∫–∏–Ω—É—Ç–∏</button>
                </div>
                
                <div class="formula-box" id="sandbox-status">
                    <div class="formula-tex">$\varnothing$</div>
                    <div class="formula-desc">–ü–æ—Ä–æ–∂–Ω—è –º–Ω–æ–∂–∏–Ω–∞</div>
                </div>
                
                <div class="legend">
                    <div><span class="dot" style="background:var(--accent-a)"></span>A</div>
                    <div><span class="dot" style="background:var(--accent-b)"></span>B</div>
                    <div><span class="dot" style="background:var(--accent-c)"></span>C</div>
                    <div><span class="dot" style="border:1px solid #666"></span>U</div>
                </div>
                <p style="text-align:center; color:#555; font-size:0.8rem; margin-top:15px;">
                    –ü—ñ–¥–∫–∞–∑–∫–∞: –ö–ª—ñ–∫–∞–π –ø–æ —Ü–µ–Ω—Ç—Ä—É, —â–æ–± –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ç–æ—á–Ω—ñ—Å—Ç—å.
                </p>
            </div>

            <div id="challenge-controls" style="display: none;">
                <h3 style="margin:0">–ó–∞–≤–¥–∞–Ω–Ω—è:</h3>
                <p style="font-size: 0.9rem; color: #aaa;">–ù–∞–±–µ—Ä–∏ –Ω–∞ –¥—ñ–∞–≥—Ä–∞–º—ñ:</p>
                
                <div class="formula-box" style="border-color: var(--accent-b);">
                    <div class="formula-tex" id="target-formula">?</div>
                </div>
                
                <div class="feedback" id="feedback-msg"></div>
                
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button class="btn btn-primary" onclick="checkAnswer()" style="flex: 2;">–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏</button>
                    <button class="btn btn-outline" onclick="generateTask()" style="flex: 1;">–ü—Ä–æ–ø—É—Å–∫</button>
                </div>
                <div style="margin-top: 15px; text-align: center; color: #666;">
                    –†–∞—Ö—É–Ω–æ–∫: <span id="score" style="color: white; font-weight: bold; font-size:1.2rem;">0</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. CONFIG & GEOMETRY ---
        const canvas = document.getElementById('vennCanvas');
        const ctx = canvas.getContext('2d');
        
        // –í–∏–ø—Ä–∞–≤–ª–µ–Ω–∞ –≥–µ–æ–º–µ—Ç—Ä—ñ—è: –±—ñ–ª—å—à—ñ –∫–æ–ª–∞, –±–ª–∏–∂—á–µ –æ–¥–∏–Ω –¥–æ –æ–¥–Ω–æ–≥–æ
        const r = 100; // –ë—É–ª–æ 85, —Å—Ç–∞–ª–æ 100 (–±—ñ–ª—å—à–µ –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è)
        
        const centers = {
            A: { x: 250, y: 150 }, // –¢—Ä–æ—Ö–∏ –æ–ø—É—Å—Ç–∏–≤
            B: { x: 170, y: 270 }, // –ó—Å—É–Ω—É–≤ –≤–ø—Ä–∞–≤–æ —ñ –≤–≤–µ—Ä—Ö
            C: { x: 330, y: 270 }  // –ó—Å—É–Ω—É–≤ –≤–ª—ñ–≤–æ —ñ –≤–≤–µ—Ä—Ö
        };
        // –¢–µ–ø–µ—Ä —Ü–µ–Ω—Ç—Ä —Ç—Ä–∏–∫—É—Ç–Ω–∏–∫–∞ "–∂–∏—Ä–Ω–∏–π"

        const colors = {
            A: "rgba(255, 0, 85, 1)",
            B: "rgba(0, 242, 255, 1)",
            C: "rgba(57, 255, 20, 1)",
            U: "rgba(255, 255, 255, 0.1)"
        };

        let activeRegions = new Set(); 
        let currentMode = 'sandbox';
        let currentTaskTarget = []; 
        let score = 0;

        // --- 2. MATH ENGINE (BITMASKS) ---
        // Region IDs:
        // 0 = Universe
        // 1=A, 2=B, 4=C (Binary flags)
        // Example: 3 = 1+2 = A & B

        function getRegionIndex(x, y) {
            const inA = Math.hypot(x - centers.A.x, y - centers.A.y) < r;
            const inB = Math.hypot(x - centers.B.x, y - centers.B.y) < r;
            const inC = Math.hypot(x - centers.C.x, y - centers.C.y) < r;

            let idx = 0;
            if (inA) idx |= 1; 
            if (inB) idx |= 2; 
            if (inC) idx |= 4; 
            
            return idx;
        }

        // Pre-generate region paths logic
        function pathCircle(ctx, key) {
            ctx.beginPath();
            ctx.arc(centers[key].x, centers[key].y, r, 0, Math.PI * 2);
            ctx.closePath();
        }

        function getRegionShape(idx) {
            const osc = document.createElement('canvas');
            osc.width = canvas.width;
            osc.height = canvas.height;
            const octx = osc.getContext('2d');

            if (idx === 0) {
                octx.fillStyle = '#ffffff';
                octx.fillRect(0, 0, osc.width, osc.height);
                octx.globalCompositeOperation = 'destination-out';
                pathCircle(octx, 'A'); octx.fill();
                pathCircle(octx, 'B'); octx.fill();
                pathCircle(octx, 'C'); octx.fill();
                return osc;
            }

            const hasA = (idx & 1) !== 0;
            const hasB = (idx & 2) !== 0;
            const hasC = (idx & 4) !== 0;

            octx.globalCompositeOperation = 'source-over';
            octx.fillStyle = '#ffffff';
            let first = true;

            if (hasA) { pathCircle(octx, 'A'); octx.fill(); first = false; }
            
            if (hasB) {
                pathCircle(octx, 'B');
                if (first) { octx.fill(); first = false; } 
                else { octx.globalCompositeOperation = 'source-in'; octx.fill(); }
            }
            
            if (hasC) {
                pathCircle(octx, 'C');
                if (first) { octx.fill(); } 
                else { octx.globalCompositeOperation = 'source-in'; octx.fill(); }
            }

            octx.globalCompositeOperation = 'destination-out';
            if (!hasA) { pathCircle(octx, 'A'); octx.fill(); }
            if (!hasB) { pathCircle(octx, 'B'); octx.fill(); }
            if (!hasC) { pathCircle(octx, 'C'); octx.fill(); }

            return osc;
        }

        // --- 3. RENDERER ---
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Selection Glows
            ctx.globalCompositeOperation = 'screen';
            activeRegions.forEach(idx => {
                const shape = getRegionShape(idx);
                if (idx === 0) {
                    ctx.shadowColor = 'rgba(100, 150, 255, 0.4)';
                    ctx.shadowBlur = 0;
                    ctx.drawImage(shape, 0, 0);
                    ctx.fillStyle = 'rgba(50, 50, 80, 0.3)'; 
                    ctx.fillRect(0,0,canvas.width, canvas.height); // Tint U
                } else {
                    ctx.shadowColor = 'white';
                    ctx.shadowBlur = 20;
                    ctx.drawImage(shape, 0, 0);
                    ctx.drawImage(shape, 0, 0); 
                }
            });

            // Draw Outlines
            ctx.globalCompositeOperation = 'source-over';
            ctx.shadowBlur = 0;
            ctx.lineWidth = 2;

            const drawOutline = (key, color) => {
                ctx.strokeStyle = color;
                ctx.fillStyle = color.replace('1)', '0.05)'); 
                pathCircle(ctx, key);
                ctx.fill();
                ctx.stroke();
                // –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —à—Ä–∏—Ñ—Ç—É
                ctx.font = "900 24px Arial"; // –¢—Ä–æ—Ö–∏ –∂–∏—Ä–Ω—ñ—à–µ —ñ –±—ñ–ª—å—à–µ
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                let lx = centers[key].x, ly = centers[key].y;
                
                // –ö–æ—Ä–∏–≥—É–≤–∞–Ω–Ω—è –ø–æ–∑–∏—Ü—ñ—ó (—Ç—Ä–æ—Ö–∏ –ø—ñ–¥—Å—É–Ω—É–≤, —â–æ–± –±—É–ª–æ –≥–∞—Ä–Ω—ñ—à–µ)
                if(key === 'A') ly -= r - 35;
                if(key === 'B') { lx -= r - 35; ly += r/2; }
                if(key === 'C') { lx += r - 35; ly += r/2; }

                // 1. –ú–∞–ª—é—î–º–æ —Ç–æ–≤—Å—Ç—É —á–æ—Ä–Ω—É –æ–±–≤–æ–¥–∫—É (–∫–æ–Ω—Ç—É—Ä)
                ctx.lineWidth = 5;
                ctx.strokeStyle = "rgba(0,0,0,0.8)"; 
                ctx.strokeText(key, lx, ly);

                // 2. –ú–∞–ª—é—î–º–æ —Å–∞–º—É –±—É–∫–≤—É –±—ñ–ª–∏–º –∫–æ–ª—å–æ—Ä–æ–º –∑–≤–µ—Ä—Ö—É
                ctx.fillStyle = "white";
                ctx.fillText(key, lx, ly);
            };

            drawOutline('A', colors.A);
            drawOutline('B', colors.B);
            drawOutline('C', colors.C);
        }

        // --- 4. INTERACTION ---
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const idx = getRegionIndex(x, y);
            
            if (activeRegions.has(idx)) {
                activeRegions.delete(idx);
            } else {
                activeRegions.add(idx);
            }
            
            render();
            updateFormulaText();
        });

        function clearSelection() {
            activeRegions.clear();
            render();
            updateFormulaText();
        }

        // --- 5. LOGIC DICTIONARY (UPDATED) ---
        
        function getSelectionKey() {
            return Array.from(activeRegions).sort((a,b) => a-b).join(',');
        }

// --- 5. LOGIC ENGINE (Quine-McCluskey Lite) ---

        function getActiveMinterms() {
            // –ü–µ—Ä–µ—Ç–≤–æ—Ä—é—î–º–æ Set activeRegions —É –º–∞—Å–∏–≤ –±—ñ–Ω–∞—Ä–Ω–∏—Ö —Ä—è–¥–∫—ñ–≤
            // 0 -> "000", 1 -> "001" (A), 2 -> "010" (B), 4 -> "100" (C)
            // –£–≤–∞–≥–∞: —É –≤–∞—à—ñ–π –ª–æ–≥—ñ—Ü—ñ 1=A, 2=B, 4=C. 
            // –¢–æ–±—Ç–æ –±—ñ—Ç–∏: C B A.
            
            let minterms = [];
            activeRegions.forEach(idx => {
                // idx - —Ü–µ —á–∏—Å–ª–æ –≤—ñ–¥ 0 –¥–æ 7. 
                // –ü–µ—Ä–µ—Ç–≤–æ—Ä–∏–º–æ –≤ —Ä—è–¥–æ–∫ "CBA" –¥–ª—è –∑—Ä—É—á–Ω–æ—Å—Ç—ñ –æ–±—Ä–æ–±–∫–∏
                let bin = "";
                bin += (idx & 4) ? "1" : "0"; // C
                bin += (idx & 2) ? "1" : "0"; // B
                bin += (idx & 1) ? "1" : "0"; // A
                minterms.push(bin);
            });
            return minterms.sort();
        }

        function simplifyBooleanLogic(minterms) {
            if (minterms.length === 0) return { tex: "\\varnothing", desc: "–ü–æ—Ä–æ–∂–Ω—è –º–Ω–æ–∂–∏–Ω–∞" };
            if (minterms.length === 8) return { tex: "U", desc: "–£–Ω—ñ–≤–µ—Ä—Å—É–º" };

            // –ê–ª–≥–æ—Ä–∏—Ç–º —Å–∫–ª–µ—é–≤–∞–Ω–Ω—è (—Å–ø—Ä–æ—â–µ–Ω–∏–π QM)
            let terms = [...minterms];
            let merged = [];
            
            // –¶–∏–∫–ª —Å–ø—Ä–æ—â–µ–Ω–Ω—è: –Ω–∞–º–∞–≥–∞—î–º–æ—Å—è —Å–∫–ª–µ—ó—Ç–∏ "001" —ñ "011" –≤ "0-1"
            // –ü–æ–≤—Ç–æ—Ä—é—î–º–æ, –ø–æ–∫–∏ —î —â–æ —Å–∫–ª–µ—é–≤–∞—Ç–∏
            let somethingChanged = true;
            
            while (somethingChanged) {
                somethingChanged = false;
                let nextIterTerms = new Set();
                let usedIndices = new Set();
                
                for (let i = 0; i < terms.length; i++) {
                    for (let j = i + 1; j < terms.length; j++) {
                        let diff = 0;
                        let diffIdx = -1;
                        
                        // –ü–æ—Ä—ñ–≤–Ω—é—î–º–æ —Å–∏–º–≤–æ–ª–∏
                        for (let k = 0; k < 3; k++) {
                            if (terms[i][k] !== terms[j][k]) {
                                diff++;
                                diffIdx = k;
                            }
                        }
                        
                        // –Ø–∫—â–æ –≤—ñ–¥—Ä—ñ–∑–Ω—è—é—Ç—å—Å—è —Ä—ñ–≤–Ω–æ –æ–¥–Ω–∏–º –±—ñ—Ç–æ–º - —Å–∫–ª–µ—é—î–º–æ
                        if (diff === 1) {
                            let newTerm = terms[i].substring(0, diffIdx) + "-" + terms[i].substring(diffIdx + 1);
                            nextIterTerms.add(newTerm);
                            usedIndices.add(i);
                            usedIndices.add(j);
                            somethingChanged = true;
                        }
                    }
                }
                
                // –¢—ñ, —â–æ –Ω–µ —Å–∫–ª–µ—ó–ª–∏—Å—è –Ω—ñ –∑ –∫–∏–º, –ø–µ—Ä–µ–Ω–æ—Å–∏–º–æ –≤ —Ñ—ñ–Ω–∞–ª (—Ü–µ –ø—Ä–æ—Å—Ç—ñ —ñ–º–ø–ª—ñ–∫–∞–Ω—Ç–∏)
                for (let i = 0; i < terms.length; i++) {
                    if (!usedIndices.has(i)) {
                        merged.push(terms[i]);
                    }
                }
                
                terms = Array.from(nextIterTerms);
            }
            
            // –î–æ–¥–∞—î–º–æ —Ç–µ, —â–æ –∑–∞–ª–∏—à–∏–ª–æ—Å—è –ø—ñ—Å–ª—è –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ –ø—Ä–æ—Ö–æ–¥—É
            merged = [...merged, ...terms];
            
            // –í–∏–¥–∞–ª—è—î–º–æ –¥—É–±–ª—ñ–∫–∞—Ç–∏
            merged = [...new Set(merged)];

            return formatToLatex(merged);
        }

        function formatToLatex(implicants) {
            // Implicant structure: "CBA" –¥–µ '1' - —î, '0' - –Ω—ñ (—à—Ç—Ä–∏—Ö), '-' - –Ω–µ–≤–∞–∂–ª–∏–≤–æ
            // –ü—Ä–∏–∫–ª–∞–¥: "1-0" –æ–∑–Ω–∞—á–∞—î C AND (NOT A) -> C \ A
            
            let parts = implicants.map(term => {
                // term[0] = C, term[1] = B, term[2] = A
                let positive = [];
                let negative = [];
                
                if (term[2] === '1') positive.push("A");
                if (term[2] === '0') negative.push("A");
                
                if (term[1] === '1') positive.push("B");
                if (term[1] === '0') negative.push("B");
                
                if (term[0] === '1') positive.push("C");
                if (term[0] === '0') negative.push("C");

                // –§–æ—Ä–º—É–≤–∞–Ω–Ω—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ –∑–∞–ø–∏—Å—É
                if (positive.length === 0 && negative.length === 0) return "U"; 
                
                // –í–∞—Ä—ñ–∞–Ω—Ç 1: –¢—ñ–ª—å–∫–∏ –ø–æ–∑–∏—Ç–∏–≤–Ω—ñ (A \cap B)
                if (negative.length === 0) return positive.join(" \\cap ");
                
                // –í–∞—Ä—ñ–∞–Ω—Ç 2: –ó–º—ñ—à–∞–Ω—ñ (—Ä—ñ–∑–Ω–∏—Ü—è) -> (A \cap B) \setminus C
                if (positive.length > 0) {
                    let posPart = positive.length > 1 ? `(${positive.join(" \\cap ")})` : positive[0];
                    let negPart = negative.length > 1 ? `(${negative.join(" \\cup ")})` : negative[0];
                    // –Ø–∫—â–æ —Ä—ñ–∑–Ω–∏—Ü—è —Å–∫–ª–∞–¥–Ω—ñ—à–∞, –º–æ–∂–Ω–∞ –ø—Ä–æ—Å—Ç–æ –ø–∏—Å–∞—Ç–∏ –ø–µ—Ä–µ—Ç–∏–Ω –∑ –¥–æ–ø–æ–≤–Ω–µ–Ω–Ω—è–º,
                    // –∞–ª–µ –¥–ª—è –∫—Ä–∞—Å–∏ —Å–ø—Ä–æ–±—É—î–º–æ setminus
                    return `${posPart} \\setminus ${negPart}`;
                }
                
                // –í–∞—Ä—ñ–∞–Ω—Ç 3: –¢—ñ–ª—å–∫–∏ –Ω–µ–≥–∞—Ç–∏–≤–Ω—ñ (–ó–∞–∫–æ–Ω–∏ –¥–µ –ú–æ—Ä–≥–∞–Ω–∞) -> (A \cup B)'
                return `(${negative.join(" \\cup ")})'`;
            });

            // –ó'—î–¥–Ω—É—î–º–æ —á–∞—Å—Ç–∏–Ω–∏ —á–µ—Ä–µ–∑ –æ–±'—î–¥–Ω–∞–Ω–Ω—è
            let tex = parts.join(" \\cup ");
            
            // –û–ø–∏—Å (—Å–ø—Ä–æ—â–µ–Ω–∏–π)
            let desc = "–õ–æ–≥—ñ—á–Ω–∞ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—è (–∞–≤—Ç–æ)";
            if (parts.length === 1) desc = "–ü—Ä–æ—Å—Ç–∞ –≥—Ä—É–ø–∞";
            if (parts.length > 2) desc = "–°–∫–ª–∞–¥–Ω–µ –æ–±'—î–¥–Ω–∞–Ω–Ω—è";
            
            return { tex: tex, desc: desc };
        }

function updateFormulaText() {
            if (currentMode !== 'sandbox') return;

            const texEl = document.querySelector('#sandbox-status .formula-tex');
            const descEl = document.querySelector('#sandbox-status .formula-desc');
            
            // 1. –û—Ç—Ä–∏–º—É—î–º–æ –∫–ª—é—á (–≤—ñ–¥—Å–æ—Ä—Ç–æ–≤–∞–Ω—ñ ID —Ä–µ–≥—ñ–æ–Ω—ñ–≤)
            // 0=U, 1=A, 2=B, 4=C, 3=AB, 5=AC, 6=BC, 7=ABC
            const selectionKey = Array.from(activeRegions).sort((a,b) => a - b).join(',');

            // 2. –°–ª–æ–≤–Ω–∏–∫ "–õ—é–¥—Å—å–∫–∏—Ö" –Ω–∞–∑–≤ –¥–ª—è –ø–æ—à–∏—Ä–µ–Ω–∏—Ö –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π
            const commonPatterns = {
                // --- –ü–æ—Ä–æ–∂–Ω—è —ñ –í—Å–µ ---
                "": { tex: "\\varnothing", desc: "–ü–æ—Ä–æ–∂–Ω—è –º–Ω–æ–∂–∏–Ω–∞" },
                "0,1,2,3,4,5,6,7": { tex: "U", desc: "–£–Ω—ñ–≤–µ—Ä—Å—É–º (–í—Å–µ)" },

                // --- –û–¥–∏–Ω–∞—Ä–Ω—ñ –∫–æ–ª–∞ ---
                "1,3,5,7": { tex: "A", desc: "–ú–Ω–æ–∂–∏–Ω–∞ A" },
                "2,3,6,7": { tex: "B", desc: "–ú–Ω–æ–∂–∏–Ω–∞ B" },
                "4,5,6,7": { tex: "C", desc: "–ú–Ω–æ–∂–∏–Ω–∞ C" },

                // --- –î–æ–ø–æ–≤–Ω–µ–Ω–Ω—è (–ù–µ –ê...) ---
                "0,2,4,6": { tex: "A'", desc: "–î–æ–ø–æ–≤–Ω–µ–Ω–Ω—è A (–ù–µ A)" },
                "0,1,4,5": { tex: "B'", desc: "–î–æ–ø–æ–≤–Ω–µ–Ω–Ω—è B (–ù–µ B)" },
                "0,1,2,3": { tex: "C'", desc: "–î–æ–ø–æ–≤–Ω–µ–Ω–Ω—è C (–ù–µ C)" },

                // --- –û–±'—î–¥–Ω–∞–Ω–Ω—è (U) ---
                "1,2,3,5,6,7": { tex: "A \\cup B", desc: "A –∞–±–æ B" },
                "1,3,4,5,6,7": { tex: "A \\cup C", desc: "A –∞–±–æ C" },
                "2,3,4,5,6,7": { tex: "B \\cup C", desc: "B –∞–±–æ C" },
                "1,2,3,4,5,6,7": { tex: "A \\cup B \\cup C", desc: "–û–±'—î–¥–Ω–∞–Ω–Ω—è —Ç—Ä—å–æ—Ö" },

                // --- –ü–µ—Ä–µ—Ç–∏–Ω–∏ (‚à©) ---
                "3,7": { tex: "A \\cap B", desc: "A —ñ B —Ä–∞–∑–æ–º" },
                "5,7": { tex: "A \\cap C", desc: "A —ñ C —Ä–∞–∑–æ–º" },
                "6,7": { tex: "B \\cap C", desc: "B —ñ C —Ä–∞–∑–æ–º" },
                "7":   { tex: "A \\cap B \\cap C", desc: "–°–ø—ñ–ª—å–Ω–µ –¥–ª—è –≤—Å—ñ—Ö —Ç—Ä—å–æ—Ö" },

                // --- –†—ñ–∑–Ω–∏—Ü—ñ (\) ---
                "1,5": { tex: "A \\setminus B", desc: "A –±–µ–∑ B" },
                "1,3": { tex: "A \\setminus C", desc: "A –±–µ–∑ C" },
                "2,6": { tex: "B \\setminus A", desc: "B –±–µ–∑ A" },
                "2,3": { tex: "B \\setminus C", desc: "B –±–µ–∑ C" },
                "4,5": { tex: "C \\setminus B", desc: "C –±–µ–∑ B" },
                "4,6": { tex: "C \\setminus A", desc: "C –±–µ–∑ A" },

                // --- –°–∏–º–µ—Ç—Ä–∏—á–Ω—ñ —Ä—ñ–∑–Ω–∏—Ü—ñ (Œî) ---
                "1,2,5,6": { tex: "A \\Delta B", desc: "A –∞–±–æ B, –∞–ª–µ –Ω–µ –æ–±–∏–¥–≤–∞" },
                "1,3,4,6": { tex: "A \\Delta C", desc: "A –∞–±–æ C, –∞–ª–µ –Ω–µ –æ–±–∏–¥–≤–∞" },
                "2,3,4,5": { tex: "B \\Delta C", desc: "B –∞–±–æ C, –∞–ª–µ –Ω–µ –æ–±–∏–¥–≤–∞" },

                // --- –°–ø–µ—Ü–∏—Ñ—ñ—á–Ω—ñ ---
                "3": { tex: "(A \\cap B) \\setminus C", desc: "–¢—ñ–ª—å–∫–∏ A —ñ B (–±–µ–∑ C)" },
                "5": { tex: "(A \\cap C) \\setminus B", desc: "–¢—ñ–ª—å–∫–∏ A —ñ C (–±–µ–∑ B)" },
                "6": { tex: "(B \\cap C) \\setminus A", desc: "–¢—ñ–ª—å–∫–∏ B —ñ C (–±–µ–∑ A)" },
                "1": { tex: "A \\setminus (B \\cup C)", desc: "–¢—ñ–ª—å–∫–∏ A (—á–∏—Å—Ç–∞)" },
                "2": { tex: "B \\setminus (A \\cup C)", desc: "–¢—ñ–ª—å–∫–∏ B (—á–∏—Å—Ç–∞)" },
                "4": { tex: "C \\setminus (A \\cup B)", desc: "–¢—ñ–ª—å–∫–∏ C (—á–∏—Å—Ç–∞)" },
				"1,2,3,4,5,6": { 
                    tex: "(A \\cup B \\cup C) \\setminus (A \\cap B \\cap C)", 
                    desc: "–û–±'—î–¥–Ω–∞–Ω–Ω—è –±–µ–∑ –ø–æ—Ç—Ä—ñ–π–Ω–æ–≥–æ –ø–µ—Ä–µ—Ç–∏–Ω—É" 
                },
				
				// –ë–æ–Ω—É—Å: –ü–æ–≤–Ω–∞ —Å–∏–º–µ—Ç—Ä–∏—á–Ω–∞ —Ä—ñ–∑–Ω–∏—Ü—è (—Ç—Ä–∏ –ø–µ–ª—é—Å—Ç–∫–∏ + —Ü–µ–Ω—Ç—Ä)
                "1,2,4,7": {
                    tex: "A \\Delta B \\Delta C",
                    desc: "–ù–µ–ø–∞—Ä–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –≤—Ö–æ–¥–∂–µ–Ω—å (XOR 3-—Ö)"
                },
                
                // --- –ó–∞–∫–æ–Ω–∏ –¥–µ –ú–æ—Ä–≥–∞–Ω–∞ (–∑–æ–≤–Ω—ñ—à–Ω—ñ) ---
                "0": { tex: "(A \\cup B \\cup C)'", desc: "–ñ–æ–¥–Ω–∞ –∑ –º–Ω–æ–∂–∏–Ω" },
                "0,4,5,6": { tex: "(A \\cup B)'", desc: "–ù—ñ A, –Ω—ñ B" },
                "0,2,3,6": { tex: "(A \\cup C)'", desc: "–ù—ñ A, –Ω—ñ C" },
                "0,1,3,5": { tex: "(B \\cup C)'", desc: "–ù—ñ B, –Ω—ñ C" }
            };

            let result;

            if (commonPatterns[selectionKey]) {
                // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –≥–æ—Ç–æ–≤–∏–π —à–∞–±–ª–æ–Ω
                result = commonPatterns[selectionKey];
            } else {
                // –Ø–∫—â–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ ‚Äî –∑–∞–ø—É—Å–∫–∞—î–º–æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä (—Ç–æ–π, —â–æ —è –¥–∞–≤–∞–≤ —Ä–∞–Ω—ñ—à–µ)
                const minterms = getActiveMinterms();
                result = simplifyBooleanLogic(minterms);
            }

            texEl.innerHTML = `$ ${result.tex} $`;
            descEl.innerText = result.desc;
            texEl.style.color = commonPatterns[selectionKey] ? "var(--success)" : "var(--accent-b)";
            
            MathJax.typesetPromise([texEl]);
        }

        // –†–æ–∑—à–∏—Ä–µ–Ω–∞ –±–∞–∑–∞ –∑–Ω–∞–Ω—å
    /*    const formulas = {
            "": { tex: "\\varnothing", desc: "–ù—ñ—á–æ–≥–æ –Ω–µ –≤–∏–±—Ä–∞–Ω–æ" },
            "0,1,2,3,4,5,6,7": { tex: "U", desc: "–£–Ω—ñ–≤–µ—Ä—Å—É–º (–í—Å–µ)" },

            // –ü–æ–æ–¥–∏–Ω–æ–∫—ñ (–í–ò–ü–†–ê–í–õ–ï–ù–û)
            "1": { tex: "A \\setminus (B \\cup C)", desc: "–¢—ñ–ª—å–∫–∏ A (–±–µ–∑ —ñ–Ω—à–∏—Ö)" },
            "2": { tex: "B \\setminus (A \\cup C)", desc: "–¢—ñ–ª—å–∫–∏ B (–±–µ–∑ —ñ–Ω—à–∏—Ö)" },
            "4": { tex: "C \\setminus (A \\cup B)", desc: "–¢—ñ–ª—å–∫–∏ C (–±–µ–∑ —ñ–Ω—à–∏—Ö)" },

            // –ü—Ä–æ—Å—Ç—ñ –º–Ω–æ–∂–∏–Ω–∏
            "1,3,5,7": { tex: "A", desc: "–ú–Ω–æ–∂–∏–Ω–∞ A" },
            "2,3,6,7": { tex: "B", desc: "–ú–Ω–æ–∂–∏–Ω–∞ B" },
            "4,5,6,7": { tex: "C", desc: "–ú–Ω–æ–∂–∏–Ω–∞ C" },

            // –û–±'—î–¥–Ω–∞–Ω–Ω—è
            "1,2,3,5,6,7": { tex: "A \\cup B", desc: "A –∞–±–æ B" },
            "1,3,4,5,6,7": { tex: "A \\cup C", desc: "A –∞–±–æ C" },
            "2,3,4,5,6,7": { tex: "B \\cup C", desc: "B –∞–±–æ C" },
            "1,2,3,4,5,6,7": { tex: "A \\cup B \\cup C", desc: "–û–±'—î–¥–Ω–∞–Ω–Ω—è —Ç—Ä—å–æ—Ö" },

            // –ü–µ—Ä–µ—Ç–∏–Ω–∏
            "3,7": { tex: "A \\cap B", desc: "–°–ø—ñ–ª—å–Ω–µ –¥–ª—è A —ñ B" },
            "5,7": { tex: "A \\cap C", desc: "–°–ø—ñ–ª—å–Ω–µ –¥–ª—è A —ñ C" },
            "6,7": { tex: "B \\cap C", desc: "–°–ø—ñ–ª—å–Ω–µ –¥–ª—è B —ñ C" },
            "7":   { tex: "A \\cap B \\cap C", desc: "–¶–µ–Ω—Ç—Ä (–°–ø—ñ–ª—å–Ω–µ –¥–ª—è –≤—Å—ñ—Ö)" },

            // –†—ñ–∑–Ω–∏—Ü—ñ (–ü—Ä–æ—Å—Ç—ñ)
            "1,5": { tex: "A \\setminus B", desc: "A –º—ñ–Ω—É—Å B" },
            "1,3": { tex: "A \\setminus C", desc: "A –º—ñ–Ω—É—Å C" },
            "2,6": { tex: "B \\setminus A", desc: "B –º—ñ–Ω—É—Å A" },
            "2,3": { tex: "B \\setminus C", desc: "B –º—ñ–Ω—É—Å C" },
            "4,5": { tex: "C \\setminus B", desc: "C –º—ñ–Ω—É—Å B" },
            "4,6": { tex: "C \\setminus A", desc: "C –º—ñ–Ω—É—Å A" },

            // –°–∏–º–µ—Ç—Ä–∏—á–Ω—ñ —Ä—ñ–∑–Ω–∏—Ü—ñ (–í–ò–ü–†–ê–í–õ–ï–ù–û - –¥–æ–¥–∞–Ω–æ 4 –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏)
            // A delta B = (A-B) U (B-A) = {1,5} U {2,6} = 1,2,5,6
            "1,2,5,6": { tex: "A \\Delta B", desc: "–°–∏–º–µ—Ç—Ä–∏—á–Ω–∞ —Ä—ñ–∑–Ω–∏—Ü—è A —ñ B" },
            "1,3,4,6": { tex: "A \\Delta C", desc: "–°–∏–º–µ—Ç—Ä–∏—á–Ω–∞ —Ä—ñ–∑–Ω–∏—Ü—è A —ñ C" },
            "2,3,4,5": { tex: "B \\Delta C", desc: "–°–∏–º–µ—Ç—Ä–∏—á–Ω–∞ —Ä—ñ–∑–Ω–∏—Ü—è B —ñ C" },

            // –°–ø–µ—Ü–∏—Ñ—ñ—á–Ω—ñ "–¢—ñ–ª—å–∫–∏ –ø–µ—Ä–µ—Ç–∏–Ω–∏" (–±–µ–∑ —Ç—Ä–µ—Ç—å–æ–≥–æ)
            "3": { tex: "(A \\cap B) \\setminus C", desc: "–¢—ñ–ª—å–∫–∏ A —ñ B" },
            "5": { tex: "(A \\cap C) \\setminus B", desc: "–¢—ñ–ª—å–∫–∏ A —ñ C" },
            "6": { tex: "(B \\cap C) \\setminus A", desc: "–¢—ñ–ª—å–∫–∏ B —ñ C" },
            
            // "–†—ñ–≤–Ω–æ –¥–≤–∞"
            "3,5,6": { tex: "(A \\cap B) \\cup (A \\cap C) \\cup (B \\cap C) \\setminus ABC", desc: "–ï–ª–µ–º–µ–Ω—Ç–∏, —â–æ –Ω–∞–ª–µ–∂–∞—Ç—å —Ä—ñ–≤–Ω–æ –¥–≤–æ–º –º–Ω–æ–∂–∏–Ω–∞–º" },

            // –î–æ–ø–æ–≤–Ω–µ–Ω–Ω—è
            "0": { tex: "(A \\cup B \\cup C)'", desc: "–ù—ñ—á–æ–≥–æ –∑ –º–Ω–æ–∂–∏–Ω (–∑–æ–≤–Ω—ñ—à–Ω—ñ–π —Ñ–æ–Ω)" },
            "0,2,4,6": { tex: "A'", desc: "–ù–µ A" },
            
            // –ö–æ–º–±—ñ–Ω–æ–≤–∞–Ω—ñ —Ä—ñ–∑–Ω–∏—Ü—ñ (—è–∫ –≤–∏ –ø—Ä–æ—Å–∏–ª–∏)
            "1,4,5": { tex: "(A \\cup C) \\setminus B", desc: "A —ñ C –±–µ–∑ B" },
            "1,2,3": { tex: "(A \\cup B) \\setminus C", desc: "A —ñ B –±–µ–∑ C" },
            "2,4,6": { tex: "(B \\cup C) \\setminus A", desc: "B —ñ C –±–µ–∑ A" }
        };

        function updateFormulaText() {
            if (currentMode !== 'sandbox') return;

            const texEl = document.querySelector('#sandbox-status .formula-tex');
            const descEl = document.querySelector('#sandbox-status .formula-desc');
            const key = getSelectionKey();

            if (formulas[key]) {
                texEl.innerHTML = `$ ${formulas[key].tex} $`;
                descEl.innerText = formulas[key].desc;
                texEl.style.color = "var(--accent-b)";
            } else {
                // Fallback for unknown
                if (activeRegions.size === 0) {
                    texEl.innerHTML = `$\\varnothing$`;
                    descEl.innerText = "";
                } else {
                    texEl.innerHTML = `?`;
                    descEl.innerText = "–¶–µ —è–∫–∞—Å—å —Å–∫–ª–∞–¥–Ω–∞ –∫–æ–º–±—ñ–∞—Ü—ñ—è. –®—Ç—É—á–Ω–∏–π —ñ–Ω—Ç–µ–ª–µ–∫—Ç –Ω–µ –º–æ–∂–µ –∑ —Ü–∏–º –≤–ø–æ—Ä–∞—Ç–∏—Å—è. –ú–æ–∂–µ —Å–ø—Ä–æ–±—É—î—Ç–µ —Å–≤—ñ–π –ø—Ä–∏—Ä–æ–¥–Ω–∏?üòâ –í–∏–≤–µ–¥—ñ—Ç—å —Ñ–æ—Ä–º—É–ª—É —Å–∞–º—ñ! (–ù–∞—Å–ø—Ä–∞–≤–¥—ñ, –¥–ª—è —Ç—Ä—å–æ—Ö –º–Ω–æ–∂–∏–Ω, —â–æ –ø–µ—Ä–µ—Ç–∏–Ω–∞—é—Ç—å—Å—è, —ñ—Å–Ω—É—î 2^(2^3)=256 –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π. –Ü —Ü–µ –Ω–µ –≤—Ä–∞—Ö–æ–≤—É—é—á–∏ —Ç–æ—Ç–æ–∂–Ω—å–æ —Ä—ñ–≤–Ω–∏—Ö –µ–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç—ñ–≤. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, B'\\A' –µ–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω–æ A\\B";
                    texEl.style.color = "#777";
                }
            }
            MathJax.typesetPromise([texEl]);
        }
*/
        // --- 6. CHALLENGE GENERATOR ---

        // List of tasks using keys that DEFINITELY exist in our map
        const tasks = [
            { key: "1,2,3,5,6,7", tex: "A \\cup B" },
            { key: "3,7", tex: "A \\cap B" },
            { key: "1,2,5,6", tex: "A \\Delta B" }, // Symmetric Diff Test
            { key: "1", tex: "A \\setminus (B \\cup C)" }, // Only A Test
            { key: "7", tex: "A \\cap B \\cap C" },
            { key: "1,4,5", tex: "(A \\cup C) \\setminus B" },
            { key: "0", tex: "(A \\cup B \\cup C)'" }, // Universe test
            { key: "3,5,6", tex: "\\text{–†—ñ–≤–Ω–æ –¥–≤—ñ –º–Ω–æ–∂–∏–Ω–∏}" }, // Logical description
            { key: "1,5", tex: "A \\setminus B" }
        ];

        function generateTask() {
            const t = tasks[Math.floor(Math.random() * tasks.length)];
            currentTaskTarget = t.key.split(',').map(Number).sort((a,b)=>a-b);
            
            // Reset UI
            activeRegions.clear();
            render();
            document.getElementById('feedback-msg').innerText = "";
            document.getElementById('score').style.color = "white";
            
            const el = document.getElementById('target-formula');
            el.innerHTML = `$ ${t.tex} $`;
            MathJax.typesetPromise([el]);
        }

        function checkAnswer() {
            const userKey = getSelectionKey();
            const targetKey = currentTaskTarget.join(',');
            const fb = document.getElementById('feedback-msg');
            const scoreEl = document.getElementById('score');

            if (userKey === targetKey) {
                fb.innerText = "–í–Ü–†–ù–û! üî•";
                fb.style.color = "var(--success)";
                score += 100;
                scoreEl.innerText = score;
                scoreEl.style.color = "var(--success)";
                
                document.querySelector('.universe-frame').style.borderColor = "var(--success)";
                setTimeout(() => {
                    document.querySelector('.universe-frame').style.borderColor = "#333";
                    generateTask();
                }, 1000);
            } else {
                fb.innerText = "–ü–æ–º–∏–ª–∫–∞ ‚ùå";
                fb.style.color = "var(--danger)";
            }
        }

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');

            if (mode === 'sandbox') {
                document.getElementById('sandbox-controls').style.display = 'block';
                document.getElementById('challenge-controls').style.display = 'none';
                clearSelection();
            } else {
                document.getElementById('sandbox-controls').style.display = 'none';
                document.getElementById('challenge-controls').style.display = 'block';
                generateTask();
            }
        }

        // Init
        render();

    </script>
</body>
</html>