<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–í–∏–¥–∏ –ë—ñ–Ω–∞—Ä–Ω–∏—Ö –í—ñ–¥–Ω–æ—à–µ–Ω—å</title>
    
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']], // –î–æ–∑–≤–æ–ª—è—î–º–æ $...$ –¥–ª—è —ñ–Ω–ª–∞–π–Ω —Ñ–æ—Ä–º—É–ª
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>

    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            --primary: #3498db;
            --success: #27ae60;
            --warning: #f39c12;
            --danger: #c0392b;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --bg: #f8f9fa;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
        }

        h1 { margin-bottom: 5px; color: var(--dark); }
        .subtitle { color: #7f8c8d; margin-bottom: 25px; font-size: 1rem; }

        /* Layout */
        .main-layout {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            max-width: 1200px;
            width: 100%;
            align-items: flex-start;
        }

        .panel {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Matrix */
        .matrix-grid {
            display: grid;
            grid-template-columns: 40px repeat(3, 50px);
            grid-template-rows: 40px repeat(3, 50px);
            gap: 5px;
            margin-bottom: 10px;
        }

        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            user-select: none;
            height: 50px;
        }

        .header-cell {
            font-weight: bold;
            color: var(--primary);
            cursor: default;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .matrix-cell {
            background-color: var(--light);
            border: 2px solid #bdc3c7;
            color: #bdc3c7;
        }

        .matrix-cell.active {
            background-color: var(--primary);
            border-color: var(--primary);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.4);
        }
        
        .matrix-cell.diagonal {
            border-style: dashed;
            border-color: #95a5a6;
        }

        /* Graph Container */
        #network-container {
            width: 500px;
            height: 300px;
            border: 1px solid #ddd;
            border-radius: 12px;
            background: white;
        }

        /* Properties */
        .props-container {
            width: 300px;
        }

        .prop-item {
            padding: 8px 12px;
            margin-bottom: 6px;
            border-radius: 6px;
            background: #f0f3f4;
            color: #95a5a6;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .prop-item.active {
            background: #e8f8f5;
            color: var(--dark);
            font-weight: 600;
            border-left: 5px solid var(--success);
        }

        .result-badge {
            margin-top: 15px;
            padding: 12px;
            background: var(--dark);
            color: white;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            box-sizing: border-box;
        }
        .result-badge.found {
            background: linear-gradient(135deg, #8e44ad, #c0392b);
        }

        /* Buttons */
        .presets {
            margin-top: 15px;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 6px 12px;
            font-size: 0.8rem;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            transition: 0.2s;
        }
        button:hover { background: #ecf0f1; border-color: var(--dark); }

        /* Theory Section */
        .theory-section {
            max-width: 1000px;
            width: 100%;
            margin-top: 40px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.03);
        }

        details { width: 100%; }
        
        summary {
            padding: 15px 25px;
            background: #f8f9fa;
            cursor: pointer;
            font-weight: bold;
            color: var(--dark);
            font-size: 1.1rem;
            border-bottom: 1px solid #eee;
            outline: none;
        }
        
        .theory-content {
            padding: 25px;
            line-height: 1.7;
            font-size: 1rem;
        }

        table.theory-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 0.95rem;
        }
        
        table.theory-table th {
            background: #eef2f3;
            text-align: left;
            padding: 12px;
            border-bottom: 2px solid #bdc3c7;
            width: 20%;
        }
        
        table.theory-table td {
            padding: 12px;
            border-bottom: 1px solid #eee;
            vertical-align: top;
        }
        
        /* Fix font size inside MathJax */
        mjx-container { font-size: 105% !important; }
    </style>
</head>
<body>

    <h2>–ë—ñ–Ω–∞—Ä–Ω—ñ –≤—ñ–¥–Ω–æ—à–µ–Ω–Ω–∫—è</h2>
    <div class="subtitle">–ü–æ–±—É–¥—É–π –≥—Ä–∞—Ñ —ñ –¥–æ—Å–ª—ñ–¥–∏ –π–æ–≥–æ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ</div>

    <div class="main-layout">
        <div class="panel">
            <h3>–ú–∞—Ç—Ä–∏—Ü—è –°—É–º—ñ–∂–Ω–æ—Å—Ç—ñ</h3>
            <div class="matrix-grid" id="matrix-container"></div>
            <div style="font-size:0.8rem; color:#999;">–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –Ω–∞ –∫–æ–º—ñ—Ä–∫—É (0/1)</div>
        </div>

        <div class="panel">
            <h3>–ì—Ä–∞—Ñ –í—ñ–¥–Ω–æ—à–µ–Ω–Ω—è</h3>
            <div id="network-container"></div>
        </div>

        <div class="panel props-container">
            <h3>–í–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ</h3>
            <div id="props-list">
                <div class="prop-item" id="p-refl"><span>–†–µ—Ñ–ª–µ–∫—Å–∏–≤–Ω–µ</span><span class="icon"></span></div>
                <div class="prop-item" id="p-irrefl"><span>–ê–Ω—Ç–∏—Ä–µ—Ñ–ª–µ–∫—Å–∏–≤–Ω–µ</span><span class="icon"></span></div>
                <div class="prop-item" id="p-sym"><span>–°–∏–º–µ—Ç—Ä–∏—á–Ω–µ</span><span class="icon"></span></div>
                <div class="prop-item" id="p-antisym"><span>–ê–Ω—Ç–∏—Å–∏–º–µ—Ç—Ä–∏—á–Ω–µ</span><span class="icon"></span></div>
                <div class="prop-item" id="p-asym"><span>–ê—Å–∏–º–µ—Ç—Ä–∏—á–Ω–µ</span><span class="icon"></span></div>
                <div class="prop-item" id="p-trans"><span>–¢—Ä–∞–Ω–∑–∏—Ç–∏–≤–Ω–µ</span><span class="icon"></span></div>
                <div class="prop-item" id="p-compl"><span>–ü–æ–≤–Ω–µ (–ó–≤'—è–∑–Ω–µ)</span><span class="icon"></span></div>
            </div>

            <div id="result-type" class="result-badge">–ó–≤–∏—á–∞–π–Ω–µ –≤—ñ–¥–Ω–æ—à–µ–Ω–Ω—è</div>

            <div class="presets">
                <button onclick="setPreset('empty')">–û—á–∏—Å—Ç–∏—Ç–∏</button>
                <button onclick="setPreset('equiv')">–ï–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω—ñ—Å—Ç—å</button>
                <button onclick="setPreset('partial')">–ß–∞—Å—Ç–∫. –ø–æ—Ä—è–¥–æ–∫</button>
                <button onclick="setPreset('strict')">–°—Ç—Ä–æ–≥. –ø–æ—Ä—è–¥–æ–∫</button>
                <button onclick="setPreset('linear')">–õ—ñ–Ω. –ø–æ—Ä—è–¥–æ–∫</button>
            </div>
        </div>
    </div>

    <div class="theory-section">
        <details>
            <summary>üìñ –î–æ–≤—ñ–¥–Ω–∏–∫ –∑ —Ç–µ–æ—Ä—ñ—ó (–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è —Ç–∞ –§–æ—Ä–º—É–ª–∏)</summary>
            <div class="theory-content">
                <p>–ù–µ—Ö–∞–π $A$ ‚Äî –º–Ω–æ–∂–∏–Ω–∞, –∞ $R$ ‚Äî –±—ñ–Ω–∞—Ä–Ω–µ –≤—ñ–¥–Ω–æ—à–µ–Ω–Ω—è –Ω–∞ –Ω—ñ–π ($R \subseteq A \times A$). –ó–∞–ø–∏—Å $(x, y) \in R$ –æ–∑–Ω–∞—á–∞—î –Ω–∞—è–≤–Ω—ñ—Å—Ç—å –¥—É–≥–∏ $x \to y$.</p>
                
                <table class="theory-table">
                    <thead>
                        <tr>
                            <th>–í–ª–∞—Å—Ç–∏–≤—ñ—Å—Ç—å</th>
                            <th>–§–æ—Ä–º–∞–ª—å–Ω–µ –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è</th>
                            <th>–ü—Ä–∏–∫–ª–∞–¥–∏</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>–†–µ—Ñ–ª–µ–∫—Å–∏–≤–Ω–µ</strong></td>
                            <td>$$ \forall x \in A: (x, x) \in R $$</td>
                            <td>¬´$=$¬ª, ¬´$\le$¬ª, ¬´–¥—ñ–ª–∏—Ç—å—Å—è –Ω–∞¬ª<br><em>(–ö–æ–∂–µ–Ω –µ–ª–µ–º–µ–Ω—Ç –º–∞—î –ø–µ—Ç–ª—é)</em></td>
                        </tr>
                        <tr>
                            <td><strong>–ê–Ω—Ç–∏—Ä–µ—Ñ–ª–µ–∫—Å–∏–≤–Ω–µ</strong></td>
                            <td>$$ \forall x \in A: (x, x) \notin R $$</td>
                            <td>¬´$<$¬ª, ¬´–±—É—Ç–∏ –±–∞—Ç—å–∫–æ–º¬ª<br><em>(–ñ–æ–¥–Ω–∏—Ö –ø–µ—Ç–µ–ª—å)</em></td>
                        </tr>
                        <tr>
                            <td><strong>–°–∏–º–µ—Ç—Ä–∏—á–Ω–µ</strong></td>
                            <td>$$ \forall x,y: (x,y) \in R \Rightarrow (y,x) \in R $$</td>
                            <td>¬´$=$¬ª, ¬´—Ä–æ–¥–∏—á¬ª, ¬´$\neq$¬ª</td>
                        </tr>
                        <tr>
                            <td><strong>–ê–Ω—Ç–∏—Å–∏–º–µ—Ç—Ä–∏—á–Ω–µ</strong></td>
                            <td>$$ (x,y) \in R \land (y,x) \in R \Rightarrow x = y $$</td>
                            <td>¬´$\le$¬ª, ¬´$\subseteq$¬ª<br><em>(–ù–µ–º–∞—î —Å—Ç—Ä—ñ–ª–æ–∫ —Ç—É–¥–∏-–Ω–∞–∑–∞–¥ –º—ñ–∂ —Ä—ñ–∑–Ω–∏–º–∏ —Ç–æ—á–∫–∞–º–∏)</em></td>
                        </tr>
                        <tr>
                            <td><strong>–¢—Ä–∞–Ω–∑–∏—Ç–∏–≤–Ω–µ</strong></td>
                            <td>$$ (x,y) \in R \land (y,z) \in R \Rightarrow (x,z) \in R $$</td>
                            <td>¬´$<$¬ª, ¬´–±—É—Ç–∏ –ø—Ä–µ–¥–∫–æ–º¬ª<br><em>(–ü—Ä–∏–Ω—Ü–∏–ø: –¥—Ä—É–≥ –º–æ–≥–æ –¥—Ä—É–≥–∞ ‚Äî –º—ñ–π –¥—Ä—É–≥)</em></td>
                        </tr>
                         <tr>
                            <td><strong>–ü–æ–≤–Ω–µ</strong></td>
                            <td>$$ \forall x,y: (x,y) \in R \lor (y,x) \in R $$</td>
                            <td>¬´$\le$¬ª (—É—Å—ñ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—ñ)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>–ö–ª—é—á–æ–≤—ñ —Ç–∏–ø–∏ –≤—ñ–¥–Ω–æ—à–µ–Ω—å</h3>
                <ul>
                    <li><strong>–ï–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω—ñ—Å—Ç—å ($\equiv$):</strong> –†–µ—Ñ–ª–µ–∫—Å–∏–≤–Ω–µ + –°–∏–º–µ—Ç—Ä–∏—á–Ω–µ + –¢—Ä–∞–Ω–∑–∏—Ç–∏–≤–Ω–µ. <br><em>–ü—Ä–∏–∫–ª–∞–¥:</em> $a \equiv b \pmod n$.</li>
                    <li><strong>–ß–∞—Å—Ç–∫–æ–≤–∏–π –ø–æ—Ä—è–¥–æ–∫ ($\preceq$):</strong> –†–µ—Ñ–ª–µ–∫—Å–∏–≤–Ω–µ + –ê–Ω—Ç–∏—Å–∏–º–µ—Ç—Ä–∏—á–Ω–µ + –¢—Ä–∞–Ω–∑–∏—Ç–∏–≤–Ω–µ. <br><em>–ü—Ä–∏–∫–ª–∞–¥:</em> $\subseteq$ (–ø—ñ–¥–º–Ω–æ–∂–∏–Ω–∏).</li>
                    <li><strong>–°—Ç—Ä–æ–≥–∏–π –ø–æ—Ä—è–¥–æ–∫ ($<$):</strong> –ê–Ω—Ç–∏—Ä–µ—Ñ–ª–µ–∫—Å–∏–≤–Ω–µ + –ê–Ω—Ç–∏—Å–∏–º–µ—Ç—Ä–∏—á–Ω–µ + –¢—Ä–∞–Ω–∑–∏—Ç–∏–≤–Ω–µ.</li>
                    <li><strong>–õ—ñ–Ω—ñ–π–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫ ($\le$):</strong> –ß–∞—Å—Ç–∫–æ–≤–∏–π –ø–æ—Ä—è–¥–æ–∫ + –ü–æ–≤–Ω–æ—Ç–∞.</li>
                </ul>
            </div>
        </details>
    </div>

    <script>
        // --- CONFIG ---
        const nodes = ['a', 'b', 'c'];
        let matrix = [[0,0,0], [0,0,0], [0,0,0]];

        // --- VIS.JS ---
        let network = null;
        let edgesDataSet = new vis.DataSet([]);
        const nodesDataSet = new vis.DataSet([
            { id: 0, label: 'a', x: 0, y: 0, fixed: true, color:{background:'#3498db', border:'white'}, font:{color:'white', size:24} },
            { id: 1, label: 'b', x: 150, y: 0, fixed: true, color:{background:'#3498db', border:'white'}, font:{color:'white', size:24} },
            { id: 2, label: 'c', x: 300, y: 0, fixed: true, color:{background:'#3498db', border:'white'}, font:{color:'white', size:24} }
        ]);

        function initNetwork() {
            const container = document.getElementById('network-container');
            const data = { nodes: nodesDataSet, edges: edgesDataSet };
            const options = {
                edges: {
                    arrows: { to: { enabled: true, scaleFactor: 1 } },
                    smooth: {
                        enabled: true,
                        type: 'curvedCW',
                        roundness: 0.2
                    },
                    color: { color: '#2c3e50', highlight: '#e74c3c' },
                    width: 2
                },
                interaction: { dragNodes: false, zoomView: false },
                physics: { enabled: false }
            };
            network = new vis.Network(container, data, options);
        }

        // --- RENDER ---
        function renderMatrix() {
            const container = document.getElementById('matrix-container');
            container.innerHTML = '';

            // Header
            container.appendChild(createDiv('header-cell', ''));
            nodes.forEach(n => container.appendChild(createDiv('header-cell', n)));

            // Rows
            for (let i = 0; i < 3; i++) {
                container.appendChild(createDiv('header-cell', nodes[i]));
                for (let j = 0; j < 3; j++) {
                    const div = document.createElement('div');
                    let cls = `cell matrix-cell ${matrix[i][j] ? 'active' : ''}`;
                    if (i === j) cls += ' diagonal';
                    div.className = cls;
                    div.innerText = matrix[i][j];
                    div.onclick = () => toggleEdge(i, j);
                    container.appendChild(div);
                }
            }
        }

        function createDiv(cls, content) {
            const d = document.createElement('div');
            d.className = cls;
            d.innerText = content;
            return d;
        }

        function updateGraph() {
            const newEdges = [];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (matrix[i][j] === 1) {
                        if (i === j) {
                            // Loops setup
                            newEdges.push({ 
                                from: i, to: j, 
                                selfReferenceSize: 25, 
                                selfReference: { angle: Math.PI * 1.5 } // Top loop
                            });
                        } else {
                            newEdges.push({ from: i, to: j });
                        }
                    }
                }
            }
            edgesDataSet.clear();
            edgesDataSet.add(newEdges);
        }

        // --- LOGIC ---
        function toggleEdge(from, to) {
            matrix[from][to] = matrix[from][to] === 1 ? 0 : 1;
            updateAll();
        }

        function updateAll() {
            renderMatrix();
            updateGraph();
            analyze();
        }

        function analyze() {
            const m = matrix;
            const N = 3;

            // Properties checks
            const isReflexive = m[0][0] && m[1][1] && m[2][2];
            const isIrreflexive = !m[0][0] && !m[1][1] && !m[2][2];

            let isSymmetric = true;
            for(let i=0; i<N; i++) for(let j=0; j<N; j++) 
                if(m[i][j] && !m[j][i]) isSymmetric = false;

            let isAsymmetric = true; 
            for(let i=0; i<N; i++) for(let j=0; j<N; j++) 
                if(m[i][j] && m[j][i]) isAsymmetric = false;

            let isAntisymmetric = true;
            for(let i=0; i<N; i++) for(let j=0; j<N; j++) 
                if(i !== j && m[i][j] && m[j][i]) isAntisymmetric = false;

            let isTransitive = true;
            for(let i=0; i<N; i++) for(let j=0; j<N; j++) for(let k=0; k<N; k++)
                if(m[i][j] && m[j][k] && !m[i][k]) isTransitive = false;

            let isComplete = true;
            for(let i=0; i<N; i++) for(let j=0; j<N; j++) 
                if (i !== j && !m[i][j] && !m[j][i]) isComplete = false;

            // UI Indicators
            setProp('p-refl', isReflexive);
            setProp('p-irrefl', isIrreflexive);
            setProp('p-sym', isSymmetric);
            setProp('p-antisym', isAntisymmetric);
            setProp('p-asym', isAsymmetric);
            setProp('p-trans', isTransitive);
            setProp('p-compl', isComplete);

            // Determine Type
            const badge = document.getElementById('result-type');
            let type = "–ó–≤–∏—á–∞–π–Ω–µ –≤—ñ–¥–Ω–æ—à–µ–Ω–Ω—è";
            let found = false;

            if (isReflexive && isSymmetric && isTransitive) {
                type = "–ï–ö–í–Ü–í–ê–õ–ï–ù–¢–ù–Ü–°–¢–¨ (‚â°)";
                found = true;
            } else if (isReflexive && isAntisymmetric && isTransitive) {
                if (isComplete) type = "–õ–Ü–ù–Ü–ô–ù–ò–ô –ü–û–†–Ø–î–û–ö (‚â§)";
                else type = "–ß–ê–°–¢–ö–û–í–ò–ô –ü–û–†–Ø–î–û–ö (‚äÜ)";
                found = true;
            } else if (isAsymmetric && isTransitive) {
                 if (isComplete) type = "–°–¢–†–û–ì–ò–ô –õ–Ü–ù–Ü–ô–ù–ò–ô –ü–û–†–Ø–î–û–ö (<)";
                 else type = "–°–¢–†–û–ì–ò–ô –ü–û–†–Ø–î–û–ö (<)";
                 found = true;
            }

            badge.innerText = type;
            if(found) badge.classList.add('found'); else badge.classList.remove('found');
            
            // Re-render math if needed (rarely needed dynamically here but good practice)
            if(window.MathJax) MathJax.typesetPromise();
        }

        function setProp(id, isActive) {
            const el = document.getElementById(id);
            const icon = el.querySelector('.icon');
            if(isActive) {
                el.classList.add('active');
                icon.innerText = '‚úî';
            } else {
                el.classList.remove('active');
                icon.innerText = '‚úï';
            }
        }

        // --- PRESETS ---
        function setPreset(type) {
            matrix = [[0,0,0],[0,0,0],[0,0,0]];
            
            if (type === 'equiv') {
                matrix = [[1,1,0], [1,1,0], [0,0,1]];
            } else if (type === 'partial') {
                matrix = [[1,1,1], [0,1,0], [0,0,1]];
            } else if (type === 'strict') {
                matrix = [[0,1,1], [0,0,1], [0,0,0]];
            } else if (type === 'linear') {
                matrix = [[1,1,1], [0,1,1], [0,0,1]];
            }
            updateAll();
        }

        initNetwork();
        renderMatrix();
        analyze();

    </script>
</body>
</html>
