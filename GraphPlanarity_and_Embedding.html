<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°–∏–º—É–ª—è—Ç–æ—Ä: –ü–ª–∞–Ω–∞—Ä–Ω—ñ—Å—Ç—å, 3-–∑–≤'—è–∑–Ω—ñ—Å—Ç—å —Ç–∞ –£–∫–ª–∞–¥–∞–Ω–Ω—è –¢—É—Ç—Ç–µ</title>
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    <style>
        :root {
            --primary-color: #3f51b5; /* Indigo */
            --primary-hover: #303f9f;
            --secondary-color: #17a2b8; /* Tutte Outer */
            --tertiary-color: #28a745; /* Tutte Inner */
            --planar-color: #4CAF50;    /* Green */
            --non-planar-color: #F44336; /* Red */
            --highlight-color: #ffc107; /* Amber */
            --highlight-secondary-color: #03a9f4; /* Light Blue */
            --flash-color: #e91e63; /* Pink */
            --removed-color: #bdbdbd;
            --light-bg: #f4f7f9;
            --white-bg: #ffffff;
            --border-color: #e0e0e0;
            --text-color: #333;
            --comment-color: #111;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 20px;
            background-color: var(--light-bg);
            color: var(--text-color);
            margin: 0;
            line-height: 1.6;
        }

        h1, h2 {
            color: var(--primary-color);
            text-align: center;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
        }

        /* --- –°—Ç–∏–ª—ñ –¥–ª—è –≤–∫–ª–∞–¥–æ–∫ --- */
        .stage-tabs {
            display: flex;
            background: #e0e0e0;
            border-radius: 8px;
            padding: 5px;
            width: 100%;
            max-width: 800px;
            box-sizing: border-box;
            justify-content: space-around;
        }
        .stage-tab {
            flex: 1;
            padding: 12px 15px;
            text-align: center;
            font-weight: 600;
            font-size: 1.1em;
            color: #777;
            background: #f0f0f0;
            border-radius: 6px;
            border: 2px solid transparent;
            cursor: not-allowed;
            transition: all 0.3s ease;
        }
        .stage-tab.active {
            background: var(--white-bg);
            color: var(--primary-color);
            border-color: var(--primary-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .stage-tab.enabled {
             color: #333;
             cursor: pointer;
        }
        .stage-tab.enabled:not(.active):hover {
            background: #d5d5d5;
        }
        .stage-tab.completed {
            color: var(--planar-color);
            border-color: var(--planar-color);
        }
        .stage-tab.failed {
            color: var(--non-planar-color);
            border-color: var(--non-planar-color);
        }

        /* --- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä–∏ –µ—Ç–∞–ø—ñ–≤ --- */
        .stage-container {
            width: 100%;
            background-color: var(--white-bg);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .controls-panel {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            font-weight: 500;
        }

        .control-group input[type="number"],
        .control-group input[type="range"] {
            width: 70px;
            padding: 5px 8px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }
        .control-group input[type="range"] { width: 100px; padding: 0; }

        button {
            padding: 10px 15px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        button:hover { background-color: var(--primary-hover); }
        button:disabled { background-color: #adb5bd; cursor: not-allowed; }
        button.success { background-color: var(--planar-color); }
        button.success:hover { background-color: #388E3C; }
        button.danger { background-color: var(--non-planar-color); }
        button.danger:hover { background-color: #D32F2F; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover { background-color: #5a6268; }

        #graph-svg-container {
            width: 100%;
            position: relative;
        }

        #graph-svg {
            width: 100%;
            min-height: 500px;
            display: block;
            background-color: #fdfdfd;
        }

        /* --- –°—Ç–∏–ª—ñ –¥–ª—è –≥—Ä–∞—Ñ–∞ (D3/SVG) --- */
        .edge {
            stroke: #999;
            stroke-width: 3;
            transition: stroke 0.3s, stroke-width 0.3s, opacity 0.3s;
        }
        .edge.highlight { stroke: var(--non-planar-color); stroke-width: 5; }
        .edge.highlight-new { stroke: var(--primary-color); stroke-width: 4; stroke-dasharray: 5 5; }
        .edge.edge-new.highlight { stroke: var(--non-planar-color); stroke-width: 5; stroke-dasharray: none; }
        .edge.removed { opacity: 0.5; }
        
        /* –°–ø–µ—Ü—ñ–∞–ª—å–Ω—ñ —Å—Ç–∏–ª—ñ –¥–ª—è –¢—É—Ç—Ç–µ */
        .edge.tutte-outer { stroke: var(--secondary-color); stroke-width: 4; }
        .edge.tutte-highlight { stroke: var(--non-planar-color); stroke-width: 4; }


        .node {
            cursor: move;
            transition: fill 0.3s, stroke 0.3s, opacity 0.3s;
        }
        .node-circle {
            stroke: var(--white-bg);
            stroke-width: 3;
            fill: var(--primary-color);
            r: 16; /* –ó–±—ñ–ª—å—à–µ–Ω–æ –¥–ª—è –Ω–æ–º–µ—Ä—ñ–≤ */
        }
        .node-label {
            font-size: 14px;
            font-weight: bold;
            fill: white;
            text-anchor: middle;
            dy: ".35em";
            pointer-events: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .node.highlight .node-circle { fill: var(--highlight-color); }
        .node.highlight .node-label { fill: #333; }
        .node.highlight-secondary .node-circle { fill: var(--highlight-secondary-color); }
        .node.highlight-secondary .node-label { fill: #333; }
        .node.flash .node-circle { fill: var(--flash-color); stroke: #333; }
		.node.selected .node-circle { fill: var(--flash-color); stroke: #333; }
        .node.removed .node-circle { fill: var(--removed-color); opacity: 0.8; }
        .node.removed .node-label { opacity: 0.4; }
        
        /* –°–ø–µ—Ü—ñ–∞–ª—å–Ω—ñ —Å—Ç–∏–ª—ñ –¥–ª—è –¢—É—Ç—Ç–µ */
        .node.tutte-outer .node-circle { fill: var(--secondary-color); r: 14; }
        .node.tutte-inner .node-circle { fill: var(--tertiary-color); }
        .node.tutte-highlight .node-circle { fill: var(--non-planar-color); r: 14; }
        .node.tutte-neighbor .node-circle { fill: var(--highlight-color); }
        .node.tutte-neighbor .node-label { fill: #333; }
        
        /* –ö–ª–∞—Å—Ç–µ—Ä–∏ –¥–ª—è –¢—É—Ç—Ç–µ */
        .tutte-cluster {
            stroke-width: 3;
            stroke: white;
            fill: var(--non-planar-color);
            opacity: 0.8;
        }
        .tutte-cluster-label {
            font-size: 16px;
            font-weight: bold;
            fill: white;
            text-anchor: middle;
            dy: ".35em";
            pointer-events: none;
        }
        
        /* –¶–µ–Ω—Ç—Ä–æ—ó–¥–∏ –¥–ª—è –¢—É—Ç—Ç–µ */
        .tutte-centroid {
            fill: var(--highlight-color);
            stroke: #333;
            stroke-width: 2px;
            opacity: 0.9;
            pointer-events: none;
        }
        .tutte-centroid-line {
            stroke: var(--highlight-color);
            stroke-width: 2;
            stroke-dasharray: 3 3;
            opacity: 0.9;
            pointer-events: none;
        }


        .simulation-footer {
            padding: 15px 20px;
            background-color: #fafafa;
            border-top: 1px solid var(--border-color);
        }
        
        #step-commentary, #connectivity-commentary, #tutte-commentary {
            min-height: 5em;
            font-size: 1.1em;
            line-height: 1.5;
            color: var(--comment-color);
            padding: 15px;
            border-radius: 6px;
            background: #eee;
            margin-bottom: 15px;
            text-align: center;
        }
        
        #step-commentary .result, #connectivity-commentary .result, #tutte-commentary .result {
            font-weight: bold;
            font-size: 1.2em;
        }
        .result.planar { color: var(--planar-color); }
        .result.non-planar { color: var(--non-planar-color); }

        .step-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .step-controls button { background-color: #6c757d; }
        .step-controls button:hover { background-color: #5a6268; }
        .step-controls button:disabled { background-color: #adb5bd; cursor: not-allowed; }
        
        #stage-transition-controls {
            padding: 20px;
            text-align: center;
        }
        
        .theory-spoiler {
            width: 100%;
            max-width: 1200px;
            background: var(--white-bg);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            margin-top: 20px;
        }
        .theory-spoiler summary {
            font-size: 1.2em;
            font-weight: 600;
            padding: 15px 20px;
            cursor: pointer;
            color: var(--primary-color);
        }
        .theory-spoiler div { padding: 0 20px 20px 20px; line-height: 1.6; }
        .theory-spoiler h4 { color: var(--text-color); border-bottom: 2px solid var(--primary-color); padding-bottom: 5px; margin-top: 20px; }

    </style>
</head>
<body>

    <h3>–ü–ª–∞–Ω–∞—Ä–Ω—ñ—Å—Ç—å, 3-–∑–≤'—è–∑–Ω—ñ—Å—Ç—å —Ç–∞ –£–∫–ª–∞–¥–∞–Ω–Ω—è –¢—É—Ç—Ç–µ</h3>

    <div class="main-container">

        <div class="stage-tabs">
            <div class="stage-tab active" id="tab-stage-1">–ï—Ç–∞–ø 1: –ü–ª–∞–Ω–∞—Ä–Ω—ñ—Å—Ç—å</div>
            <div class="stage-tab" id="tab-stage-2">–ï—Ç–∞–ø 2: 3-–ó–≤'—è–∑–Ω—ñ—Å—Ç—å</div>
            <div class="stage-tab" id="tab-stage-3">–ï—Ç–∞–ø 3: –£–∫–ª–∞–¥–∞–Ω–Ω—è –¢—É—Ç—Ç–µ</div>
        </div>

        <div class="stage-container" id="stage-1-planarity">
            <div class="controls-panel">
                <div class="control-group">
                    <label>–ü—Ä–∏–∫–ª–∞–¥–∏ –≥—Ä–∞—Ñ—ñ–≤:</label>
                    <button id="gen-planar-btn">–¢–µ—Å—Ç–æ–≤–∏–π –ì—Ä–∞—Ñ –ü–µ—Ç–µ—Ä—Å–æ–Ω–∞</button>
                    <button id="gen-planar-2cut-btn">–ü–ª–∞–Ω–∞—Ä–Ω–∏–π (2-–∑–≤'—è–∑–Ω–∏–π)</button>
                    <button id="gen-icosahedron-btn">–Ü–∫–æ—Å–∞—î–¥—Ä (-1)</button> <button id="gen-k5-btn">K5</button>
                    <button id="gen-k33-btn">K3,3</button>
                    <button id="gen-homeo-k5-btn">–ù–µ–ø–ª–∞–Ω–∞—Ä–Ω–∏–π (–ï–π–ª–µ—Ä O–ö)</button>
                    <button id="gen-random-btn">–í–∏–ø–∞–¥–∫–æ–≤–∏–π</button>
				
					<button id="toggle-physics-btn" class="secondary">üîå –í–∏–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É</button>

                </div>
                <div class="control-group">
                    <label for="node-count-input">–í–µ—Ä—à–∏–Ω–∏:</label>
                    <input type="number" id="node-count-input" value="10" min="4" max="12">
                </div>
                <div class="control-group">
                    <label for="edge-prob-input">–©—ñ–ª—å–Ω—ñ—Å—Ç—å:</label>
                    <input type="range" id="edge-prob-input" value="0.5" min="0.1" max="1.0" step="0.05">
					 <p>–†–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è (–ø—Ä–∏ –≤–∏–º–∫–Ω–µ–Ω—ñ–π "—Ñ—ñ–∑–∏—Ü—ñ"): –ü–æ–¥–≤—ñ–π–Ω–∏–π –∫–ª—ñ–∫ —Å—Ç–≤–æ—Ä—ñ—î –≤–µ—Ä—à–∏–Ω—É, –∫–ª—ñ–∫ –∑ ctrl –≤–∏–¥–∞–ª—è—î, –Ω–∞—Ç–∏—Å–∫–∞–Ω–Ω—è –∑ Shift –Ω–∞ 2 –≤–µ—Ä—à–∏–Ω–∏ —Å—Ç–≤–æ—Ä—é—î —Ä–µ–±—Ä–æ</p>
                </div>
				
            </div>
            
            <div class="simulation-footer">
                <div id="step-commentary">–ó–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ –≥—Ä–∞—Ñ –¥–ª—è –ø–æ—á–∞—Ç–∫—É —Å–∏–º—É–ª—è—Ü—ñ—ó...</div>
                <div class="step-controls">
                    <button id="prev-step-btn" disabled>‚óÑ –ü–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –∫—Ä–æ–∫</button>
                    <button id="next-step-btn" disabled>–ù–∞—Å—Ç—É–ø–Ω–∏–π –∫—Ä–æ–∫ ‚ñ∫</button>
                </div>
            </div>
        </div>

        <div class="stage-container" id="stage-2-connectivity" style="display: none;">
            <div class="controls-panel">
                <button id="start-connectivity-test-btn">–ü–æ—á–∞—Ç–∏ —Ç–µ—Å—Ç –Ω–∞ 3-–∑–≤'—è–∑–Ω—ñ—Å—Ç—å</button>
            </div>
            <div class="simulation-footer">
                <div id="connectivity-commentary">
                    –ì—Ä–∞—Ñ –ø–ª–∞–Ω–∞—Ä–Ω–∏–π. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É, —â–æ–± –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –π–æ–≥–æ –Ω–∞ 3-–∑–≤'—è–∑–Ω—ñ—Å—Ç—å.
                    <br>–¶–µ –Ω–µ–æ–±—Ö—ñ–¥–Ω–æ –¥–ª—è –∫–æ—Ä–µ–∫—Ç–Ω–æ–≥–æ —É–∫–ª–∞–¥–∞–Ω–Ω—è –∑–∞ —Ç–µ–æ—Ä–µ–º–æ—é –¢—É—Ç—Ç–µ.
                </div>
				
				
				
				
                <div class="step-controls" id="tutte-options" style="display: none; flex-direction: column; gap: 10px;">
                    </div>
            </div>
        </div>
        
        <div class="stage-container" id="stage-3-tutte" style="display: none;">
             <div class="controls-panel">
                <label>–ö–µ—Ä—É–≤–∞–Ω–Ω—è —É–∫–ª–∞–¥–∞–Ω–Ω—è–º:</label>
                <button id="tutte-toggle-physics-btn" class="secondary">üîå –£–≤—ñ–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É</button>
                <button id="tutte-prev-step-btn" disabled>‚óÑ –ö—Ä–æ–∫ –ù–∞–∑–∞–¥</button>
                <button id="tutte-next-step-btn" disabled>2. –ö—Ä–æ–∫ –í–ø–µ—Ä–µ–¥ ‚ñ∫</button>
                <button id="tutte-run-auto-btn" disabled>–ê–≤—Ç–æ (10 —ñ—Ç–µ—Ä–∞—Ü—ñ–π)</button>
             </div>
             <div class="simulation-footer">
                <div id="tutte-commentary">
                    –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —É–∫–ª–∞–¥–∞–Ω–Ω—è –¢—É—Ç—Ç–µ...
                </div>
             </div>
        </div>

        <div id="graph-svg-container">
            <svg id="graph-svg"></svg>
        </div>

        <details class="theory-spoiler" open>
            <summary>–¢–µ–æ—Ä—ñ—è: –ü–ª–∞–Ω–∞—Ä–Ω—ñ—Å—Ç—å, –ó–≤'—è–∑–Ω—ñ—Å—Ç—å —Ç–∞ –£–∫–ª–∞–¥–∞–Ω–Ω—è –¢—É—Ç—Ç–µ</summary>
            <div>
                <h4>–ï—Ç–∞–ø 1: –ö—Ä–∏—Ç–µ—Ä—ñ–π –ø–ª–∞–Ω–∞—Ä–Ω–æ—Å—Ç—ñ</h4>
                <p>–ì—Ä–∞—Ñ –Ω–∞–∑–∏–≤–∞—î—Ç—å—Å—è <strong>–ø–ª–∞–Ω–∞—Ä–Ω–∏–º</strong>, —è–∫—â–æ –π–æ–≥–æ –º–æ–∂–Ω–∞ –∑–æ–±—Ä–∞–∑–∏—Ç–∏ –Ω–∞ –ø–ª–æ—â–∏–Ω—ñ —Ç–∞–∫, —â–æ–± –π–æ–≥–æ —Ä–µ–±—Ä–∞ –ø–µ—Ä–µ—Ç–∏–Ω–∞–ª–∏—Å—è –ª–∏—à–µ —É –≤–µ—Ä—à–∏–Ω–∞—Ö.</p>
                <p><strong>–ö—Ä–∏—Ç–µ—Ä—ñ–π –ï–π–ª–µ—Ä–∞ (–ù–∞—Å–ª—ñ–¥–æ–∫):</strong> –î–ª—è $v \ge 3$ —Ç–∞ $e$ —Ä–µ–±–µ—Ä, –ø–ª–∞–Ω–∞—Ä–Ω–∏–π –≥—Ä–∞—Ñ –ø–æ–≤–∏–Ω–µ–Ω –∑–∞–¥–æ–≤–æ–ª—å–Ω—è—Ç–∏ $e \le 3v - 6$. –¶–µ —à–≤–∏–¥–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ "–Ω–∞ –Ω—ñ".</p>
                <p><strong>–¢–µ–æ—Ä–µ–º–∞ –ö—É—Ä–∞—Ç–æ–≤—Å—å–∫–æ–≥–æ:</strong> –ì—Ä–∞—Ñ –ø–ª–∞–Ω–∞—Ä–Ω–∏–π $\iff$ –≤—ñ–Ω –Ω–µ –º—ñ—Å—Ç–∏—Ç—å –ø—ñ–¥–≥—Ä–∞—Ñ–∞, –≥–æ–º–µ–æ–º–æ—Ä—Ñ–Ω–æ–≥–æ $K_5$ –∞–±–æ $K_{3,3}$.</p>
                
				<h4>–î–µ—Ç–∞–ª—ñ –ï—Ç–∞–ø—É 1: –ü–æ—à—É–∫ K‚ÇÖ —Ç–∞ K‚ÇÉ,‚ÇÉ (–†–µ–∞–ª—ñ–∑–∞—Ü—ñ—è)</h4>
<p>
    –©–æ–± –¥–æ–≤–µ—Å—Ç–∏, —â–æ –≥—Ä–∞—Ñ –Ω–µ–ø–ª–∞–Ω–∞—Ä–Ω–∏–π, –Ω–∞–º –ø–æ—Ç—Ä—ñ–±–Ω–æ –∑–Ω–∞–π—Ç–∏ –ø—ñ–¥–≥—Ä–∞—Ñ,
    <em>–≥–æ–º–µ–æ–º–æ—Ä—Ñ–Ω–∏–π</em> K‚ÇÖ –∞–±–æ K‚ÇÉ,‚ÇÉ. –¶–µ –æ–∑–Ω–∞—á–∞—î, —â–æ –º–∏ —à—É–∫–∞—î–º–æ 5 (–∞–±–æ 6) "—Ç–µ—Ä–º—ñ–Ω–∞–ª—å–Ω–∏—Ö"
    –≤–µ—Ä—à–∏–Ω —ñ 10 (–∞–±–æ 9) —à–ª—è—Ö—ñ–≤ –º—ñ–∂ –Ω–∏–º–∏, —è–∫—ñ —î <strong>–≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ-–Ω–µ–ø–µ—Ä–µ—Ç–∏–Ω–Ω–∏–º–∏</strong>
    (—Ç–æ–±—Ç–æ, –≤–æ–Ω–∏ –º–æ–∂—É—Ç—å –¥—ñ–ª–∏—Ç–∏ –º—ñ–∂ —Å–æ–±–æ—é –ª–∏—à–µ "—Ç–µ—Ä–º—ñ–Ω–∞–ª—å–Ω—ñ" –≤–µ—Ä—à–∏–Ω–∏, –∞–ª–µ
    –∂–æ–¥–Ω—ñ –¥–≤—ñ –ø–∞—Ä–∏ —à–ª—è—Ö—ñ–≤ –Ω–µ –º–æ–∂—É—Ç—å –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –æ–¥–∏–Ω —ñ —Ç–æ–π —Å–∞–º–∏–π <em>–≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π</em>
    –≤—É–∑–æ–ª).
</p>
<p>
    –¶–µ–π —Å–∏–º—É–ª—è—Ç–æ—Ä –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î –¥–ª—è —Ü—å–æ–≥–æ "—á–µ—Å–Ω–∏–π" –∞–ª–≥–æ—Ä–∏—Ç–º
    <strong>—Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–≥–æ –ø–æ—à—É–∫—É –∑ –±–µ–∫—Ç—Ä–µ–∫—ñ–Ω–≥–æ–º (DFS)</strong>.
    –í—ñ–Ω –ø—Ä–∞—Ü—é—î —Ç–∞–∫:
</p>
<ol>
    <li>–í–∏–±–∏—Ä–∞—î –ø–∞—Ä—É —Ç–µ—Ä–º—ñ–Ω–∞–ª—ñ–≤ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, $A$ —ñ $B$).</li>
    <li>
        –ó–Ω–∞—Ö–æ–¥–∏—Ç—å <em>–ø–µ—Ä—à–∏–π</em> –ø—Ä–æ—Å—Ç–∏–π —à–ª—è—Ö –º—ñ–∂ –Ω–∏–º–∏,
        –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ –ª–∏—à–µ –≤—ñ–ª—å–Ω—ñ –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ –≤—É–∑–ª–∏.
    </li>
    <li>
        "–ë–ª–æ–∫—É—î" –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ –≤—É–∑–ª–∏ —Ü—å–æ–≥–æ —à–ª—è—Ö—É.
    </li>
    <li>
        –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –Ω–∞–º–∞–≥–∞—î—Ç—å—Å—è –∑–Ω–∞–π—Ç–∏ —Ä–µ—à—Ç—É 9 (–∞–±–æ 8) —à–ª—è—Ö—ñ–≤.
    </li>
    <li>
        –Ø–∫—â–æ –Ω–∞ —è–∫–æ–º—É—Å—å –µ—Ç–∞–ø—ñ —Ä–µ–∫—É—Ä—Å—ñ—è –∑–∞–∑–Ω–∞—î –Ω–µ–≤–¥–∞—á—ñ (—à–ª—è—Ö –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ),
        –≤–æ–Ω–∞ "–≤—ñ–¥–∫–æ—á—É—î—Ç—å—Å—è" (backtracks), —Ä–æ–∑–±–ª–æ–∫–æ–≤—É—î –≤—É–∑–ª–∏ —ñ
        –ø—Ä–æ–±—É—î <em>—ñ–Ω—à–∏–π</em> —à–ª—è—Ö –¥–ª—è –ø–∞—Ä–∏ $A$ —ñ $B$.
    </li>
</ol>
<p>
    –¶–µ–π –º–µ—Ç–æ–¥ –≥–∞—Ä–∞–Ω—Ç—É—î –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è –≥–æ–º–µ–æ–º–æ—Ä—Ñ–Ω–æ–≥–æ –ø—ñ–¥–≥—Ä–∞—Ñ—É, —è–∫—â–æ
    –≤—ñ–Ω —ñ—Å–Ω—É—î, –∞–ª–µ –≤—ñ–Ω –º–∞—î –≤–∏—Å–æ–∫—É –∫–æ–º–±—ñ–Ω–∞—Ç–æ—Ä–Ω—É —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å.
</p>

<h4>–ö–æ–º–±—ñ–Ω–∞—Ç–æ—Ä–Ω–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å (–ß–æ–º—É —Ü–µ –ø–æ–≤—ñ–ª—å–Ω–æ)</h4>
<p>
    "–ñ–∞–¥—ñ–±–Ω–∏–π" –∞–ª–≥–æ—Ä–∏—Ç–º (–ø–æ—à—É—Ö —à–ª—è—Ö—ñ–≤ –±–µ–∑ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –Ω–µ–∑–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ) –ø—Ä–∞—Ü—é—î
    —à–≤–∏–¥–∫–æ, –∞–ª–µ –º–æ–∂–µ –ø–æ–º–∏–ª—è—Ç–∏—Å—è. –ü–æ–≤–Ω–∏–π –ø–µ—Ä–µ–±—ñ—Ä 
    —î –∫–æ—Ä–µ–∫—Ç–Ω–∏–º, –∞–ª–µ –ø–æ–≤—ñ–ª—å–Ω–∏–º, –æ—Å–∫—ñ–ª—å–∫–∏ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π –¥–ª—è
    –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –≤–µ–ª–∏—á–µ–∑–Ω–∞.
</p>
<ul>
    <li>
        <strong>–î–ª—è K‚ÇÖ:</strong> –ú–∏ –º–∞—î–º–æ –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –∫–æ–∂–Ω—É –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—é –∑ 5 –≤–µ—Ä—à–∏–Ω —É –≥—Ä–∞—Ñ—ñ.
        –ö—ñ–ª—å–∫—ñ—Å—Ç—å —Ç–∞–∫–∏—Ö –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π:
        $$
        \binom{v}{5} = \frac{v!}{5!(v-5)!}
        $$
        –î–ª—è $v=10$ (—è–∫ —É –≥—Ä–∞—Ñ—ñ –ü–µ—Ç–µ—Ä—Å–æ–Ω–∞) —Ü–µ $\binom{10}{5} = 252$ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—ó.
        –î–ª—è $v=12$ —Ü–µ –≤–∂–µ $\binom{12}{5} = 792$ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—ó.
    </li>
    <li>
        <strong>–î–ª—è K‚ÇÉ,‚ÇÉ:</strong> –¶–µ —â–µ –≥—ñ—Ä—à–µ. –ú–∏ –º–∞—î–º–æ –≤–∏–±—Ä–∞—Ç–∏ 6 –≤–µ—Ä—à–∏–Ω, –∞ –ø–æ—Ç—ñ–º
        —Ä–æ–∑–¥—ñ–ª–∏—Ç–∏ —ó—Ö –Ω–∞ 2 –≥—Ä—É–ø–∏ –ø–æ 3 (—Ü–µ –º–æ–∂–Ω–∞ –∑—Ä–æ–±–∏—Ç–∏ 10-–º–∞ —Å–ø–æ—Å–æ–±–∞–º–∏):
        $$
        \binom{v}{6} \times \frac{1}{2}\binom{6}{3} = \binom{v}{6} \times 10
        $$
        –î–ª—è $v=10$ —Ü–µ $\binom{10}{6} \times 10 = 2100$ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π.
        –î–ª—è $v=12$ —Ü–µ $\binom{12}{6} \times 10 = 9240$ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π.
    </li>
</ul>
<p>
    –°–∞–º–µ —Ç–æ–º—É —Å–∏–º—É–ª—è—Ç–æ—Ä –æ–±–º–µ–∂—É—î –∫—ñ–ª—å–∫—ñ—Å—Ç—å –≤–µ—Ä—à–∏–Ω –¥–æ 12.
</p>

<h4>–°—É—á–∞—Å–Ω—ñ –∞–ª–≥–æ—Ä–∏—Ç–º–∏ –ø–ª–∞–Ω–∞—Ä–Ω–æ—Å—Ç—ñ</h4>
<p>
    –£ –ø—Ä–æ—Ñ–µ—Å—ñ–π–Ω–∏—Ö –∑–∞—Å—Ç–æ—Å—É–Ω–∫–∞—Ö <strong>–Ω—ñ—Ö—Ç–æ –Ω–µ</strong> –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î —Ç–∞–∫–∏–π
    "–≥—Ä—É–±–∏–π" –ø–æ—à—É–∫ K‚ÇÖ/K‚ÇÉ,‚ÇÉ. –¶–µ –Ω–µ–µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ. –°—É—á–∞—Å–Ω—ñ –∞–ª–≥–æ—Ä–∏—Ç–º–∏
    —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è –ø–ª–∞–Ω–∞—Ä–Ω–æ—Å—Ç—ñ, —Ç–∞–∫—ñ —è–∫ –∫–ª–∞—Å–∏—á–Ω–∏–π
    <strong>–∞–ª–≥–æ—Ä–∏—Ç–º –•–æ–ø–∫—Ä–æ—Ñ—Ç–∞-–¢–∞—Ä–¥–∂–∞–Ω–∞ (1974)</strong> –∞–±–æ –±—ñ–ª—å—à –Ω–æ–≤—ñ –º–µ—Ç–æ–¥–∏
    (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, <strong>–∞–ª–≥–æ—Ä–∏—Ç–º –ë–æ–π—î—Ä–∞-–ú—ñ—Ä–≤–æ–ª—å–¥–∞</strong>, —â–æ –±–∞–∑—É—î—Ç—å—Å—è –Ω–∞ PQ-–¥–µ—Ä–µ–≤–∞—Ö),
    –ø—Ä–∞—Ü—é—é—Ç—å –∑–∞ –ª—ñ–Ω—ñ–π–Ω–∏–π —á–∞—Å $O(v)$ (—Ç–æ–±—Ç–æ, –Ω–µ–π–º–æ–≤—ñ—Ä–Ω–æ —à–≤–∏–¥–∫–æ).
</p>
<p>
    –í–æ–Ω–∏ –Ω–µ "—à—É–∫–∞—é—Ç—å" K‚ÇÖ, –∞ –Ω–∞–º–∞–≥–∞—é—Ç—å—Å—è –ø–æ–±—É–¥—É–≤–∞—Ç–∏ –ø–ª–∞–Ω–∞—Ä–Ω–µ —É–∫–ª–∞–¥–∞–Ω–Ω—è
    "—à–º–∞—Ç–æ–∫ –∑–∞ —à–º–∞—Ç–∫–æ–º". –Ø–∫—â–æ –Ω–∞ —è–∫–æ–º—É—Å—å –µ—Ç–∞–ø—ñ –≤–æ–Ω–∏ –Ω–µ –º–æ–∂—É—Ç—å –¥–æ–¥–∞—Ç–∏
    –Ω–æ–≤–µ —Ä–µ–±—Ä–æ, –Ω–µ –ø–æ—Ä—É—à–∏–≤—à–∏ –≤–∂–µ –ø–æ–±—É–¥–æ–≤–∞–Ω—É —Å—Ç—Ä—É–∫—Ç—É—Ä—É, –≤–æ–Ω–∏ –º–æ–∂—É—Ç—å
    (–∑–∞–≤–¥—è–∫–∏ —Å–∫–ª–∞–¥–Ω—ñ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ñ –¥–∞–Ω–∏—Ö) –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ –∑–∞—è–≤–∏—Ç–∏, —â–æ
    –ø–µ—Ä–µ—à–∫–æ–¥–æ—é —î –≥–æ–º–µ–æ–º–æ—Ä—Ñ–Ω–∏–π K‚ÇÖ –∞–±–æ K‚ÇÉ,‚ÇÉ, —ñ –∑—É–ø–∏–Ω–∏—Ç–∏ –ø—Ä–æ—Ü–µ—Å.
</p>
				
				
                <h4 id="theory-stage-2">–ï—Ç–∞–ø 2: 3-–ó–≤'—è–∑–Ω—ñ—Å—Ç—å</h4>
                <p><strong>–ó–≤'—è–∑–Ω—ñ—Å—Ç—å</strong> –≥—Ä–∞—Ñ–∞ $k$ –æ–∑–Ω–∞—á–∞—î, —â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ –≤–∏–¥–∞–ª–∏—Ç–∏ —â–æ–Ω–∞–π–º–µ–Ω—à–µ $k$ –≤–µ—Ä—à–∏–Ω, —â–æ–± —Ä–æ–∑–±–∏—Ç–∏ –≥—Ä–∞—Ñ –Ω–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏.</p>
                <ul>
                    <li><strong>–®–∞—Ä–Ω—ñ—Ä (Cut Vertex):</strong> –í–µ—Ä—à–∏–Ω–∞, –≤–∏–¥–∞–ª–µ–Ω–Ω—è —è–∫–æ—ó –∑–±—ñ–ª—å—à—É—î –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç. –ì—Ä–∞—Ñ –∑ —à–∞—Ä–Ω—ñ—Ä–æ–º —î <strong>1-–∑–≤'—è–∑–Ω–∏–º</strong>.</li>
                    <li><strong>–ü–∞—Ä–∞-—Ä–æ–∑–¥—ñ–ª—é–≤–∞—á (Separation Pair):</strong> –ü–∞—Ä–∞ –≤–µ—Ä—à–∏–Ω, –≤–∏–¥–∞–ª–µ–Ω–Ω—è —è–∫–∏—Ö —Ä–æ–∑'—î–¥–Ω—É—î –≥—Ä–∞—Ñ. –ì—Ä–∞—Ñ –±–µ–∑ —à–∞—Ä–Ω—ñ—Ä—ñ–≤, –∞–ª–µ –∑ –ø–∞—Ä–æ—é-—Ä–æ–∑–¥—ñ–ª—é–≤–∞—á–µ–º, —î <strong>2-–∑–≤'—è–∑–Ω–∏–º</strong>.</li>
                    <li><strong>3-–∑–≤'—è–∑–Ω–∏–π –≥—Ä–∞—Ñ:</strong> –ì—Ä–∞—Ñ, —â–æ –Ω–µ –º–∞—î –∞–Ω—ñ —à–∞—Ä–Ω—ñ—Ä—ñ–≤, –∞–Ω—ñ –ø–∞—Ä-—Ä–æ–∑–¥—ñ–ª—é–≤–∞—á—ñ–≤.</li>
                </ul>
                <p>–¶–µ–π —Å–∏–º—É–ª—è—Ç–æ—Ä –≤—ñ–∑—É–∞–ª—å–Ω–æ –ø–µ—Ä–µ–≤—ñ—Ä—è—î –Ω–∞—è–≤–Ω—ñ—Å—Ç—å —à–∞—Ä–Ω—ñ—Ä—ñ–≤ —Ç–∞ –ø–∞—Ä-—Ä–æ–∑–¥—ñ–ª—é–≤–∞—á—ñ–≤, "—Ä–æ–∑—Ç—è–≥—É—é—á–∏" –≥—Ä–∞—Ñ —Ñ—ñ–∑–∏—á–Ω–æ—é —Å–∏–º—É–ª—è—Ü—ñ—î—é –ø—ñ—Å–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤.</p>

                <h4 id="theory-stage-3">–ï—Ç–∞–ø 3: –£–∫–ª–∞–¥–∞–Ω–Ω—è –¢—É—Ç—Ç–µ (Spring Embedding)</h4>
                <p>–¢–µ–æ—Ä–µ–º–∞ –¢—É—Ç—Ç–µ (1963) —Å—Ç–≤–µ—Ä–¥–∂—É—î, —â–æ –±—É–¥—å-—è–∫–∏–π <strong>3-–∑–≤'—è–∑–Ω–∏–π –ø–ª–∞–Ω–∞—Ä–Ω–∏–π –≥—Ä–∞—Ñ</strong> –º–æ–∂–Ω–∞ —É–∫–ª–∞—Å—Ç–∏ –Ω–∞ –ø–ª–æ—â–∏–Ω—ñ —Ç–∞–∫, —â–æ:</p>
                <ol>
                    <li>–û–¥–Ω–∞ –∑ –π–æ–≥–æ –≥—Ä–∞–Ω–µ–π (—Ü–∏–∫–ª—ñ–≤) —É—Ç–≤–æ—Ä—é—î –æ–ø—É–∫–ª–∏–π –±–∞–≥–∞—Ç–æ–∫—É—Ç–Ω–∏–∫ (—Ü–µ –Ω–∞—à "–∑–æ–≤–Ω—ñ—à–Ω—ñ–π" —Ü–∏–∫–ª).</li>
                    <li>–ö–æ–∂–Ω–∞ "–≤–Ω—É—Ç—Ä—ñ—à–Ω—è" –≤–µ—Ä—à–∏–Ω–∞ —Ä–æ–∑–º—ñ—â—É—î—Ç—å—Å—è –≤ <strong>—Ü–µ–Ω—Ç—Ä—ñ –º–∞—Å (–±–∞—Ä—ñ—Ü–µ–Ω—Ç—Ä—ñ)</strong> —Å–≤–æ—ó—Ö —Å—É—Å—ñ–¥—ñ–≤.</li>
                </ol>
                <p>–¶–µ –≥–∞—Ä–∞–Ω—Ç—É—î –ø–ª–∞–Ω–∞—Ä–Ω–µ —É–∫–ª–∞–¥–∞–Ω–Ω—è –±–µ–∑ –ø–µ—Ä–µ—Ç–∏–Ω—ñ–≤. –ê–ª–≥–æ—Ä–∏—Ç–º –º–æ–¥–µ–ª—é—î "—Å–∏—Å—Ç–µ–º—É –ø—Ä—É–∂–∏–Ω", –¥–µ –∫–æ–∂–Ω–µ —Ä–µ–±—Ä–æ - —Ü–µ –ø—Ä—É–∂–∏–Ω–∞ –∑ –æ–¥–Ω–∞–∫–æ–≤–∏–º –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–æ–º –∂–æ—Ä—Å—Ç–∫–æ—Å—Ç—ñ. –ü–æ–∑–∏—Ü—ñ—ó –≤–µ—Ä—à–∏–Ω –∑–æ–≤–Ω—ñ—à–Ω—å–æ–≥–æ —Ü–∏–∫–ª—É —Ñ—ñ–∫—Å–æ–≤–∞–Ω—ñ, –∞ –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ "–∑–Ω–∞—Ö–æ–¥—è—Ç—å" —Å–≤–æ—î –ø–æ–ª–æ–∂–µ–Ω–Ω—è —Ä—ñ–≤–Ω–æ–≤–∞–≥–∏.</p>
                <p><strong>–ß–æ–º—É 3-–∑–≤'—è–∑–Ω—ñ—Å—Ç—å –∫—Ä–∏—Ç–∏—á–Ω–∞?</strong> –Ø–∫—â–æ –≥—Ä–∞—Ñ –Ω–µ 3-–∑–≤'—è–∑–Ω–∏–π (–º–∞—î —à–∞—Ä–Ω—ñ—Ä –∞–±–æ –ø–∞—Ä—É-—Ä–æ–∑–¥—ñ–ª—é–≤–∞—á), —Å–∏—Å—Ç–µ–º–∞ "–ø—Ä—É–∂–∏–Ω" —Å—Ç–∞—î –Ω–µ—Å—Ç–∞–±—ñ–ª—å–Ω–æ—é. –í–Ω—É—Ç—Ä—ñ—à–Ω—ñ –≤–µ—Ä—à–∏–Ω–∏, —â–æ –Ω–∞–ª–µ–∂–∞—Ç—å –¥–æ –æ–¥–Ω–æ–≥–æ "—à–º–∞—Ç–∫–∞", "—Å–∫–æ–ª–∞–ø—Å—É—é—Ç—å" –≤ –æ–¥–Ω—É —Ç–æ—á–∫—É, –æ—Å–∫—ñ–ª—å–∫–∏ —ó—Ö–Ω—ñ –ø–æ–∑–∏—Ü—ñ—ó –∑–∞–ª–µ–∂–∞—Ç—å –ª–∏—à–µ –æ–¥–Ω–∞ –≤—ñ–¥ –æ–¥–Ω–æ—ó, –∞ –Ω–µ –≤—ñ–¥ —Ñ—ñ–∫—Å–æ–≤–∞–Ω–æ–≥–æ –∑–æ–≤–Ω—ñ—à–Ω—å–æ–≥–æ —Ü–∏–∫–ª—É.</p>
            </div>
			<h4>–¢–µ–æ—Ä–µ–º–∞ –¢—É—Ç—Ç–µ —è–∫ –°–õ–ê–† (–°–∏—Å—Ç–µ–º–∞ –õ—ñ–Ω—ñ–π–Ω–∏—Ö –ê–ª–≥–µ–±—Ä–∞—ó—á–Ω–∏—Ö –†—ñ–≤–Ω—è–Ω—å)</h4>
<p>
    –£–º–æ–≤–∞, —â–æ –∫–æ–∂–Ω–∞ –≤–Ω—É—Ç—Ä—ñ—à–Ω—è –≤–µ—Ä—à–∏–Ω–∞ $v_i$ —î –±–∞—Ä–∏—Ü–µ–Ω—Ç—Ä–æ–º (—Ü–µ–Ω—Ç—Ä–æ–º –º–∞—Å) —Å–≤–æ—ó—Ö —Å—É—Å—ñ–¥—ñ–≤,
    –Ω–∞—Å–ø—Ä–∞–≤–¥—ñ —î —Å–∏—Å—Ç–µ–º–æ—é –ª—ñ–Ω—ñ–π–Ω–∏—Ö —Ä—ñ–≤–Ω—è–Ω—å. –ú–∏ –º–æ–∂–µ–º–æ —Ä–æ–∑–≤'—è–∑–∞—Ç–∏ —ó—ó,
    —â–æ–± <em>–º–∏—Ç—Ç—î–≤–æ</em> –∑–Ω–∞–π—Ç–∏ —Ñ—ñ–Ω–∞–ª—å–Ω—ñ –ø–æ–∑–∏—Ü—ñ—ó, –∑–∞–º—ñ—Å—Ç—å —ñ—Ç–µ—Ä–∞—Ü—ñ–π.
</p>
<p>
    –†–æ–∑–≥–ª—è–Ω–µ–º–æ –æ–∫—Ä–µ–º–æ $x$ —Ç–∞ $y$ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏. –î–ª—è $x$-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –∫–æ–∂–Ω–æ—ó
    <strong>–≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ—ó</strong> –≤–µ—Ä—à–∏–Ω–∏ $v_i$ (–∑ –Ω–µ–≤—ñ–¥–æ–º–æ—é $x_i$) –º–∞—î–º–æ:
</p>
$$
x_i = \frac{1}{\text{deg}(v_i)} \sum_{j \in N(v_i)} x_j
$$
<p>
    –¥–µ $N(v_i)$ ‚Äî —Ü–µ –º–Ω–æ–∂–∏–Ω–∞ —Å—É—Å—ñ–¥—ñ–≤ $v_i$.
    –ü–µ—Ä–µ–≥—Ä—É–ø—É—î–º–æ —Ü–µ —É —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É —Ñ–æ—Ä–º—É –°–õ–ê–† (<code>Ax = b</code>),
    –ø–µ—Ä–µ–Ω—ñ—Å—à–∏ –≤—Å—ñ <em>–Ω–µ–≤—ñ–¥–æ–º—ñ</em> (—ñ–Ω—à—ñ –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ –≤–µ—Ä—à–∏–Ω–∏ $I$) –ª—ñ–≤–æ—Ä—É—á,
    –∞ <em>–≤—ñ–¥–æ–º—ñ</em> (—Ñ—ñ–∫—Å–æ–≤–∞–Ω—ñ –∑–æ–≤–Ω—ñ—à–Ω—ñ –≤–µ—Ä—à–∏–Ω–∏ $O$) –∑–∞–ª–∏—à–∏–≤—à–∏ –ø—Ä–∞–≤–æ—Ä—É—á:
</p>
$$
\text{deg}(v_i) \cdot x_i - \sum_{j \in N(v_i) \cap I} x_j = \sum_{k \in N(v_i) \cap O} \bar{x}_k
$$
<p>
    –î–µ:
</p>
<ul>
    <li>$v_i$ - –≤–Ω—É—Ç—Ä—ñ—à–Ω—è –≤–µ—Ä—à–∏–Ω–∞, $I$ - –º–Ω–æ–∂–∏–Ω–∞ –≤—Å—ñ—Ö –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ—Ö –≤–µ—Ä—à–∏–Ω.</li>
    <li>$O$ - –º–Ω–æ–∂–∏–Ω–∞ –≤—Å—ñ—Ö –∑–æ–≤–Ω—ñ—à–Ω—ñ—Ö (—Ñ—ñ–∫—Å–æ–≤–∞–Ω–∏—Ö) –≤–µ—Ä—à–∏–Ω.</li>
    <li>$x_i$ —Ç–∞ $x_j$ - <strong>–Ω–µ–≤—ñ–¥–æ–º—ñ</strong> $x$-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ—Ö –≤–µ—Ä—à–∏–Ω.</li>
    <li>$\bar{x}_k$ - <strong>–≤—ñ–¥–æ–º—ñ</strong> (—Ñ—ñ–∫—Å–æ–≤–∞–Ω—ñ) $x$-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ —Å—É—Å—ñ–¥—ñ–≤ –Ω–∞ –∑–æ–≤–Ω—ñ—à–Ω—ñ–π –≥—Ä–∞–Ω—ñ.</li>
    <li>$\text{deg}(v_i)$ - –ø–æ–≤–Ω–∏–π —Å—Ç–µ–ø—ñ–Ω—å –≤–µ—Ä—à–∏–Ω–∏ $v_i$.</li>
</ul>
<p>
    –ê–Ω–∞–ª–æ–≥—ñ—á–Ω–∞, –∞–ª–µ –Ω–µ–∑–∞–ª–µ–∂–Ω–∞ —Å–∏—Å—Ç–µ–º–∞ —Ä—ñ–≤–Ω—è–Ω—å —ñ—Å–Ω—É—î —ñ –¥–ª—è $y$-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.
</p>

<h4>–£–∫–ª–∞–¥–∞–Ω–Ω—è —è–∫ –ú–µ—Ç–æ–¥ –Ø–∫–æ–±—ñ</h4>
<p>
    –Ü—Ç–µ—Ä–∞—Ü—ñ–π–Ω–∞ –ø—Ä–æ—Ü–µ–¥—É—Ä–∞ —É–∫–ª–∞–¥–∞–Ω–Ω—è, —è–∫—É –≤–∏ –±–∞—á–∏—Ç–µ –Ω–∞ –ï—Ç–∞–ø—ñ 3,
    –Ω–∞—Å–ø—Ä–∞–≤–¥—ñ —î –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—î—é <strong>–º–µ—Ç–æ–¥—É –Ø–∫–æ–±—ñ</strong> –¥–ª—è —Ä–æ–∑–≤'—è–∑–∞–Ω–Ω—è
    —Ü—ñ—î—ó –°–õ–ê–†.
</p>
<p>
    –ú–µ—Ç–æ–¥ –Ø–∫–æ–±—ñ ‚Äî —Ü–µ —ñ—Ç–µ—Ä–∞—Ü—ñ–π–Ω–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º, –¥–µ –Ω–æ–≤–µ –ø–æ–ª–æ–∂–µ–Ω–Ω—è $(k+1)$ –¥–ª—è <em>–∫–æ–∂–Ω–æ—ó</em> –≤–µ—Ä—à–∏–Ω–∏
    –æ–±—á–∏—Å–ª—é—î—Ç—å—Å—è <strong>–≤–∏–∫–ª—é—á–Ω–æ</strong> –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–æ–ª–æ–∂–µ–Ω—å <em>—É—Å—ñ—Ö</em> –≤–µ—Ä—à–∏–Ω
    –Ω–∞ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–º—É –∫—Ä–æ—Ü—ñ $(k)$.
</p>
$$
x_i^{(k+1)} = \frac{1}{\text{deg}(v_i)} \left( \sum_{j \in N(v_i) \cap I} x_j^{(k)} + \sum_{k \in N(v_i) \cap O} \bar{x}_k \right)
$$
<p>
    –¶–µ <em>—Ç–æ—á–Ω–æ</em> —Ç–µ, —â–æ —Ä–æ–±–∏—Ç—å —Å–∏–º—É–ª—è—Ç–æ—Ä: –Ω–∞ –∫–æ–∂–Ω–æ–º—É "–∫—Ä–æ—Ü—ñ" –≤—ñ–Ω
    –ø–µ—Ä–µ—Ä–∞—Ö–æ–≤—É—î –±–∞—Ä–∏—Ü–µ–Ω—Ç—Ä –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –≤—É–∑–ª–∞ –Ω–∞ –æ—Å–Ω–æ–≤—ñ "—Å—Ç–∞—Ä–∏—Ö"
    –ø–æ–∑–∏—Ü—ñ–π, –∞ –ø–æ—Ç—ñ–º –ø–µ—Ä–µ–º—ñ—â—É—î —ó—Ö —É—Å—ñ –æ–¥–Ω–æ—á–∞—Å–Ω–æ.
</p>
<p>
    –ú–∞—Ç—Ä–∏—Ü—è —Ü—ñ—î—ó —Å–∏—Å—Ç–µ–º–∏ (—è–∫–∞ —î —á–∞—Å—Ç–∏–Ω–æ—é –º–∞—Ç—Ä–∏—Ü—ñ –õ–∞–ø–ª–∞—Å–∞)
    –º–∞—î –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ (–≤–æ–Ω–∞ —î <strong> –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ –¥–æ–º—ñ–Ω—É—é—á–æ—é</strong>),
    —è–∫—ñ <strong>–≥–∞—Ä–∞–Ω—Ç—É—é—Ç—å</strong>, —â–æ –º–µ—Ç–æ–¥ –Ø–∫–æ–±—ñ (—ñ —ñ—Ç–µ—Ä–∞—Ü—ñ–π–Ω–µ —É–∫–ª–∞–¥–∞–Ω–Ω—è –¢—É—Ç—Ç–µ)
    –∑–∞–≤–∂–¥–∏ –±—É–¥–µ –∑–±—ñ–≥–∞—Ç–∏—Å—è –¥–æ —î–¥–∏–Ω–æ–≥–æ –∫–æ—Ä–µ–∫—Ç–Ω–æ–≥–æ, –ø–ª–∞–Ω–∞—Ä–Ω–æ–≥–æ —Ä–æ–∑–≤'—è–∑–∫—É.
</p>
        </details>
    </div>

  
  <script type="module">
        // --- DOM –ï–ª–µ–º–µ–Ω—Ç–∏ ---
        const svgEl = d3.select("#graph-svg");
        const svgContainer = d3.select("#graph-svg-container");
        
        // –ï—Ç–∞–ø 1 (–ü–ª–∞–Ω–∞—Ä–Ω—ñ—Å—Ç—å)
        const stage1Container = d3.select("#stage-1-planarity");
        const tabStage1 = d3.select("#tab-stage-1");
        const commentaryEl = d3.select("#step-commentary");
        const nextBtn = d3.select("#next-step-btn");
        const prevBtn = d3.select("#prev-step-btn");
        const nodeCountInput = d3.select("#node-count-input");
        const edgeProbInput = d3.select("#edge-prob-input");
        const genPlanarBtn = d3.select("#gen-planar-btn");
        const genPlanar2CutBtn = d3.select("#gen-planar-2cut-btn"); 
        const genIcosahedronBtn = d3.select("#gen-icosahedron-btn"); // –î–û–î–ê–ù–û
        const genK5Btn = d3.select("#gen-k5-btn");
        const genK33Btn = d3.select("#gen-k33-btn");
        const genHomeoK5Btn = d3.select("#gen-homeo-k5-btn");
        const genRandomBtn = d3.select("#gen-random-btn");
        const togglePhysicsBtn = d3.select("#toggle-physics-btn");
        const allGenButtons = [genPlanarBtn, genPlanar2CutBtn, genIcosahedronBtn, genK5Btn, genK33Btn, genHomeoK5Btn, genRandomBtn, nodeCountInput, edgeProbInput];
        
        // –ï—Ç–∞–ø 2 (–ó–≤'—è–∑–Ω—ñ—Å—Ç—å)
        const stage2Container = d3.select("#stage-2-connectivity");
        const tabStage2 = d3.select("#tab-stage-2");
        const connectivityCommentaryEl = d3.select("#connectivity-commentary");
        const startConnectivityTestBtn = d3.select("#start-connectivity-test-btn");
        const tutteOptionsContainer = d3.select("#tutte-options");

        // –ï—Ç–∞–ø 3 (–¢—É—Ç—Ç–µ)
        const stage3Container = d3.select("#stage-3-tutte");
        const tabStage3 = d3.select("#tab-stage-3");
        const tutteCommentaryEl = d3.select("#tutte-commentary");
        const tuttePrevBtn = d3.select("#tutte-prev-step-btn");
        const tutteNextBtn = d3.select("#tutte-next-step-btn");
        const tutteAutoBtn = d3.select("#tutte-run-auto-btn");
        const tutteTogglePhysicsBtn = d3.select("#tutte-toggle-physics-btn"); // –ó–ú–Ü–ù–ï–ù–û
        let tutteSimulation = null; // –û–∫—Ä–µ–º–∞ —Å–∏–º—É–ª—è—Ü—ñ—è –¥–ª—è –¢—É—Ç—Ç–µ


        // --- –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏ ---
        const NODE_RADIUS = 12;
        let width, height;

        // --- –ì–ª–æ–±–∞–ª—å–Ω–∏–π —Å—Ç–∞–Ω ---
        let mainGraph = { nodes: [], edges: [] }; // {id, x, y}, {source: id, target: id}
        let d3Nodes = []; // –ú–∞—Å–∏–≤ –¥–ª—è D3 —Å–∏–º—É–ª—è—Ü—ñ—ó
        let d3Edges = []; // –ú–∞—Å–∏–≤ –¥–ª—è D3 —Å–∏–º—É–ª—è—Ü—ñ—ó
        let simulation;
		let selectedNodesForEdge = new Set();
        let currentStage = 'planarity'; // 'planarity', 'connectivity', 'tutte'

        // --- D3 –ï–ª–µ–º–µ–Ω—Ç–∏ ---
        let linkGroup, nodeGroup, labelGroup, newEdgeGroup;
        // –î–ª—è –¢—É—Ç—Ç–µ
        let tutteClusterGroup;
        let tutteCentroidGroup;

        // --- –°—Ç–∞–Ω –ï—Ç–∞–ø—É 1 (–ü–ª–∞–Ω–∞—Ä–Ω—ñ—Å—Ç—å) ---
        let planarityState = {
            steps: [],
            currentStep: 0,
            originalGraphD3: { nodes: [], edges: [] } // {id}, {source: {id}, target: {id}}
        };

        // --- –°—Ç–∞–Ω –ï—Ç–∞–ø—É 3 (–¢—É—Ç—Ç–µ) ---
        let tutteState = {
            history: [],
            currentStep: -1,
            adj: [], // –°–ø–∏—Å–æ–∫ —Å—É–º—ñ–∂–Ω–æ—Å—Ç—ñ (–ø–æ id)
            outerFaceIds: [],
            innerNodeIds: []
        };


        // ====================================================================
        // --- –Ü–ù–Ü–¶–Ü–ê–õ–Ü–ó–ê–¶–Ü–Ø –¢–ê –ö–ï–†–£–í–ê–ù–ù–Ø –ï–¢–ê–ü–ê–ú–ò ---
        // ====================================================================

        function switchStage(stageName) {
            currentStage = stageName;
            
            stage1Container.style('display', 'none');
            stage2Container.style('display', 'none');
            stage3Container.style('display', 'none');

            tabStage1.classed('active', false);
            tabStage2.classed('active', false);
            tabStage3.classed('active', false);

            // –ó—É–ø–∏–Ω—è—î–º–æ —Å–∏–º—É–ª—è—Ü—ñ—é –¢—É—Ç—Ç–µ, —è–∫—â–æ –≤–æ–Ω–∞ –±—É–ª–∞
            if (tutteSimulation) {
                tutteSimulation.stop();
                tutteSimulation = null;
                tutteTogglePhysicsBtn.text("üîå –£–≤—ñ–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É");
            }

            if (stageName === 'planarity') {
                stage1Container.style('display', 'block');
                tabStage1.classed('active', true);
                // resetToPlanarityStage(); // –ù–µ –≤–∏–∫–ª–∏–∫–∞—î–º–æ –∑–≤—ñ–¥—Å–∏, —â–æ–± —É–Ω–∏–∫–Ω—É—Ç–∏ —Ä–µ–∫—É—Ä—Å—ñ—ó
            } else if (stageName === 'connectivity') {
                stage2Container.style('display', 'block');
                tabStage2.classed('active', true);
                initConnectivityStage();
            } else if (stageName === 'tutte') {
                stage3Container.style('display', 'block');
                tabStage3.classed('active', true);
                // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –¢—É—Ç—Ç–µ –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è –∑ –∫–Ω–æ–ø–æ–∫ –ï—Ç–∞–ø—É 2
            }
            
            // –°–∫–∏–¥–∞–Ω–Ω—è —Å–∏–º—É–ª—è—Ü—ñ—ó, —è–∫—â–æ –≤–æ–Ω–∞ —î (–¥–ª—è –µ—Ç–∞–ø—ñ–≤ 1 —ñ 2)
            if (simulation && stageName !== 'tutte') {
                simulation.stop();
                simulation = null;
            }
            
            // –ó–∞–ø—É—Å–∫ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—ó –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó
            if (stageName === 'planarity') {
                // –ü—Ä–∏ –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—ñ –Ω–∞ 1 –µ—Ç–∞–ø, –º–∏ –º–∞—î–º–æ –≤—ñ–¥–Ω–æ–≤–∏—Ç–∏ —Å–∏–º—É–ª—è—Ü—ñ—é
                // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ *–∑–±–µ—Ä–µ–∂–µ–Ω—ñ* d3Nodes/d3Edges, —è–∫—ñ –≤–∂–µ –º–∞—é—Ç—å –ø–æ–∑–∏—Ü—ñ—ó
                if (d3Nodes.length === 0) { // –Ø–∫—â–æ —Ü–µ –ø–µ—Ä—à–∏–π –∑–∞–ø—É—Å–∫
                     d3Nodes = planarityState.originalGraphD3.nodes.map(n => ({...n, x: 0, y: 0}));
                     d3Edges = planarityState.originalGraphD3.edges.map(e => ({
                        id: e.id,
                        source: d3Nodes.find(n => n.id === e.source.id), 
                        target: d3Nodes.find(n => n.id === e.target.id)
                    }));
                }
                
                // –ú–∏ –º–∞—î–º–æ –∑–±–µ—Ä–µ–≥—Ç–∏ –ø–æ–∑–∏—Ü—ñ—ó, —è–∫—â–æ –≤–æ–Ω–∏ —î –∑ mainGraph
                if (mainGraph.nodes.length > 0) {
                    d3Nodes.forEach(d3n => {
                        const mainN = mainGraph.nodes.find(mn => mn.id === d3n.id);
                        if (mainN && mainN.x) { // –Ø–∫—â–æ –ø–æ–∑–∏—Ü—ñ—ó –≤–∂–µ –±—É–ª–∏
                            d3n.x = mainN.x;
                            d3n.y = mainN.y;
                        }
                    });
                }
                
                initPlanaritySimulation(d3Nodes, d3Edges);
                updatePlanarityView();
                
            } else if (stageName === 'connectivity') {
                // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ d3Nodes/d3Edges, –æ–Ω–æ–≤–ª–µ–Ω—ñ –∑ mainGraph
                d3Nodes = mainGraph.nodes.map(n => ({...n}));
                d3Edges = mainGraph.edges.map((e, i) => ({
                    id: `e${i}`, // –ü–µ—Ä–µ–∫–æ–Ω–∞—î–º–æ—Å—å, —â–æ —î ID
                    source: d3Nodes.find(n => n.id === e.source), 
                    target: d3Nodes.find(n => n.id === e.target)
                }));
                initConnectivityStage(); // initConnectivityStage —Ç–µ–ø–µ—Ä —Å–∞–º –º–∞–ª—é—î
            } else if (stageName === 'tutte') {
                // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó –¢—É—Ç—Ç–µ (–±–µ–∑ —Å–∏–º—É–ª—è—Ü—ñ—ó)
                if(simulation) {
                    simulation.stop(); // –ó—É–ø–∏–Ω—è—î–º–æ –≥–æ–ª–æ–≤–Ω—É —Å–∏–º—É–ª—è—Ü—ñ—é
                    simulation = null;
                }
                initTutteVisuals();
                updateTutteView();
            }
        }
        
        // !!! –í–ò–ü–†–ê–í–õ–ï–ù–û (–î–û–î–ê–ù–û –û–ë–†–û–ë–ù–ò–ö–ò –ù–ê–¢–ò–°–ö–ê–ù–ù–Ø) !!!
        tabStage1.on('click', () => {
            // –ü—Ä–∏ –Ω–∞—Ç–∏—Å–∫–∞–Ω–Ω—ñ –Ω–∞ –ï—Ç–∞–ø 1, –º–∏ —Å–∫–∏–¥–∞—î–º–æ –≤—Å–µ –¥–æ –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ —Å—Ç–∞–Ω—É
            resetToPlanarityStage();
        });
        
        tabStage2.on('click', () => {
            // –ù–∞ –ï—Ç–∞–ø 2 –º–æ–∂–Ω–∞ –ø–µ—Ä–µ–π—Ç–∏, —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –≤—ñ–Ω "enabled"
            if (tabStage2.classed('enabled')) {
                switchStage('connectivity');
            }
        });
        
        tabStage3.on('click', () => {
            // –ù–∞ –ï—Ç–∞–ø 3 –º–æ–∂–Ω–∞ –ø–µ—Ä–µ–π—Ç–∏, —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –≤—ñ–Ω "enabled"
            if (tabStage3.classed('enabled')) {
                switchStage('tutte');
            }
        });


        function resetToPlanarityStage() {
            currentStage = 'planarity'; // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –ø—Ä–∏–º—É—Å–æ–≤–æ
            
            // –°–∫–∏–¥–∞—î–º–æ —Å—Ç–∞–Ω–∏ 2 —ñ 3
            tabStage1.classed('active', true);
            tabStage2.classed('active', false).classed('enabled', false).classed('completed', false).classed('failed', false);
            tabStage3.classed('active', false).classed('enabled', false).classed('completed', false).classed('failed', false);
            
            stage1Container.style('display', 'block');
            stage2Container.style('display', 'none');
            stage3Container.style('display', 'none');

            mainGraph = { nodes: [], edges: [] };
            d3Nodes = [];
            d3Edges = [];
            
            tutteState = { history: [], currentStep: -1, adj: [], outerFaceIds: [], innerNodeIds: [] };
            
            tutteOptionsContainer.style('display', 'none').html('');
            startConnectivityTestBtn.property('disabled', false);

            allGenButtons.forEach(btn => btn.property('disabled', false));
            
            generatePlanarityGraph('planar');
        }

        // ====================================================================
        // --- D3 –°–ò–ú–£–õ–Ø–¶–Ü–Ø (–°–ü–Ü–õ–¨–ù–ê) ---
        // ====================================================================
        
        function initBaseSimulation(nodes, edges) {
            if (simulation) {
                simulation.stop();
            }

            // –û—á–∏—â–µ–Ω–Ω—è SVG
            svgEl.selectAll("*").remove();

            // –ì—Ä—É–ø–∏ –¥–ª—è –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ (—Ä–µ–±—Ä–∞ –ø—ñ–¥ –≤–µ—Ä—à–∏–Ω–∞–º–∏)
            linkGroup = svgEl.append("g").attr("class", "links-group");
            newEdgeGroup = svgEl.append("g").attr("class", "new-edges-group");
            nodeGroup = svgEl.append("g").attr("class", "nodes-group");
            labelGroup = svgEl.append("g").attr("class", "labels-group");
            tutteClusterGroup = svgEl.append("g").attr("class", "tutte-clusters-group");
            tutteCentroidGroup = svgEl.append("g").attr("class", "tutte-centroids-group");
            
			
			
			// –û—á–∏—â—É—î–º–æ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è –ø—Ä–∏ –∫–æ–∂–Ω–æ–º—É –ø–µ—Ä–µ–º–∞–ª—å–æ–≤—É–≤–∞–Ω–Ω—ñ
            selectedNodesForEdge.clear();

            // 1. –ü–æ–¥–≤—ñ–π–Ω–∏–π –∫–ª—ñ–∫ –Ω–∞ –∫–∞–Ω–≤—ñ (–î–æ–¥–∞—Ç–∏ –í–µ—Ä—à–∏–Ω—É)
            svgEl.on('dblclick', (event) => {
                event.preventDefault();
                // –ü—Ä–∞—Ü—é—î —Ç—ñ–ª—å–∫–∏ –Ω–∞ –ï—Ç–∞–ø—ñ 1 –∑ –≤–∏–º–∫–Ω–µ–Ω–æ—é —Ñ—ñ–∑–∏–∫–æ—é
                if (currentStage !== 'planarity' || physicsEnabled === true) return;
                
                if (d3Nodes.length >= 12) {
                    alert("–î–æ—Å—è–≥–Ω—É—Ç–æ –ª—ñ–º—ñ—Ç—É –≤ 12 –≤–µ—Ä—à–∏–Ω.");
                    return;
                }
                
                const [x, y] = d3.pointer(event);
                // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –Ω–æ–≤–∏–π —É–Ω—ñ–∫–∞–ª—å–Ω–∏–π ID
                const newId = (d3Nodes.length > 0 ? Math.max(...d3Nodes.map(n => n.id)) : 0) + 1;
                const newNode = { id: newId, x: x, y: y, fx: x, fy: y }; // fx/fy, —â–æ–± –≤—ñ–Ω –Ω–µ —Ä—É—Ö–∞–≤—Å—è

                // –î–æ–¥–∞—î–º–æ –≤—É–∑–æ–ª –¥–æ –í–°–Ü–• –¥–∂–µ—Ä–µ–ª –¥–∞–Ω–∏—Ö
                d3Nodes.push(newNode);
                mainGraph.nodes.push({ id: newId, x: x, y: y });
                planarityState.originalGraphD3.nodes.push({ id: newId });
                
                // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞—î–º–æ —Ç–µ—Å—Ç (—Ü–µ –æ–Ω–æ–≤–∏—Ç—å –≤—Å–µ, –≤ —Ç.—á. d3Edges)
				initPlanaritySimulation(d3Nodes, d3Edges);
                runPlanarityTest();
            });

            // 2. –ö–ª—ñ–∫ –Ω–∞ –í–µ—Ä—à–∏–Ω—ñ (–í–∏–¥—ñ–ª–∏—Ç–∏ / –í–∏–¥–∞–ª–∏—Ç–∏)
            // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –¥–µ–ª–µ–≥—É–≤–∞–Ω–Ω—è –Ω–∞ –≥—Ä—É–ø—ñ-–±–∞—Ç—å–∫—É
            nodeGroup.on('click', (event) => {
                // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –¥–∞–Ω—ñ –≤—É–∑–ª–∞, –Ω–∞ —è–∫–∏–π –∫–ª—ñ–∫–Ω—É–ª–∏
                const d = d3.select(event.target.closest('.node'))?.datum();
                if (!d) return; // –ö–ª—ñ–∫–Ω—É–ª–∏ –Ω–µ –Ω–∞ –≤—É–∑–æ–ª

                if (currentStage !== 'planarity' || physicsEnabled === true) return;
                
                const clickedNodeId = d.id;

                if (event.ctrlKey) {
                    // --- –í–ò–î–ê–õ–ò–¢–ò –í–ï–†–®–ò–ù–£ ---
                    event.preventDefault();
                    event.stopPropagation();
                    
                    // –í–∏–¥–∞–ª—è—î–º–æ –∑ —É—Å—ñ—Ö –¥–∂–µ—Ä–µ–ª –¥–∞–Ω–∏—Ö
                    d3Nodes = d3Nodes.filter(n => n.id !== clickedNodeId);
                    d3Edges = d3Edges.filter(e => e.source.id !== clickedNodeId && e.target.id !== clickedNodeId);
                    
                    mainGraph.nodes = mainGraph.nodes.filter(n => n.id !== clickedNodeId);
                    mainGraph.edges = mainGraph.edges.filter(e => e.source !== clickedNodeId && e.target !== clickedNodeId);
                    
                    planarityState.originalGraphD3.nodes = planarityState.originalGraphD3.nodes.filter(n => n.id !== clickedNodeId);
                    planarityState.originalGraphD3.edges = planarityState.originalGraphD3.edges.filter(e => e.source.id !== clickedNodeId && e.target.id !== clickedNodeId);
                    
                    selectedNodesForEdge.clear();
					initPlanaritySimulation(d3Nodes, d3Edges);
                    runPlanarityTest(); // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞—î–º–æ

                } else if (event.shiftKey) {
                    // --- –î–û–î–ê–¢–ò –†–ï–ë–†–û (–í–∏–¥—ñ–ª–µ–Ω–Ω—è) ---
                    event.preventDefault();
                    event.stopPropagation();
                    
                    selectedNodesForEdge.add(clickedNodeId);
                    // –û–Ω–æ–≤–ª—é—î–º–æ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è –≤—ñ–∑—É–∞–ª—å–Ω–æ
                    nodeGroup.selectAll('.node').classed('selected', n => selectedNodesForEdge.has(n.id));

                    if (selectedNodesForEdge.size === 2) {
                        const [id1, id2] = Array.from(selectedNodesForEdge);
                        
                        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —á–∏ —Ä–µ–±—Ä–æ –≤–∂–µ —ñ—Å–Ω—É—î
                        const exists = d3Edges.some(e => (e.source.id === id1 && e.target.id === id2) || (e.source.id === id2 && e.target.id === id1));
                        
                        if (!exists) {
                            const newEdgeId = `e_${Date.now()}`;
                            const newEdge = { 
                                id: newEdgeId, 
                                source: d3Nodes.find(n => n.id === id1), 
                                target: d3Nodes.find(n => n.id === id2) 
                            };
                            
                            // –î–æ–¥–∞—î–º–æ —Ä–µ–±—Ä–æ –¥–æ –í–°–Ü–• –¥–∂–µ—Ä–µ–ª
                            d3Edges.push(newEdge); 
                            mainGraph.edges.push({ source: id1, target: id2 });
                            planarityState.originalGraphD3.edges.push({ id: newEdgeId, source: {id: id1}, target: {id: id2} });
                            initPlanaritySimulation(d3Nodes, d3Edges);
                            runPlanarityTest(); // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –∑–Ω—ñ–º–µ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è
                        } else {
                             selectedNodesForEdge.clear();
                             nodeGroup.selectAll('.node').classed('selected', false);
                        }
                    }
                } else {
                    // –ü—Ä–æ—Å—Ç–∏–π –∫–ª—ñ–∫ (–±–µ–∑ Shift/Ctrl) –∑–Ω—ñ–º–∞—î –≤–∏–¥—ñ–ª–µ–Ω–Ω—è
                    selectedNodesForEdge.clear();
                    nodeGroup.selectAll('.node').classed('selected', false);
                }
            });

            // 3. –ö–ª—ñ–∫ –Ω–∞ –†–µ–±—Ä—ñ (–í–∏–¥–∞–ª–∏—Ç–∏)
            linkGroup.on('click', (event) => {
                const d = d3.select(event.target.closest('.edge'))?.datum();
                if (!d) return; // –ö–ª—ñ–∫–Ω—É–ª–∏ –Ω–µ –Ω–∞ —Ä–µ–±—Ä–æ

                if (currentStage !== 'planarity' || physicsEnabled === true || !event.ctrlKey) return;
                
                event.preventDefault();
                event.stopPropagation();

                const edgeIdToDelete = d.id;
                const sourceId = d.source.id;
                const targetId = d.target.id;

                // –í–∏–¥–∞–ª—è—î–º–æ –∑ —É—Å—ñ—Ö –¥–∂–µ—Ä–µ–ª
                d3Edges = d3Edges.filter(e => e.id !== edgeIdToDelete);
                mainGraph.edges = mainGraph.edges.filter(e => !((e.source === sourceId && e.target === targetId) || (e.source === targetId && e.target === sourceId)));
                planarityState.originalGraphD3.edges = planarityState.originalGraphD3.edges.filter(e => e.id !== edgeIdToDelete);
                initPlanaritySimulation(d3Nodes, d3Edges);
                runPlanarityTest(); // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞—î–º–æ
            });
			
				
            simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(edges).id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-400))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(NODE_RADIUS * 2.5))
                .on("tick", ticked);
                
            initNodeDrag(nodes);
            return simulation;
        }
        
        // --- Toggle physics —Ç–∞ –æ–Ω–æ–≤–ª–µ–Ω—ñ drag-—Ö–µ–Ω–¥–ª–µ—Ä–∏ ---
        let physicsEnabled = true;

        if (!togglePhysicsBtn.empty()) {
            togglePhysicsBtn.on("click", () => {
                physicsEnabled = !physicsEnabled;

                if (physicsEnabled) {
                    // –£–≤—ñ–º–∫–Ω—É—Ç–∏ —Å–∏–ª–∏ –∑ –ø–æ—Ç—Ä—ñ–±–Ω–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
                    simulation.force("charge", d3.forceManyBody().strength(-400));
                    simulation.force("link", d3.forceLink(d3Edges).id(d => d.id).distance(100).strength(1));
                    simulation.force("collision", d3.forceCollide().radius(NODE_RADIUS * 2.5));
                    
                    // –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø 2: –ó–º–µ–Ω—à—É—î–º–æ "–ø–æ—à—Ç–æ–≤—Ö" –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫—É
                    simulation.alpha(0.1).restart(); 
                    
                    togglePhysicsBtn.text("üîå –í–∏–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É");
                } else {
                    // –í–∏–º–∫–Ω—É—Ç–∏ –≤–ø–ª–∏–≤ —Å–∏–ª
                    simulation.force("charge", d3.forceManyBody().strength(0));
                    simulation.force("link", d3.forceLink(d3Edges).id(d => d.id).distance(100).strength(() => 0));
                    simulation.force("collision", null);

                    simulation.alpha(0);
                    simulation.stop();

                    togglePhysicsBtn.text("‚ö° –£–≤—ñ–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É");
                }
            });
        }

        // –û–Ω–æ–≤–ª–µ–Ω—ñ drag-—Ö–µ–Ω–¥–ª–µ—Ä–∏
        function initNodeDrag(nodes) {
            const drag = d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
            
            nodeGroup.selectAll('.node')
                .data(nodes, d => d.id)
                .call(drag);
        }

        function dragstarted(event, d) {
            // –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø 3: –î–æ–∑–≤–æ–ª—è—î–º–æ –ø–µ—Ä–µ—Ç—è–≥—É–≤–∞–Ω–Ω—è –Ω–∞ –≤—Å—ñ—Ö –µ—Ç–∞–ø–∞—Ö
            // (–í–∏–¥–∞–ª–µ–Ω–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É: currentStage === 'tutte' && !d.isOuter)

            if (physicsEnabled && simulation && simulation.alpha() > 0) {
                 if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            } else if (tutteSimulation) { // –û–∫—Ä–µ–º–∏–π –æ–±—Ä–æ–±–Ω–∏–∫ –¥–ª—è —Ñ—ñ–∑–∏–∫–∏ –¢—É—Ç—Ç–µ
                 if (!event.active) tutteSimulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            else {
                // —Ñ—ñ–∑–∏–∫–∞ –≤–∏–º–∫–Ω–µ–Ω–∞
                d.fx = d.x;
                d.fy = d.y;
            }
        }

        function dragged(event, d) {
            // –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø 3: –î–æ–∑–≤–æ–ª—è—î–º–æ –ø–µ—Ä–µ—Ç—è–≥—É–≤–∞–Ω–Ω—è –Ω–∞ –≤—Å—ñ—Ö –µ—Ç–∞–ø–∞—Ö
            // (–í–∏–¥–∞–ª–µ–Ω–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É: currentStage === 'tutte' && !d.isOuter)

            if (physicsEnabled && simulation && simulation.alpha() > 0) {
                d.fx = event.x;
                d.fy = event.y;
            } else if (tutteSimulation) { // –û–∫—Ä–µ–º–∏–π –æ–±—Ä–æ–±–Ω–∏–∫ –¥–ª—è —Ñ—ñ–∑–∏–∫–∏ –¢—É—Ç—Ç–µ
                d.fx = event.x;
                d.fy = event.y;
            }
            else {
                // —Ñ—ñ–∑–∏–∫–∞ –≤–∏–º–∫–Ω–µ–Ω–∞
                d.x = event.x;
                d.y = event.y;
                d.fx = event.x;
                d.fy = event.y;
                
                // —Ä—É—á–Ω–∏–π "—Ç–∏–∫"
                if (currentStage === 'tutte') {
                    updateTutteView(); // –¢—É—Ç—Ç–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î –≤–ª–∞—Å–Ω–∏–π –∞–ø–¥–µ–π—Ç–µ—Ä
                } else {
                    ticked(); // –ï—Ç–∞–ø–∏ 1-2 –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å –∑–∞–≥–∞–ª—å–Ω–∏–π
                }
            }
        }

        function dragended(event, d) {
            // –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø 3: –î–æ–∑–≤–æ–ª—è—î–º–æ –ø–µ—Ä–µ—Ç—è–≥—É–≤–∞–Ω–Ω—è –Ω–∞ –≤—Å—ñ—Ö –µ—Ç–∞–ø–∞—Ö
            // (–í–∏–¥–∞–ª–µ–Ω–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É: currentStage === 'tutte' && !d.isOuter)

            if (physicsEnabled && simulation && simulation.alpha() > 0) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            } else if (tutteSimulation) { // –û–∫—Ä–µ–º–∏–π –æ–±—Ä–æ–±–Ω–∏–∫ –¥–ª—è —Ñ—ñ–∑–∏–∫–∏ –¢—É—Ç—Ç–µ
                 if (!event.active) tutteSimulation.alphaTarget(0);
                 if (d.isOuter) { // –ó–æ–≤–Ω—ñ—à–Ω—ñ –∑–∞–≤–∂–¥–∏ —Ñ—ñ–∫—Å–æ–≤–∞–Ω—ñ —É –¢—É—Ç—Ç–µ
                    d.fx = d.x;
                    d.fy = d.y;
                 } else {
                    d.fx = null;
                    d.fy = null;
                 }
            }
            else {
                // —Ñ—ñ–∑–∏–∫–∞ –≤–∏–º–∫–Ω–µ–Ω–∞
                d.fx = null;
                d.fy = null;
            }
        }

        function ticked() {
            // –û–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–æ–∑–∏—Ü—ñ–π –≤–µ—Ä—à–∏–Ω
            nodeGroup.selectAll('.node')
                .attr("transform", d => `translate(${d.x},${d.y})`);
            
            labelGroup.selectAll('.node-label')
                .attr("transform", d => `translate(${d.x},${d.y})`);

            // –û–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–æ–∑–∏—Ü—ñ–π –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏—Ö —Ä–µ–±–µ—Ä
            // (d.source - —Ü–µ –æ–±'—î–∫—Ç –≤—É–∑–ª–∞)
            linkGroup.selectAll('.edge')
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
            
            // –û–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–æ–∑–∏—Ü—ñ–π –Ω–æ–≤–∏—Ö —Ä–µ–±–µ—Ä (–¥–ª—è –µ—Ç–∞–ø—É 1)
            newEdgeGroup.selectAll('.edge-new')
                .attr("x1", d => d3Nodes.find(n => n.id === d.source).x)
                .attr("y1", d => d3Nodes.find(n => n.id === d.source).y)
                .attr("x2", d => d3Nodes.find(n => n.id === d.target).x)
                .attr("y2", d => d3Nodes.find(n => n.id === d.target).y);
            
             // –û–Ω–æ–≤–ª–µ–Ω–Ω—è –∫–ª–∞—Å—Ç–µ—Ä—ñ–≤ (–¥–ª—è –¢—É—Ç—Ç–µ)
            tutteClusterGroup.selectAll('.tutte-cluster-path')
                .attr('d', d => {
                    const points = d.nodeIds
                        .map(id => d3Nodes.find(n => n.id === id))
                        .filter(Boolean) // –§—ñ–ª—å—Ç—Ä—É—î–º–æ, —è–∫—â–æ –≤—É–∑–æ–ª –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ
                        .map(n => [n.x, n.y]);
                    if (points.length < 3) return null; // –ü–æ—Ç—Ä—ñ–±–Ω–æ 3+ —Ç–æ—á–∫–∏ –¥–ª—è –æ–±–æ–ª–æ–Ω–∫–∏
                    return d3.polygonHull(points);
                });
            
             tutteClusterGroup.selectAll('.tutte-cluster-label')
                 .attr('x', d => {
                    const points = d.nodeIds
                        .map(id => d3Nodes.find(n => n.id === id))
                        .filter(Boolean);
                    if (points.length === 0) return 0;
                    return d3.mean(points, p => p.x);
                 })
                 .attr('y', d => {
                    const points = d.nodeIds
                        .map(id => d3Nodes.find(n => n.id === id))
                        .filter(Boolean);
                    if (points.length === 0) return 0;
                    return d3.mean(points, p => p.y);
                 });
        }


        // ====================================================================
        // --- –ï–¢–ê–ü 1: –ü–õ–ê–ù–ê–†–ù–Ü–°–¢–¨ ---
        // ====================================================================

        genPlanarBtn.on('click', () => generatePlanarityGraph('planar'));
        genPlanar2CutBtn.on('click', () => generatePlanarityGraph('planar-2cut'));
        genIcosahedronBtn.on('click', () => generatePlanarityGraph('icosahedron')); // –î–û–î–ê–ù–û
        genK5Btn.on('click', () => generatePlanarityGraph('k5'));
        genK33Btn.on('click', () => generatePlanarityGraph('k33'));
        genHomeoK5Btn.on('click', () => generatePlanarityGraph('homeo-k5'));
        genRandomBtn.on('click', () => generatePlanarityGraph('random'));

        function generatePlanarityGraph(type) {
            let nodes = [];
            let edges = [];
            
            switch(type) {
                case 'planar': //–Ω–∞—Å–ø—Ä–∞–≤–¥—ñ –Ω—ñ, —Ü–µ –ì—Ä–∞—Ñ –ü–µ—Ç–µ—Ä—Å–æ–Ω–∞
                    nodes = Array.from({length: 10}, (_, i) => ({ id: i + 1 }));
                    edges = [
                        {source: 1, target: 2}, {source: 2, target: 3}, {source: 3, target: 4}, {source: 4, target: 5}, {source: 5, target: 1},
                        {source: 9, target: 7}, {source: 9, target: 6}, {source: 8, target: 6}, {source: 8, target: 10}, {source: 10, target: 7},
                        {source: 1, target: 6}, {source: 2, target: 7}, {source: 3, target: 8}, {source: 4, target: 9}, {source: 5, target: 10}
                    ];
                    break;
                
                case 'planar-2cut': // –ü–ª–∞–Ω–∞—Ä–Ω–∏–π, –∞–ª–µ –∑ 2-—Ä–æ–∑–¥—ñ–ª—é–≤–∞—á–µ–º (–Ω–µ 3-–∑–≤'—è–∑–Ω–∏–π)
                    nodes = Array.from({length: 8}, (_, i) => ({ id: i + 1 }));
                    edges = [
                        {source: 1, target: 2}, {source: 2, target: 3}, {source: 3, target: 1},
                 
                        {source: 1, target: 3}, {source: 3, target: 4}, {source: 4, target: 1},
                        // "–ú—ñ—Å—Ç"
                        {source: 1, target: 5}, {source: 3, target: 6},
                      
                        {source: 5, target: 6}, {source: 6, target: 7}, {source: 7, target: 5},
                     
                        {source: 5, target: 7}, {source: 7, target: 8}, {source: 8, target: 5},
						{source: 6, target: 8}, {source: 2, target: 4} 
                    ];
                    break;
                
                // –î–û–î–ê–ù–û –ù–û–í–ò–ô –ü–†–ï–°–ï–¢
                case 'icosahedron': // –Ü–∫–æ—Å–∞–µ–¥—Ä (–º—ñ–Ω—É—Å –æ–¥–Ω–∞ –≤–µ—Ä—à–∏–Ω–∞). –ü–ª–∞–Ω–∞—Ä–Ω–∏–π, 3-–∑–≤'—è–∑–Ω–∏–π.
                    nodes = Array.from({length: 11}, (_, i) => ({ id: i + 1 }));
                    edges = [
                        // –í–µ—Ä—Ö–Ω—è "—à–∞–ø–∫–∞" (v1)
                        {source: 1, target: 2}, {source: 1, target: 3}, {source: 1, target: 4}, {source: 1, target: 5}, {source: 1, target: 6},
                        // –°–µ—Ä–µ–¥–Ω—î –∫—ñ–ª—å—Ü–µ (v2-v6)
                        {source: 2, target: 3}, {source: 3, target: 4}, {source: 4, target: 5}, {source: 5, target: 6}, {source: 6, target: 2},
                        // –†–µ–±—Ä–∞ –≤—ñ–¥ "—à–∞–ø–∫–∏" –¥–æ –Ω–∏–∂–Ω—å–æ–≥–æ –∫—ñ–ª—å—Ü—è
                        {source: 2, target: 7}, {source: 3, target: 8}, {source: 4, target: 9}, {source: 5, target: 10}, {source: 6, target: 11},
                        // "–î—ñ–∞–≥–æ–Ω–∞–ª—å–Ω—ñ" —Ä–µ–±—Ä–∞
                        {source: 2, target: 8}, {source: 3, target: 9}, {source: 4, target: 10}, {source: 5, target: 11}, {source: 6, target: 7},
                        // –ù–∏–∂–Ω—î –∫—ñ–ª—å—Ü–µ (v7-v11)
                        {source: 7, target: 8}, {source: 8, target: 9}, {source: 9, target: 10}, {source: 10, target: 11}, {source: 11, target: 7}
                    ];
                    break;

                case 'k5':
                    nodes = Array.from({length: 5}, (_, i) => ({ id: i + 1 }));
                    edges = [];
                    for (let i = 1; i <= 5; i++) {
                        for (let j = i + 1; j <= 5; j++) {
                            edges.push({source: i, target: j});
                        }
                    }
                    break;

                case 'k33':
                    nodes = Array.from({length: 6}, (_, i) => ({ id: i + 1 }));
                    edges = [];
                    for (let i = 1; i <= 3; i++) {
                        for (let j = 4; j <= 6; j++) {
                            edges.push({source: i, target: j});
                        }
                    }
                    break;
                
                case 'homeo-k5': // –ì–æ–º–µ–æ–º–æ—Ä—Ñ–Ω–∏–π K3,3 –∑ 7 –≤–µ—Ä—à–∏–Ω–∞–º–∏
                     nodes = Array.from({length: 7}, (_, i) => ({ id: i + 1 }));
                     edges = [
                        {source: 1, target: 4}, {source: 1, target: 5}, 
                        {source: 1, target: 7}, {source: 7, target: 6}, // —à–ª—è—Ö (1,7,6)
                        {source: 2, target: 4}, {source: 2, target: 5}, {source: 2, target: 6},
                        {source: 3, target: 4}, {source: 3, target: 5}, {source: 3, target: 6}
                     ]; // v=7, e=10. (3v-6 = 15). OK.
                    break;
                
                case 'random':
                default:
                    const nodeCount = parseInt(nodeCountInput.property('value'), 10);
                    const edgeProb = parseFloat(edgeProbInput.property('value'));
                    nodes = Array.from({length: nodeCount}, (_, i) => ({ id: i + 1 }));
                    edges = [];
                    for (let i = 1; i <= nodeCount; i++) {
                        for (let j = i + 1; j <= nodeCount; j++) {
                            if (Math.random() < edgeProb) {
                                edges.push({source: i, target: j});
                            }
                        }
                    }
                    break;
            }
            
            // –ù–∞–¥–∞—î–º–æ —Ä–µ–±—Ä–∞–º —É–Ω—ñ–∫–∞–ª—å–Ω—ñ ID –¥–ª—è D3
            edges.forEach((e, i) => e.id = `e${i}`);

            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –∫–æ–ø—ñ—é –¥–ª—è D3 —Å–∏–º—É–ª—è—Ü—ñ—ó
            d3Nodes = nodes.map(n => ({ ...n }));
            d3Edges = edges.map(e => ({ 
                id: e.id, 
                source: d3Nodes.find(n => n.id === e.source), 
                target: d3Nodes.find(n => n.id === e.target) 
            }));
            
            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –∫–æ–ø—ñ—é –¥–ª—è –ª–æ–≥—ñ–∫–∏
            planarityState.originalGraphD3 = {
                nodes: nodes.map(n => ({ id: n.id })),
                edges: edges.map(e => ({ id: e.id, source: {id: e.source}, target: {id: e.target} }))
            };
            
            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≥–æ–ª–æ–≤–Ω–∏–π –≥—Ä–∞—Ñ –¥–ª—è —ñ–Ω—à–∏—Ö –µ—Ç–∞–ø—ñ–≤
            mainGraph = {
                nodes: nodes.map(n => ({ id: n.id, x: 0, y: 0 })), // x, y –±—É–¥—É—Ç—å –∑–∞–ø–æ–≤–Ω–µ–Ω—ñ —Å–∏–º—É–ª—è—Ü—ñ—î—é
                edges: edges.map(e => ({ source: e.source, target: e.target }))
            };
            
            initPlanaritySimulation(d3Nodes, d3Edges);
            runPlanarityTest();
        }
        
        function setPlanarityButtonsDisabled(disabled) {
            nextBtn.property('disabled', disabled);
            prevBtn.property('disabled', disabled);
            allGenButtons.forEach(btn => btn.property('disabled', disabled));
        }

        async function runPlanarityTest() {
            setPlanarityButtonsDisabled(true);
            planarityState.steps = [];
            planarityState.currentStep = 0;
            
            const originalGraph = planarityState.originalGraphD3;
            
            // –°—Ç–≤–æ—Ä—é—î–º–æ –ª–æ–≥—ñ—á–Ω–∏–π –≥—Ä–∞—Ñ (—Ç—ñ–ª—å–∫–∏ ID)
            planarityLogic.logicalGraph = {
                nodes: originalGraph.nodes.map(n => n.id),
                edges: originalGraph.edges.map(e => ({source: e.source.id, target: e.target.id}))
            };
            
            // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î–º–æ –≤—ñ–∑—É–∞–ª—å–Ω—ñ —Å—Ç–∞–Ω–∏
            planarityLogic.currentVisuals = { nodes: {}, edges: {} };
            originalGraph.nodes.forEach(n => planarityLogic.currentVisuals.nodes[n.id] = 'normal');
            originalGraph.edges.forEach(e => planarityLogic.currentVisuals.edges[e.id] = 'normal');
            
            planarityLogic.currentNewEdges = [];
            
            planarityLogic.addStep("–ü–æ—á–∞—Ç–∫–æ–≤–∏–π –≥—Ä–∞—Ñ. –ü–æ—á–∏–Ω–∞—î–º–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É.");
            
            // –ó–∞–ø—É—Å–∫–∞—î–º–æ —Å–∏–º—É–ª—è—Ü—ñ—é, —â–æ–± –≤—É–∑–ª–∏ "—Ä–æ–∑—ñ–π—à–ª–∏—Å—è"
            simulation.alpha(0.3).restart();
            await new Promise(resolve => setTimeout(resolve, 500)); // –î–∞—î–º–æ —á–∞—Å

            let v = planarityLogic.logicalGraph.nodes.length;
            let e = planarityLogic.logicalGraph.edges.length;

            if (v < 3) {
                planarityLogic.addStep(`<span class="result planar">–ü–õ–ê–ù–ê–†–ù–ò–ô</span><br>–ì—Ä–∞—Ñ –º–∞—î –º–µ–Ω—à–µ 3 –≤–µ—Ä—à–∏–Ω.`, true, "v < 3");
                await finishPlanarityTest(true);
                return;
            }

            let eulerLimit = 3 * v - 6;
            if (e > eulerLimit) {
                let comment = `<span class="result non-planar">–ù–ï –ü–õ–ê–ù–ê–†–ù–ò–ô</span><br>–ü–æ—Ä—É—à–µ–Ω–æ —É–º–æ–≤—É –ï–π–ª–µ—Ä–∞: \\(e > 3v - 6\\).<br>\\(e = ${e}\\), \\(3v - 6 = ${3*v - 6}\\).`;
                planarityLogic.addStep(comment, false, "–ü–æ—Ä—É—à–µ–Ω–æ —É–º–æ–≤—É –ï–π–ª–µ—Ä–∞");
                await finishPlanarityTest(false);
                return;
            }
            
            planarityLogic.addStep(`–ö—Ä–æ–∫ 1: –£–º–æ–≤–∞ –ï–π–ª–µ—Ä–∞ \\(e \\le 3v - 6\\) –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è.<br>(\\( ${e} \\le ${eulerLimit} \\)). –ü–µ—Ä–µ—Ö–æ–¥–∏–º–æ –¥–æ –∑–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è.`);

            // –ö—Ä–æ–∫ 2: –ó–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è (–≤–∏–¥–∞–ª–µ–Ω–Ω—è –≤–µ—Ä—à–∏–Ω —Å—Ç–µ–ø–µ–Ω—è 2)
            let smoothingPerformed = false;
            let nodesToRemove = [];
            
            // –ó–±–∏—Ä–∞—î–º–æ –≤—Å—ñ—Ö –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤ –Ω–∞ –≤–∏–¥–∞–ª–µ–Ω–Ω—è
            planarityLogic.logicalGraph.nodes.forEach(nodeId => {
                if (planarityLogic.getDegree(nodeId, planarityLogic.logicalGraph) === 2) {
                    nodesToRemove.push(nodeId);
                }
            });

            if (nodesToRemove.length > 0) {
                 planarityLogic.addStep(`–ö—Ä–æ–∫ 2: –ó–Ω–∞–π–¥–µ–Ω–æ ${nodesToRemove.length} –≤–µ—Ä—à–∏–Ω —Å—Ç–µ–ø–µ–Ω—è 2. –ü–æ—á–∏–Ω–∞—î–º–æ –∑–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è...`);
            }

            // –û–±—Ä–æ–±–ª—è—î–º–æ –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤
            while(nodesToRemove.length > 0) {
                const nodeToRemove = nodesToRemove.shift();
                
                // –ú–æ–∂–ª–∏–≤–æ, —Å—Ç–µ–ø—ñ–Ω—å –∑–º—ñ–Ω–∏–≤—Å—è, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —â–µ —Ä–∞–∑
                if (planarityLogic.getDegree(nodeToRemove, planarityLogic.logicalGraph) !== 2) {
                    continue; 
                }

                smoothingPerformed = true;
                const neighbors = planarityLogic.getNeighbors(nodeToRemove, planarityLogic.logicalGraph);
                
                if (neighbors.length === 2) {
                    const [n1, n2] = neighbors;
                    
                    // –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è: –ø—ñ–¥—Å–≤—ñ—á—É—î–º–æ –≤—É–∑–æ–ª —Ç–∞ —Å—É—Å—ñ–¥—ñ–≤
                    Object.keys(planarityLogic.currentVisuals.nodes).forEach(k => planarityLogic.currentVisuals.nodes[k] = (planarityLogic.currentVisuals.nodes[k] === 'removed' ? 'removed' : 'normal'));
                    planarityLogic.currentVisuals.nodes[nodeToRemove] = 'flash';
                    planarityLogic.currentVisuals.nodes[n1] = 'highlight';
                    planarityLogic.currentVisuals.nodes[n2] = 'highlight';
                    
                    planarityLogic.logicalGraph.edges.forEach(e_orig => {
                        const e_id = planarityState.originalGraphD3.edges.find(e => (e.source.id === e_orig.source && e.target.id === e_orig.target) || (e.source.id === e_orig.target && e.target.id === e_orig.source))?.id;
                        if (!e_id) return;
                        
                        if (planarityLogic.currentVisuals.edges[e_id] !== 'removed') {
                           planarityLogic.currentVisuals.edges[e_id] = 'normal';
                        }
                    });
                    
                    // –í–∏–¥–∞–ª—è—î–º–æ –≤—É–∑–æ–ª —Ç–∞ 2 —ñ–Ω—Ü–∏–¥–µ–Ω—Ç–Ω—ñ —Ä–µ–±—Ä–∞
                    planarityLogic.logicalGraph.nodes = planarityLogic.logicalGraph.nodes.filter(id => id !== nodeToRemove);
                    
                    let removedEdges = [];
                    planarityLogic.logicalGraph.edges = planarityLogic.logicalGraph.edges.filter(edge => {
                        if (edge.source === nodeToRemove || edge.target === nodeToRemove) {
                            removedEdges.push(edge);
                            return false;
                        }
                        return true;
                    });
                    
                    // –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è
                    planarityLogic.currentVisuals.nodes[nodeToRemove] = 'removed';
                    removedEdges.forEach(e_rem => {
                        const e_id = planarityState.originalGraphD3.edges.find(e => (e.source.id === e_rem.source && e.target.id === e_rem.target) || (e.source.id === e_rem.target && e.target.id === e_rem.source))?.id;
                        if(e_id) planarityLogic.currentVisuals.edges[e_id] = 'removed';
                    });
                    
                    
                    // –î–æ–¥–∞—î–º–æ –Ω–æ–≤–µ —Ä–µ–±—Ä–æ (—è–∫—â–æ –π–æ–≥–æ —â–µ –Ω–µ–º–∞—î)
                    if (!planarityLogic.edgeExists(n1, n2, planarityLogic.logicalGraph)) {
                        planarityLogic.logicalGraph.edges.push({ source: n1, target: n2 });
                        
                        // –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –Ω–æ–≤–æ–≥–æ —Ä–µ–±—Ä–∞
                        let newEdge = { 
                            id: planarityLogic.edgeKey(n1, n2), 
                            source: n1, 
                            target: n2, 
                            class: 'highlight-new' 
                        };
                        planarityLogic.currentNewEdges.push(newEdge);
                        
                        planarityLogic.addStep(`–í–∏–¥–∞–ª–µ–Ω–æ ${nodeToRemove}. –°—Ç–≤–æ—Ä–µ–Ω–æ –Ω–æ–≤–µ —Ä–µ–±—Ä–æ (${n1}, ${n2}).`);
                        
                        // –ó–º—ñ–Ω—é—î–º–æ –∫–ª–∞—Å –¥–ª—è –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –∫—Ä–æ–∫—É
                        planarityLogic.currentNewEdges.find(e => e.id === newEdge.id).class = 'normal-new';

                    } else {
                        planarityLogic.addStep(`–í–∏–¥–∞–ª–µ–Ω–æ ${nodeToRemove}. –†–µ–±—Ä–æ (${n1}, ${n2}) –≤–∂–µ —ñ—Å–Ω—É—î.`);
                    }
                    
                    // –°–∫–∏–¥–∞—î–º–æ –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—é –≤—É–∑–ª—ñ–≤ (–æ–∫—Ä—ñ–º –≤–∏–¥–∞–ª–µ–Ω–∏—Ö)
                    planarityLogic.currentVisuals.nodes = Object.keys(planarityLogic.currentVisuals.nodes).reduce((acc, key) => {
                        if (planarityLogic.currentVisuals.nodes[key] !== 'removed') acc[key] = 'normal';
                        else acc[key] = 'removed';
                        return acc;
                    }, {});
                }
            }

            if (smoothingPerformed) {
                planarityLogic.addStep("–ö—Ä–æ–∫ 2: –ó–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ.");
            } else {
                planarityLogic.addStep("–ö—Ä–æ–∫ 2: –í–µ—Ä—à–∏–Ω —Å—Ç–µ–ø–µ–Ω—è 2 –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.");
            }
            
            // –°–∫–∏–¥–∞—î–º–æ –≤—Å—ñ –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó –¥–æ "normal"
            planarityLogic.currentNewEdges.forEach(e => e.class = 'normal-new');
            Object.keys(planarityLogic.currentVisuals.nodes).forEach(k => {
                if(planarityLogic.currentVisuals.nodes[k] !== 'removed') planarityLogic.currentVisuals.nodes[k] = 'normal';
            });
            Object.keys(planarityLogic.currentVisuals.edges).forEach(k => {
                if(planarityLogic.currentVisuals.edges[k] !== 'removed') planarityLogic.currentVisuals.edges[k] = 'normal';
            });


            // –ö—Ä–æ–∫ 3: –ü–æ—à—É–∫ –≥–æ–º–µ–æ–º–æ—Ä—Ñ–Ω–∏—Ö K5 —Ç–∞ K3,3
          //  planarityLogic.addStep("–ö—Ä–æ–∫ 3: –ü–æ—à—É–∫ –ø—ñ–¥–≥—Ä–∞—Ñ—ñ–≤, –≥–æ–º–µ–æ–º–æ—Ä—Ñ–Ω–∏—Ö K‚ÇÖ —Ç–∞ K‚ÇÉ,‚ÇÉ...<br><small>(–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è '–∂–∞–¥—ñ–±–Ω–∞' –µ–≤—Ä–∏—Å—Ç–∏–∫–∞. –í–æ–Ω–∞ –Ω—ñ–∫–æ–ª–∏ –Ω–µ –¥–∞—Å—Ç—å —Ö–∏–±–Ω–æ–≥–æ '–¢–∞–∫', –∞–ª–µ –º–æ–∂–µ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–∏ —Å–∫–ª–∞–¥–Ω–∏–π –≤–∏–ø–∞–¥–æ–∫, —è–∫ –≥—Ä–∞—Ñ –ü–µ—Ç–µ—Ä—Å–æ–Ω–∞)</small>");
            
			planarityLogic.addStep("–ö—Ä–æ–∫ 3: –ü–æ—à—É–∫ –ø—ñ–¥–≥—Ä–∞—Ñ—ñ–≤, –≥–æ–º–µ–æ–º–æ—Ä—Ñ–Ω–∏—Ö K‚ÇÖ —Ç–∞ K‚ÇÉ,‚ÇÉ...<br><small>(–ó–∞–ø—É—Å–∫ –ø–æ–≤–Ω–æ–≥–æ –ø–æ—à—É–∫—É –∑ –±–µ–∫—Ç—Ä–µ–∫—ñ–Ω–≥–æ–º. –¶–µ –º–æ–∂–µ –∑–∞–π–Ω—è—Ç–∏ 1-2 —Å–µ–∫—É–Ω–¥–∏...)</small>");
            // –ì–æ—Ç—É—î–º–æ —Å–ø–∏—Å–æ–∫ —Å—É–º—ñ–∂–Ω–æ—Å—Ç—ñ –¥–ª—è –∑–≥–ª–∞–¥–∂–µ–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞
            const adjList = buildAdjList(planarityLogic.logicalGraph);

            // –®—É–∫–∞—î–º–æ K5
            let k5Found = false;
            let k5Subgraph = null;
            
            let degreesAfterSmoothing = {};
            planarityLogic.logicalGraph.nodes.forEach(id => degreesAfterSmoothing[id] = (adjList[id] || []).length);
            
            let highDegreeNodes = planarityLogic.logicalGraph.nodes.filter(id => degreesAfterSmoothing[id] >= 4);

            if (highDegreeNodes.length >= 5) {
                planarityLogic.addStep(`–ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ ${highDegreeNodes.length} –≤–µ—Ä—à–∏–Ω –∑—ñ —Å—Ç–µ–ø–µ–Ω–µ–º ‚â•4 –Ω–∞ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å K‚ÇÖ...`);
                
                const combos5 = planarityLogic.getCombinations(highDegreeNodes, 5);
                
                for (const combo of combos5) {
                    const paths = findK5Paths(combo, planarityLogic.logicalGraph, adjList);
                    if (paths) {
                        k5Found = true;
                        k5Subgraph = { vertices: combo, paths: paths };
                        break;
                    }
                }
            }

            if (k5Found) {
                // –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –∑–Ω–∞–π–¥–µ–Ω–æ–≥–æ K5
                Object.keys(planarityLogic.currentVisuals.nodes).forEach(k => {
                    if(planarityLogic.currentVisuals.nodes[k] !== 'removed') planarityLogic.currentVisuals.nodes[k] = 'normal';
                });
                
                k5Subgraph.vertices.forEach(id => planarityLogic.currentVisuals.nodes[id] = 'highlight');
                
                // –§–∞—Ä–±—É—î–º–æ –≤—Å—ñ —Ä–µ–±—Ä–∞/—à–ª—è—Ö–∏
                Object.values(k5Subgraph.paths).forEach(path => {
                    for(let i = 0; i < path.length - 1; i++) {
                        planarityLogic.highlightPathSegment(path[i], path[i+1]);
                    }
                });
                
                planarityLogic.addStep(`<span class="result non-planar">–ù–ï –ü–õ–ê–ù–ê–†–ù–ò–ô</span><br>–ó–Ω–∞–π–¥–µ–Ω–æ –ø—ñ–¥–≥—Ä–∞—Ñ, –≥–æ–º–µ–æ–º–æ—Ä—Ñ–Ω–∏–π K‚ÇÖ.`, false, "–ó–Ω–∞–π–¥–µ–Ω–æ K5");
                await finishPlanarityTest(false);
                return;
            }

            // –®—É–∫–∞—î–º–æ K3,3
            let k33Found = false;
            let k33Subgraph = null;
            
            let mediumDegreeNodes = planarityLogic.logicalGraph.nodes.filter(id => degreesAfterSmoothing[id] >= 3);
            
            if (mediumDegreeNodes.length >= 6) {
                planarityLogic.addStep(`–ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ ${mediumDegreeNodes.length} –≤–µ—Ä—à–∏–Ω –∑—ñ —Å—Ç–µ–ø–µ–Ω–µ–º ‚â•3 –Ω–∞ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å K‚ÇÉ,‚ÇÉ...`);
                
                const combos6 = planarityLogic.getCombinations(mediumDegreeNodes, 6);
                
                comboLoop:
                for (const combo of combos6) {
                    // –î—ñ–ª–∏–º–æ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—é 6 –≤–µ—Ä—à–∏–Ω –Ω–∞ 2 –ø–æ 3 (10 –≤–∞—Ä—ñ–∞–Ω—Ç—ñ–≤)
                    const splits = planarityLogic.getCombinations(combo, 3);
                    
                    for (const setA of splits) {
                        const setB = combo.filter(id => !setA.includes(id));
                        
                        const paths = findK33Paths(setA, setB, planarityLogic.logicalGraph, adjList);
                        if (paths) {
                            k33Found = true;
                            k33Subgraph = { A: setA, B: setB, paths: paths };
                            break comboLoop;
                        }
                    }
                }
            }

            if (k33Found) {
                // –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –∑–Ω–∞–π–¥–µ–Ω–æ–≥–æ K3,3
                Object.keys(planarityLogic.currentVisuals.nodes).forEach(k => {
                    if(planarityLogic.currentVisuals.nodes[k] !== 'removed') planarityLogic.currentVisuals.nodes[k] = 'normal';
                });
                
                k33Subgraph.A.forEach(id => planarityLogic.currentVisuals.nodes[id] = 'highlight');
                k33Subgraph.B.forEach(id => planarityLogic.currentVisuals.nodes[id] = 'highlight-secondary');
                
                Object.values(k33Subgraph.paths).forEach(path => {
                    for(let i = 0; i < path.length - 1; i++) {
                        planarityLogic.highlightPathSegment(path[i], path[i+1]);
                    }
                });

                planarityLogic.addStep(`<span class="result non-planar">–ù–ï –ü–õ–ê–ù–ê–†–ù–ò–ô</span><br>–ó–Ω–∞–π–¥–µ–Ω–æ –ø—ñ–¥–≥—Ä–∞—Ñ, –≥–æ–º–µ–æ–º–æ—Ä—Ñ–Ω–∏–π K‚ÇÉ,‚ÇÉ.`, false, "–ó–Ω–∞–π–¥–µ–Ω–æ K3,3");
                await finishPlanarityTest(false);
                return;
            }

            // –Ø–∫—â–æ –Ω—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ
            //planarityLogic.addStep(`<span class="result planar">–ü–õ–ê–ù–ê–†–ù–ò–ô</span><br>K‚ÇÖ —Ç–∞ K‚ÇÉ,‚ÇÉ (–≥–æ–º–µ–æ–º–æ—Ä—Ñ–Ω—ñ) –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.<br><small>(–ê–±–æ –µ–≤—Ä–∏—Å—Ç–∏–∫–∞ –Ω–µ –∑–º–æ–≥–ª–∞ —ó—Ö –∑–Ω–∞–π—Ç–∏, —è–∫ —É –≥—Ä–∞—Ñ—ñ –ü–µ—Ç–µ—Ä—Å–æ–Ω–∞).</small>`, true, "–ü—Ä–æ–π—à–æ–≤ –µ–≤—Ä–∏—Å—Ç–∏—á–Ω—ñ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏");
     planarityLogic.addStep(`<span class="result planar">–ü–õ–ê–ù–ê–†–ù–ò–ô</span><br>K‚ÇÖ —Ç–∞ K‚ÇÉ,‚ÇÉ (–≥–æ–º–µ–æ–º–æ—Ä—Ñ–Ω—ñ) –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –ú–æ–∂–µ—Ç–µ —Å–ø—Ä–æ–±—É–≤–∞—Ç–∏ —É–∫–ª–∞—Å—Ç–∏ –π–æ–≥–æ –±–µ–∑ –ø–µ—Ä–µ—Ç–∏–Ω—ñ–≤ –≤—Ä—É—á–Ω—É (–ø—Ä–∏ –≤—ñ–¥–∫–ª—é—á–µ–Ω—ñ–π "—Ñ—ñ–∑–∏—Ü—ñ")`, true, "–ü—Ä–æ–π—à–æ–≤ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É");
	 await finishPlanarityTest(true);

        }

        const planarityLogic = {
            logicalGraph: { nodes: [], edges: [] },
            currentVisuals: { nodes: {}, edges: {} },
            currentNewEdges: [],
            
            addStep: function(comment, isPlanar = null, reason = "") {
                const step = {
                    commentary: comment,
                    logicalGraph: JSON.parse(JSON.stringify(planarityLogic.logicalGraph)),
                    visuals: JSON.parse(JSON.stringify(planarityLogic.currentVisuals)),
                    newEdges: JSON.parse(JSON.stringify(planarityLogic.currentNewEdges)),
                    isPlanar: isPlanar,
                    reason: reason
                };
                planarityState.steps.push(step);
                
                // –û–¥—Ä–∞–∑—É –æ–Ω–æ–≤–ª—é—î–º–æ –≤–∏–≥–ª—è–¥, —â–æ–± –ø–æ–∫–∞–∑–∞—Ç–∏ –∫—Ä–æ–∫
                planarityState.currentStep = planarityState.steps.length - 1;
                updatePlanarityView();
            },
            
            getDegree: function(nodeId, g) {
                return g.edges.reduce((acc, edge) => (edge.source === nodeId || edge.target === nodeId) ? acc + 1 : acc, 0);
            },
            
            getNeighbors: function(nodeId, g) {
                const neighbors = new Set();
                g.edges.forEach(edge => {
                    if(edge.source === nodeId) neighbors.add(edge.target);
                    if(edge.target === nodeId) neighbors.add(edge.source);
                });
                return Array.from(neighbors);
            },
            
            edgeExists: function(n1, n2, g) {
                return g.edges.some(e => (e.source === n1 && e.target === n2) || (e.source === n2 && e.target === n1));
            },
            
            edgeKey: (id1, id2) => id1 < id2 ? `${id1}-${id2}` : `${id2}-${id1}`,
            
            highlightPathSegment: function(n1, n2) {
                const key = planarityLogic.edgeKey(n1, n2);
                
                // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ü–µ "–Ω–æ–≤–µ" —Ä–µ–±—Ä–æ
                const newEdge = planarityLogic.currentNewEdges.find(e => e.id === key);
                if (newEdge) {
                    newEdge.class = 'highlight'; // –∞–±–æ 'edge-new highlight'
                    return;
                }
                
                // –Ü–Ω–∞–∫—à–µ, —à—É–∫–∞—î–º–æ –≤ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏—Ö —Ä–µ–±—Ä–∞—Ö
                const origEdge = planarityState.originalGraphD3.edges.find(e => 
                    (e.source.id === n1 && e.target.id === n2) || (e.source.id === n2 && e.target.id === n1)
                );
                if (origEdge) {
                    if (planarityLogic.currentVisuals.edges[origEdge.id] !== 'removed') {
                         planarityLogic.currentVisuals.edges[origEdge.id] = 'highlight';
                    }
                }
            },

            getCombinations: function(arr, k) {
                if (k === 0) return [[]];
                if (k > arr.length) return [];
                
                const first = arr[0];
                const rest = arr.slice(1);
                
                const combosWithFirst = planarityLogic.getCombinations(rest, k - 1).map(combo => [first, ...combo]);
                const combosWithoutFirst = planarityLogic.getCombinations(rest, k);
                
                return [...combosWithFirst, ...combosWithoutFirst];
            }
        };

        //
        // !!! –¶–Ø –§–£–ù–ö–¶–Ü–Ø –û–ù–û–í–õ–ï–ù–ê (–ü–†–ò–ë–†–ê–ù–û –ê–í–¢–û-–ü–ï–†–ï–•–Ü–î) !!!
        //
        async function finishPlanarityTest(isPlanar) {
            await new Promise(resolve => setTimeout(resolve, 100)); // –î–∞—î–º–æ —á–∞—Å –Ω–∞ —Ä–µ–Ω–¥–µ—Ä
            
            setPlanarityButtonsDisabled(false);
            
            updatePlanarityView(); // –û–Ω–æ–≤–ª—é—î–º–æ –¥–æ –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ –∫—Ä–æ–∫—É
            
            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ–∑–∏—Ü—ñ—ó –≤—É–∑–ª—ñ–≤ –∑ —Å–∏–º—É–ª—è—Ü—ñ—ó –≤ mainGraph
            d3Nodes.forEach(d3Node => {
                const mainNode = mainGraph.nodes.find(n => n.id === d3Node.id);
                if (mainNode) {
                    mainNode.x = d3Node.x;
                    mainNode.y = d3Node.y;
                }
            });
            
            if (isPlanar) {
                tabStage1.classed('completed', true).classed('failed', false);
                tabStage2.classed('enabled', true);
                
                // !!! –ü–†–ò–ë–†–ê–ù–û –ê–í–¢–û–ú–ê–¢–ò–ß–ù–ò–ô –ü–ï–†–ï–•–Ü–î !!!
                // switchStage('connectivity');

            } else {
                tabStage1.classed('completed', false).classed('failed', true);
                tabStage2.classed('enabled', false);
            }
			
			// –ì–∞—Ä–∞–Ω—Ç—É—î–º–æ, —â–æ —è–∫—â–æ —Ñ—ñ–∑–∏–∫–∞ –±—É–ª–∞ –≤–∏–º–∫–Ω–µ–Ω–∞, 
            // –≤–æ–Ω–∞ –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è –≤–∏–º–∫–Ω–µ–Ω–æ—é (–æ—Å–∫—ñ–ª—å–∫–∏ runPlanarityTest —ó—ó –∑–∞–ø—É—Å–∫–∞—î)
            if (physicsEnabled === false && simulation) {
                simulation.force("charge", d3.forceManyBody().strength(0));
                simulation.force("link", d3.forceLink(d3Edges).id(d => d.id).distance(100).strength(() => 0));
                simulation.force("collision", null);
                simulation.alpha(0).stop();
                // "–ó–∞–º–æ—Ä–æ–∂—É—î–º–æ" –≤—É–∑–ª–∏ –Ω–∞ —ó—Ö –º—ñ—Å—Ü—è—Ö
                d3Nodes.forEach(n => { 
                    n.fx = n.x; 
                    n.fy = n.y; 
                });
            }
        }
        
        function initPlanaritySimulation(nodes, edges) {
            // d3Nodes = nodes; // –í–∂–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ
            // d3Edges = edges; // –í–∂–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ
            
            initBaseSimulation(nodes, edges);
        }

        //
        // !!! –¶–Ø –§–£–ù–ö–¶–Ü–Ø –û–ù–û–í–õ–ï–ù–ê (–í–ò–ü–†–ê–í–õ–ï–ù–û –†–ï–ë–†–ê) !!!
        //
        function updatePlanarityView() {
            if (planarityState.steps.length === 0) return;
            
            const step = planarityState.steps[planarityState.currentStep];
            if (!step) return;
            
            // const originalGraph = planarityState.originalGraphD3; // –ë—ñ–ª—å—à–µ –Ω–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ

            // 1. –û–Ω–æ–≤–ª—é—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω—ñ —Ä–µ–±—Ä–∞
            // !!! –í–ò–ü–†–ê–í–õ–ï–ù–û: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ d3Edges, —â–æ–± 'ticked' –ø—Ä–∞—Ü—é–≤–∞–≤
            linkGroup.selectAll('.edge')
                .data(d3Edges, d => d.id) // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ d3Edges
                .join('line')
                .attr('class', d => `edge ${step.visuals.edges[d.id] || 'normal'}`)
                // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ —Ç–µ–ø–µ—Ä –±—É–¥—É—Ç—å –æ–Ω–æ–≤–ª—é–≤–∞—Ç–∏—Å—è —Ñ—É–Ω–∫—Ü—ñ—î—é ticked()
                // –∞–ª–µ –º–∏ –≤—Å—Ç–∞–Ω–æ–≤–∏–º–æ —ó—Ö —Ç—É—Ç –¥–ª—è –ø–µ—Ä—à–æ–≥–æ –º–∞–ª—é–≤–∞–Ω–Ω—è
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);
                
            // 2. –û–Ω–æ–≤–ª—é—î–º–æ "–Ω–æ–≤—ñ" —Ä–µ–±—Ä–∞ (–∑—ñ –∑–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è)
            newEdgeGroup.selectAll('.edge-new')
                .data(step.newEdges, d => d.id)
                .join('line')
                .attr('class', d => `edge edge-new ${d.class || 'normal-new'}`)
                .attr('x1', d => d3Nodes.find(n => n.id === d.source).x)
                .attr('y1', d => d3Nodes.find(n => n.id === d.source).y)
                .attr('x2', d => d3Nodes.find(n => n.id === d.target).x)
                .attr('y2', d => d3Nodes.find(n => n.id === d.target).y);
            
            // 3. –û–Ω–æ–≤–ª—é—î–º–æ –≤—É–∑–ª–∏
            const nodeSelection = nodeGroup.selectAll('.node')
                .data(d3Nodes, d => d.id)
                .join('g')
                .attr('class', d => `node ${step.visuals.nodes[d.id] || 'normal'}`)
                .attr('transform', d => `translate(${d.x},${d.y})`);
            
            nodeSelection.selectAll('.node-circle')
                .data(d => [d])
                .join('circle')
                .attr('class', 'node-circle');
            
            // 4. –û–Ω–æ–≤–ª—é—î–º–æ –º—ñ—Ç–∫–∏
            labelGroup.selectAll('.node-label')
                .data(d3Nodes, d => d.id)
                .join('text')
                .attr('class', 'node-label')
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .text(d => d.id);
            
            // 5. –û–Ω–æ–≤–ª—é—î–º–æ drag-—Ö–µ–Ω–¥–ª–µ—Ä–∏
            initNodeDrag(d3Nodes);
            
            // 6. –û–Ω–æ–≤–ª—é—î–º–æ –∫–æ–º–µ–Ω—Ç–∞—Ä
            commentaryEl.html(step.commentary);
            if (window.MathJax && MathJax.typesetPromise) {
                MathJax.typesetPromise([commentaryEl.node()]).catch(err => console.error('MathJax Error:', err));
            }
            
            // 7. –û–Ω–æ–≤–ª—é—î–º–æ –∫–Ω–æ–ø–∫–∏
            prevBtn.property('disabled', planarityState.currentStep === 0);
            nextBtn.property('disabled', planarityState.currentStep === planarityState.steps.length - 1);
        }

        nextBtn.on('click', () => {
            if (planarityState.currentStep < planarityState.steps.length - 1) {
                planarityState.currentStep++;
                updatePlanarityView();
            }
        });
        
        prevBtn.on('click', () => {
            if (planarityState.currentStep > 0) {
                planarityState.currentStep--;
                updatePlanarityView();
            }
        });


        // ====================================================================
        // --- –ï–¢–ê–ü 2: 3-–ó–í'–Ø–ó–ù–Ü–°–¢–¨ ---
        // ====================================================================
        
        //
        // !!! –¶–Ø –§–£–ù–ö–¶–Ü–Ø –û–ù–û–í–õ–ï–ù–ê (–î–û–î–ê–ù–û updateConnectivityView) !!!
        //
        function initConnectivityStage() {
            // d3Nodes/d3Edges –≤–∂–µ –º–∞—é—Ç—å –±—É—Ç–∏ –≥–æ—Ç–æ–≤—ñ (–∑ switchStage)
            initConnectivitySimulation(d3Nodes, d3Edges);

            // !!! –î–û–î–ê–ù–û –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø: –ú–∞–ª—é—î–º–æ —Ä–µ–±—Ä–∞ –æ–¥—Ä–∞–∑—É !!!
            updateConnectivityView(mainGraph.nodes.map(n => n.id), []);

            startConnectivityTestBtn.property('disabled', false);
            tutteOptionsContainer.style('display', 'none').html('');
            connectivityCommentaryEl.html("–ì—Ä–∞—Ñ –ø–ª–∞–Ω–∞—Ä–Ω–∏–π. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É, —â–æ–± –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –π–æ–≥–æ –Ω–∞ 3-–∑–≤'—è–∑–Ω—ñ—Å—Ç—å.");
        }
        
        function initConnectivitySimulation(nodes, edges) {
            initBaseSimulation(nodes, edges);
            
            // –£–≤—ñ–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É –Ω–∞ –µ—Ç–∞–ø—ñ 2
            physicsEnabled = true;
            if (simulation) {
                simulation.alpha(0.3).restart();
            }
            togglePhysicsBtn.text("üîå –í–∏–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É").style('display', 'inline-block');
        }

     startConnectivityTestBtn.on('click', async () => {
            startConnectivityTestBtn.property('disabled', true);
            // –ó—É–ø–∏–Ω—è—î–º–æ —Å–∏–º—É–ª—è—Ü—ñ—é –∑ –ï—Ç–∞–ø—É 1, —è–∫—â–æ –≤–æ–Ω–∞ —â–µ –ø—Ä–∞—Ü—é—î
            if(simulation) {
                simulation.stop();
                simulation = null;
            }
            
            const graph = mainGraph;
            const adj = buildAdjList(graph);
            const nodeIds = graph.nodes.map(n => n.id);

            // --- 1. –ü–æ–∫—Ä–æ–∫–æ–≤–∞ –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ 1-–∑–≤'—è–∑–Ω—ñ—Å—Ç—å (–®–∞—Ä–Ω—ñ—Ä–∏) ---
            connectivityCommentaryEl.html("–ü–æ—á–∏–Ω–∞—î–º–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É –Ω–∞ 1-–∑–≤'—è–∑–Ω—ñ—Å—Ç—å (–ø–æ—à—É–∫ —à–∞—Ä–Ω—ñ—Ä—ñ–≤)...");
            await new Promise(resolve => setTimeout(resolve, 1000)); // –ü–æ—á–∞—Ç–∫–æ–≤–∞ –ø–∞—É–∑–∞

            let foundCutVertex = false;
            for (const nodeId of nodeIds) {
                const remainingNodes = nodeIds.filter(id => id !== nodeId);
                if (remainingNodes.length < 2) continue; // –ù–µ–º–∞—î —á–æ–≥–æ –ø–µ—Ä–µ–≤—ñ—Ä—è—Ç–∏

                // –ê–Ω—ñ–º–∞—Ü—ñ—è: "–í–∏–¥–∞–ª—è—î–º–æ" –≤—É–∑–æ–ª (—Ä–æ–±–∏–º–æ –π–æ–≥–æ 'removed')
                updateConnectivityView(remainingNodes, [nodeId]); 
                connectivityCommentaryEl.html(`–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ —à–∞—Ä–Ω—ñ—Ä: <strong>${nodeId}</strong>...`);
                
                await new Promise(resolve => setTimeout(resolve, 500)); // –ü–∞—É–∑–∞ –¥–ª—è –∞–Ω—ñ–º–∞—Ü—ñ—ó

                const { isConnected } = isGraphConnected(remainingNodes[0], remainingNodes, adj, new Set([nodeId]));
                
                if (!isConnected) {
                    foundCutVertex = true;
                    // –ó–Ω–∞–π—à–ª–∏! –ó–∞–ø—É—Å–∫–∞—î–º–æ —Ñ—ñ–Ω–∞–ª—å–Ω—É –∞–Ω—ñ–º–∞—Ü—ñ—é "—Ä–æ–∑–ø–∞–¥—É"
                    const components = await visualizeConnectivityFailure(
                        [nodeId], 
                        "–ù–ï 3-–ó–í'–Ø–ó–ù–ò–ô", 
                        `–ó–Ω–∞–π–¥–µ–Ω–æ —à–∞—Ä–Ω—ñ—Ä (cut-vertex): <strong>${nodeId}</strong>. –ì—Ä–∞—Ñ —î 1-–∑–≤'—è–∑–Ω–∏–º.`
                    );
                    tabStage2.classed('failed', true);
                    tabStage3.classed('enabled', true);
                    showTutteOptions(false, components); // –ü–æ–∫–∞–∑—É—î–º–æ –æ–ø—Ü—ñ—ó –¥–ª—è *–≤—Å—ñ—Ö* –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
                    return; // –ó–∞–≤–µ—Ä—à—É—î–º–æ —Ç–µ—Å—Ç
                }
            }
            
            if (!foundCutVertex) {
                connectivityCommentaryEl.html("–®–∞—Ä–Ω—ñ—Ä—ñ–≤ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –ì—Ä–∞—Ñ 2-–∑–≤'—è–∑–Ω–∏–π.");
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            // --- 2. –ü–æ–∫—Ä–æ–∫–æ–≤–∞ –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ 2-–∑–≤'—è–∑–Ω—ñ—Å—Ç—å (–ü–∞—Ä–∏-—Ä–æ–∑–¥—ñ–ª—é–≤–∞—á—ñ) ---
            connectivityCommentaryEl.html("–ü–æ—á–∏–Ω–∞—î–º–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É –Ω–∞ 2-–∑–≤'—è–∑–Ω—ñ—Å—Ç—å (–ø–æ—à—É–∫ –ø–∞—Ä-—Ä–æ–∑–¥—ñ–ª—é–≤–∞—á—ñ–≤)...");
            await new Promise(resolve => setTimeout(resolve, 1000));

            let foundSeparationPair = false;
            const nodePairs = planarityLogic.getCombinations(nodeIds, 2);
            
            // –ó–º–µ–Ω—à—É—î–º–æ –ø–∞—É–∑—É –¥–ª—è –ø–∞—Ä, –±–æ —ó—Ö –±–∞–≥–∞—Ç–æ
            const pairPause = Math.max(50, 5000 / nodePairs.length); // –ø—Ä–∏–±–ª. 5 —Å–µ–∫ –Ω–∞ –≤–µ—Å—å —Ç–µ—Å—Ç

            for (const pair of nodePairs) {
                const [u, v] = pair;
                const remainingNodes = nodeIds.filter(id => id !== u && id !== v);
                if (remainingNodes.length < 1) continue;
                
                // –ê–Ω—ñ–º–∞—Ü—ñ—è: "–í–∏–¥–∞–ª—è—î–º–æ" –ø–∞—Ä—É
                updateConnectivityView(remainingNodes, pair);
                connectivityCommentaryEl.html(`–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –ø–∞—Ä—É-—Ä–æ–∑–¥—ñ–ª—é–≤–∞—á: <strong>(${u}, ${v})</strong>...`);

                await new Promise(resolve => setTimeout(resolve, pairPause)); 

                const { isConnected } = isGraphConnected(remainingNodes[0], remainingNodes, adj, new Set([u, v]));
                
                if (!isConnected) {
                    foundSeparationPair = true;
                    // –ó–Ω–∞–π—à–ª–∏! –ó–∞–ø—É—Å–∫–∞—î–º–æ —Ñ—ñ–Ω–∞–ª—å–Ω—É –∞–Ω—ñ–º–∞—Ü—ñ—é "—Ä–æ–∑–ø–∞–¥—É"
                    const components = await visualizeConnectivityFailure(
                        pair, 
                        "–ù–ï 3-–ó–í'–Ø–ó–ù–ò–ô", 
                        `–ó–Ω–∞–π–¥–µ–Ω–æ –ø–∞—Ä—É-—Ä–æ–∑–¥—ñ–ª—é–≤–∞—á: <strong>${pair.join(', ')}</strong>. –ì—Ä–∞—Ñ —î 2-–∑–≤'—è–∑–Ω–∏–º.`
                    );
                    tabStage2.classed('failed', true);
                    tabStage3.classed('enabled', true);
                    showTutteOptions(false, components); // –ü–æ–∫–∞–∑—É—î–º–æ –æ–ø—Ü—ñ—ó –¥–ª—è *–≤—Å—ñ—Ö* –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
                    return; // –ó–∞–≤–µ—Ä—à—É—î–º–æ —Ç–µ—Å—Ç
                }
            }
            
            // --- 3. –£—Å–ø—ñ—Ö ---
            if (!foundSeparationPair) {
                connectivityCommentaryEl.html("<span class='result planar'>–ì–†–ê–§ 3-–ó–í'–Ø–ó–ù–ò–ô</span><br>–®–∞—Ä–Ω—ñ—Ä—ñ–≤ —Ç–∞ –ø–∞—Ä-—Ä–æ–∑–¥—ñ–ª—é–≤–∞—á—ñ–≤ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.");
                // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –≤—Å—ñ –≤—É–∑–ª–∏
                updateConnectivityView(nodeIds, []);
                tabStage2.classed('completed', true);
                tabStage3.classed('enabled', true);
                showTutteOptions(true, null);
            }
        });
        function isGraphConnected(startNode, nodePool, adj, removedNodes) {
            let count = 0;
            const visited = new Set();
            const stack = [startNode];
            visited.add(startNode);
            
            while(stack.length > 0) {
                const node = stack.pop();
                count++;
                
                const neighbors = adj[node] || [];
                for (const neighbor of neighbors) {
                    if (removedNodes.has(neighbor)) continue;
                    if (!visited.has(neighbor) && nodePool.includes(neighbor)) {
                        visited.add(neighbor);
                        stack.push(neighbor);
                    }
                }
            }
            return { isConnected: count === nodePool.length, count: count };
        }

        async function visualizeConnectivityFailure(removedNodes, title, commentary) {
            const removedSet = new Set(removedNodes);
            const remainingNodes = mainGraph.nodes.map(n => n.id).filter(id => !removedSet.has(id));
            const adj = buildAdjList(mainGraph);
            
            // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏
            let components = [];
            let visited = new Set();
            
            for (const nodeId of remainingNodes) {
                if (!visited.has(nodeId)) {
                    const { isConnected, count } = isGraphConnected(nodeId, remainingNodes, adj, removedSet);
                    // –ü–æ—Ç—Ä—ñ–±–Ω–æ –æ—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –≤—É–∑–ª—ñ–≤ —É –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ñ
                    const componentNodes = [];
                    const stack = [nodeId];
                    visited.add(nodeId);
                    componentNodes.push(nodeId);
                    
                    while(stack.length > 0) {
                        const node = stack.pop();
                        const neighbors = adj[node] || [];
                        for (const neighbor of neighbors) {
                            if (!removedSet.has(neighbor) && !visited.has(neighbor) && remainingNodes.includes(neighbor)) {
                                visited.add(neighbor);
                                stack.push(neighbor);
                                componentNodes.push(neighbor);
                            }
                        }
                    }
                    components.push(componentNodes);
                }
            }

            connectivityCommentaryEl.html(`<span class='result non-planar'>${title}</span><br>${commentary}`);
            
            // –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è
            updateConnectivityView(remainingNodes, removedNodes);
            
            // –ó—É–ø–∏–Ω—è—î–º–æ —Å—Ç–∞—Ä—É —Å–∏–º—É–ª—è—Ü—ñ—é
            if(simulation) simulation.stop();
            
            // –ù–æ–≤–∞ —Å–∏–º—É–ª—è—Ü—ñ—è –¥–ª—è "—Ä–æ–∑—Ç—è–≥—É–≤–∞–Ω–Ω—è"
            const visibleNodes = d3Nodes.filter(n => remainingNodes.includes(n.id));
            const visibleEdges = d3Edges.filter(e => 
                remainingNodes.includes(e.source.id) && remainingNodes.includes(e.target.id)
            );
            
            // –ù–∞–¥–∞—î–º–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º —Ä—ñ–∑–Ω—ñ —Å–∏–ª–∏
            const componentMap = new Map();
            components.forEach((comp, i) => {
                comp.forEach(nodeId => componentMap.set(nodeId, i));
            });

            // –°–∏–º—É–ª—è—Ü—ñ—è, —â–æ —Ä–æ–∑—Ç—è–≥—É—î –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏
            simulation = d3.forceSimulation(visibleNodes)
                .force("link", d3.forceLink(visibleEdges).id(d => d.id).strength(0.1))
                .force("charge", d3.forceManyBody().strength(-200))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("x", d3.forceX(d => componentMap.get(d.id) % 2 === 0 ? width/4 : 3*width/4).strength(0.1))
                .force("y", d3.forceY(d => componentMap.get(d.id) < 2 ? height/3 : 2*height/3).strength(0.1))
                .on("tick", ticked);
            
            physicsEnabled = true;
            togglePhysicsBtn.text("üîå –í–∏–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É").style('display', 'inline-block');
            
            return components;
        }
        
        function updateConnectivityView(visibleNodeIds, removedNodeIds) {
            const visibleSet = new Set(visibleNodeIds);
            const removedSet = new Set(removedNodeIds);
            
            // 1. –í–µ—Ä—à–∏–Ω–∏
            const nodes = nodeGroup.selectAll('.node')
                .data(d3Nodes, d => d.id)
                .join('g')
                .attr('class', d => {
                    let c = 'node ';
                    if (removedSet.has(d.id)) c += 'removed';
                    else if (visibleSet.has(d.id)) c += 'normal'; // 'normal'
                    return c;
                })
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .style('display', d => (visibleSet.has(d.id) || removedSet.has(d.id)) ? null : 'none');
                
            nodes.selectAll('.node-circle').data(d => [d]).join('circle').attr('class', 'node-circle');
            
            // 2. –ú—ñ—Ç–∫–∏
            labelGroup.selectAll('.node-label')
                .data(d3Nodes, d => d.id)
                .join('text')
                .attr('class', 'node-label')
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .text(d => d.id)
                .style('display', d => (visibleSet.has(d.id) || removedSet.has(d.id)) ? null : 'none');
            
            // 3. –†–µ–±—Ä–∞
            linkGroup.selectAll('.edge')
                .data(d3Edges, d => d.id)
                .join('line')
                .attr('class', d => {
                    let c = 'edge ';
                    if (removedSet.has(d.source.id) || removedSet.has(d.target.id)) c += 'removed';
                    return c;
                })
                .attr('x1', d => d.source.x) // d.source - —Ü–µ –æ–±'—î–∫—Ç
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y)
                .style('display', d => (visibleSet.has(d.source.id) && visibleSet.has(d.target.id)) || removedSet.has(d.source.id) || removedSet.has(d.target.id) ? null : 'none');
                
            initNodeDrag(d3Nodes);
        }

  function showTutteOptions(is3Connected, components) {
            tutteOptionsContainer.style('display', 'flex').html(''); // –û—á–∏—â—É—î–º–æ
            
            if (is3Connected) {
                tutteOptionsContainer.append('button')
                    .attr('class', 'success')
                    .text('–ó–∞–ø—É—Å—Ç–∏—Ç–∏ –£–∫–ª–∞–¥–∞–Ω–Ω—è –¢—É—Ç—Ç–µ ‚ñ∫')
                    .on('click', () => {
                        setupTutteLayout(mainGraph, '3-connected');
                    });
            } else {
                tutteOptionsContainer.append('h3')
                    .style('width', '100%')
                    .text('–ì—Ä–∞—Ñ –Ω–µ 3-–∑–≤\'—è–∑–Ω–∏–π. –û–±–µ—Ä—ñ—Ç—å –¥—ñ—é:');
                
                tutteOptionsContainer.append('button')
                    .attr('class', 'danger')
                    .text('–ü–æ–∫–∞–∑–∞—Ç–∏ –ö–æ–ª–∞–ø—Å (–Ω–∞ –≤—Å—å–æ–º—É –≥—Ä–∞—Ñ—ñ)')
                    .on('click', () => {
                        setupTutteLayout(mainGraph, 'collapse');
                    });
                
                // !!! –í–ò–ü–†–ê–í–õ–ï–ù–û: –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∑–≤'—è–∑–Ω—ñ—Å—Ç—å *–∫–æ–∂–Ω–æ–≥–æ* –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ !!!
                if (components && components.length > 0) {
                    
                    // –°–æ—Ä—Ç—É—î–º–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ (–Ω–∞–π–±—ñ–ª—å—à—ñ —Å–ø–æ—á–∞—Ç–∫—É)
                    components.sort((a, b) => b.length - a.length);

                    components.forEach((componentNodeIds, index) => {
                        // –ö–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ –º–∞—î –º–∞—Ç–∏ —Ö–æ—á–∞ –± 3 –≤—É–∑–ª–∏, —â–æ–± —ó—ó —É–∫–ª–∞—Å—Ç–∏
                        if (componentNodeIds.length > 2) {
                            
                            // !!! –ó–ê–ü–£–°–ö–ê–Ñ–ú–û –†–ï–ö–£–†–°–ò–í–ù–£ –ü–ï–†–ï–í–Ü–†–ö–£ !!!
                            const isComponentAlso3Connected = isComponent3Connected(componentNodeIds);

                            // –°—Ç–≤–æ—Ä—é—î–º–æ –º—ñ–Ω—ñ-–≥—Ä–∞—Ñ *–ª–∏—à–µ* –¥–ª—è —Ü—ñ—î—ó –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏
                            const componentGraph = {
                                nodes: mainGraph.nodes.filter(n => componentNodeIds.includes(n.id)),
                                edges: mainGraph.edges.filter(e => 
                                    componentNodeIds.includes(e.source) && componentNodeIds.includes(e.target)
                                )
                            };
                            
                            let buttonText = "";
                            let buttonClass = "";
                            
                            if (isComponentAlso3Connected) {
                                 buttonText = `–£–∫–ª–∞—Å—Ç–∏ –ö–æ–º–ø–æ–Ω–µ–Ω—Ç ${index + 1} (${componentNodeIds.length} –≤.) (3-–∑–≤'—è–∑–Ω–∏–π)`;
                                 buttonClass = "success"; // –ó–µ–ª–µ–Ω–∞ –∫–Ω–æ–ø–∫–∞
                            } else {
                                 buttonText = `–£–∫–ª–∞—Å—Ç–∏ –ö–æ–º–ø–æ–Ω–µ–Ω—Ç ${index + 1} (${componentNodeIds.length} –≤.) (–ê–ª–µ –≤—ñ–Ω —Ç–µ–∂ –ù–ï 3-–∑–≤'—è–∑–Ω–∏–π)`;
                                 buttonClass = "secondary"; // –°—ñ—Ä–∞ –∫–Ω–æ–ø–∫–∞
                            }
                            
                            tutteOptionsContainer.append('button')
                                .attr('class', buttonClass)
                                .text(buttonText)
                                .on('click', () => {
                                    // –ü–µ—Ä–µ–¥–∞—î–º–æ –ª–∏—à–µ –ø—ñ–¥-–≥—Ä–∞—Ñ
                                    // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ä–µ–∂–∏–º: —è–∫—â–æ –≤—ñ–Ω –Ω–µ 3-–∑–≤'—è–∑–Ω–∏–π, –≤—ñ–Ω –º–∞—î –∫–æ–ª–∞–ø—Å—É–≤–∞—Ç–∏
                                    const mode = isComponentAlso3Connected ? 'component' : 'collapse';
                                    setupTutteLayout(componentGraph, mode); 
                                });
                        }
                    });
                }
            }
        }


        /**
         * –ù–æ–≤–∞ –¥–æ–ø–æ–º—ñ–∂–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è: "—Ç–∏—Ö–æ" –ø–µ—Ä–µ–≤—ñ—Ä—è—î, —á–∏ —î –∫–æ–º–ø–æ–Ω–µ–Ω—Ç 3-–∑–≤'—è–∑–Ω–∏–º.
         * @param {Array<number>} componentNodeIds - –°–ø–∏—Å–æ–∫ ID –≤—É–∑–ª—ñ–≤ —É –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ñ.
         * @returns {boolean} - true, —è–∫—â–æ 3-–∑–≤'—è–∑–Ω–∏–π, false - –≤ —ñ–Ω—à–æ–º—É –≤–∏–ø–∞–¥–∫—É.
         */
        function isComponent3Connected(componentNodeIds) {
            if (componentNodeIds.length < 4) {
                // –ì—Ä–∞—Ñ –∑ 3 –∞–±–æ –º–µ–Ω—à–µ –≤–µ—Ä—à–∏–Ω–∞–º–∏ –Ω–µ –º–æ–∂–µ –º–∞—Ç–∏ —Ä–æ–∑–¥—ñ–ª—é–≤–∞—á—ñ–≤, 
                // –≤—ñ–Ω "—Ç—Ä–∏–≤—ñ–∞–ª—å–Ω–æ" 3-–∑–≤'—è–∑–Ω–∏–π –¥–ª—è –Ω–∞—à–∏—Ö —Ü—ñ–ª–µ–π (–∞–±–æ —î —Ü–∏–∫–ª–æ–º K3).
                return true; 
            }

            // 1. –°—Ç–≤–æ—Ä—é—î–º–æ –ø—ñ–¥-–≥—Ä–∞—Ñ (—Ç—ñ–ª—å–∫–∏ ID) —Ç–∞ —Å–ø–∏—Å–æ–∫ —Å—É–º—ñ–∂–Ω–æ—Å—Ç—ñ
            const subgraph = {
                nodes: componentNodeIds,
                edges: mainGraph.edges.filter(e => 
                    componentNodeIds.includes(e.source) && componentNodeIds.includes(e.target)
                )
            };
            const adj = buildAdjList(subgraph);
            const nodeIds = subgraph.nodes;
            
            if (nodeIds.length === 0 || !adj) return false; // –ó–∞–ø–æ–±—ñ–∂–Ω–∏–∫

            // 2. –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ 1-–∑–≤'—è–∑–Ω—ñ—Å—Ç—å (—à–∞—Ä–Ω—ñ—Ä–∏)
            for (const nodeId of nodeIds) {
                const remainingNodes = nodeIds.filter(id => id !== nodeId);
                if (remainingNodes.length < 2) continue;
                
                // –í–∞–∂–ª–∏–≤–æ: –ø–µ—Ä–µ–¥–∞—î–º–æ 'adj' –ø—ñ–¥-–≥—Ä–∞—Ñ–∞!
                const { isConnected } = isGraphConnected(remainingNodes[0], remainingNodes, adj, new Set([nodeId]));
                
                if (!isConnected) {
                    // console.log("–ó–Ω–∞–π–¥–µ–Ω–æ –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π —à–∞—Ä–Ω—ñ—Ä:", nodeId);
                    return false; // –ó–Ω–∞–π–¥–µ–Ω–æ —à–∞—Ä–Ω—ñ—Ä
                }
            }

            // 3. –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ 2-–∑–≤'—è–∑–Ω—ñ—Å—Ç—å (–ø–∞—Ä–∏-—Ä–æ–∑–¥—ñ–ª—é–≤–∞—á—ñ)
            const nodePairs = planarityLogic.getCombinations(nodeIds, 2);
            
            for (const pair of nodePairs) {
                const [u, v] = pair;
                const remainingNodes = nodeIds.filter(id => id !== u && id !== v);
                if (remainingNodes.length < 1) continue;
                
                const { isConnected } = isGraphConnected(remainingNodes[0], remainingNodes, adj, new Set([u, v]));
                
                if (!isConnected) {
                    // console.log("–ó–Ω–∞–π–¥–µ–Ω–æ –≤–Ω—É—Ç—Ä—ñ—à–Ω—é –ø–∞—Ä—É-—Ä–æ–∑–¥—ñ–ª—é–≤–∞—á:", pair);
                    return false; // –ó–Ω–∞–π–¥–µ–Ω–æ –ø–∞—Ä—É-—Ä–æ–∑–¥—ñ–ª—é–≤–∞—á
                }
            }

            // 4. –Ø–∫—â–æ –Ω—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ
            return true;
        }
      


        // ====================================================================
        // --- –ï–¢–ê–ü 3: –£–ö–õ–ê–î–ê–ù–ù–Ø –¢–£–¢–¢–ï ---
        // ====================================================================

  /*      function setupTutteLayout(graphData, mode) {
            tutteState = { history: [], currentStep: -1, adj: [], outerFaceIds: [], innerNodeIds: [] };
            tutteState.adj = buildAdjList(graphData);
            
            let outerFaceIds = [];
            let explanation = "";

            if (mode === '3-connected' || mode === 'component') {
                // –ó–Ω–∞—Ö–æ–¥–∏–º–æ —Ü–∏–∫–ª (–≤ —ñ–¥–µ–∞–ª—ñ, –∑–æ–≤–Ω—ñ—à–Ω—é –≥—Ä–∞–Ω—å)
                // –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç–∏, –≤—ñ–∑—å–º–µ–º–æ –æ–ø—É–∫–ª—É –æ–±–æ–ª–æ–Ω–∫—É –ø–æ—Ç–æ—á–Ω–æ–≥–æ D3-—Ä–æ–∑—Ç–∞—à—É–≤–∞–Ω–Ω—è
                const points = graphData.nodes.map(n => [n.x, n.y]);
                const delaunay = d3.Delaunay.from(points);
                const hullIndices = Array.from(delaunay.hull);
                outerFaceIds = hullIndices.map(idx => graphData.nodes[idx].id);
                
                // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —á–∏ —Ü–µ —Å–ø—Ä–∞–≤–¥—ñ —Ü–∏–∫–ª —É –≥—Ä–∞—Ñ—ñ
                let isCycle = true;
                if (outerFaceIds.length > 0) {
                    for(let i = 0; i < outerFaceIds.length; i++) {
                        const u = outerFaceIds[i];
                        const v = outerFaceIds[(i + 1) % outerFaceIds.length];
                        if (!tutteState.adj[u] || !tutteState.adj[u].includes(v)) {
                            // –¶–µ –Ω–µ —Ä–µ–±—Ä–æ, –æ—Ç–∂–µ –æ–ø—É–∫–ª–∞ –æ–±–æ–ª–æ–Ω–∫–∞ –Ω–µ —î —Ü–∏–∫–ª–æ–º
                            isCycle = false;
                            break;
                        }
                    }
                }

                if (!isCycle || outerFaceIds.length < 3) {
                    // –Ø–∫—â–æ –æ–ø—É–∫–ª–∞ –æ–±–æ–ª–æ–Ω–∫–∞ –Ω–µ —Ü–∏–∫–ª (–∞–±–æ < 3 –≤–µ—Ä—à–∏–Ω), —à—É–∫–∞—î–º–æ –±—É–¥—å-—è–∫–∏–π —Ü–∏–∫–ª
                    outerFaceIds = findCycleDFS(graphData);
                }
                
                explanation = "–ö—Ä–æ–∫ 0: –§—ñ–∫—Å—É—î–º–æ –∑–æ–≤–Ω—ñ—à–Ω—é –≥—Ä–∞–Ω—å (–æ–ø—É–∫–ª–∏–π $n$-–∫—É—Ç–Ω–∏–∫).<br>–†–µ—à—Ç–∞ –≤—É–∑–ª—ñ–≤ - '–≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ'.";
            
            } else if (mode === 'collapse') {
                // –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü—ñ—ó –∫–æ–ª–∞–ø—Å—É - —Ç–∞–∫–æ–∂ –±–µ—Ä–µ–º–æ –æ–ø—É–∫–ª—É –æ–±–æ–ª–æ–Ω–∫—É
                const points = graphData.nodes.map(n => [n.x, n.y]);
                const delaunay = d3.Delaunay.from(points);
                const hullIndices = Array.from(delaunay.hull);
                outerFaceIds = hullIndices.map(idx => graphData.nodes[idx].id);
                
                // –Ø–∫—â–æ –¥–ª—è –∫–æ–ª–∞–ø—Å—É –Ω–µ 3-–∑–≤'—è–∑–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞ –º–∏ –Ω–µ –∑–Ω–∞–π—à–ª–∏ –≥–∞—Ä–Ω–∏–π —Ü–∏–∫–ª,
                // —Ü–µ –Ω–∞–≤—ñ—Ç—å –∫—Ä–∞—â–µ - –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü—ñ—è –±—É–¥–µ —è—Å–∫—Ä–∞–≤—ñ—à–æ—é.
                if (outerFaceIds.length < 3) {
                    // –°–ø—Ä–æ–±—É—î–º–æ –≤–∑—è—Ç–∏ –≤—É–∑–ª–∏ –∑ –Ω–∞–π–±—ñ–ª—å—à–∏–º —Å—Ç–µ–ø–µ–Ω–µ–º
                    const allDegrees = graphData.nodes.map(n => ({ id: n.id, degree: (tutteState.adj[n.id] || []).length }));
                    allDegrees.sort((a,b) => b.degree - a.degree);
                    outerFaceIds = allDegrees.slice(0, Math.min(allDegrees.length, 5)).map(n => n.id);
                }
                explanation = "–ö—Ä–æ–∫ 0: –§—ñ–∫—Å—É—î–º–æ –∑–æ–≤–Ω—ñ—à–Ω—ñ –≤—É–∑–ª–∏.<br>–ì—Ä–∞—Ñ –Ω–µ 3-–∑–≤'—è–∑–Ω–∏–π, –æ—á—ñ–∫—É—î—Ç—å—Å—è '–∫–æ–ª–∞–ø—Å'.";
            }
            
            if (outerFaceIds.length < 3) {
                tutteCommentaryEl.html("<span class='result non-planar'>–ü–æ–º–∏–ª–∫–∞: –ù–µ–º–æ–∂–ª–∏–≤–æ –∑–Ω–∞–π—Ç–∏ —Ü–∏–∫–ª –∑ 3+ –≤–µ—Ä—à–∏–Ω –¥–ª—è —É–∫–ª–∞–¥–∞–Ω–Ω—è.</span>");
                return;
            }

            tutteState.outerFaceIds = outerFaceIds;
            const outerSet = new Set(outerFaceIds);
            tutteState.innerNodeIds = graphData.nodes
                .map(n => n.id)
                .filter(id => !outerSet.has(id));

            // –°—Ç–≤–æ—Ä—é—î–º–æ D3-—Å—É–º—ñ—Å–Ω—ñ –¥–∞–Ω—ñ (–∫–æ–ø—ñ—ó)
            const d3GraphNodes = graphData.nodes.map(n => ({
                id: n.id,
                x: n.x, // –ü–æ—á–∞—Ç–∫–æ–≤—ñ –ø–æ–∑–∏—Ü—ñ—ó
                y: n.y,
                isOuter: outerSet.has(n.id)
            }));
            
            const d3GraphEdges = graphData.edges.map(e => ({
                source: e.source,
                target: e.target
            }));

            // –†–æ–∑–º—ñ—â—É—î–º–æ –∑–æ–≤–Ω—ñ—à–Ω—ñ –≤—É–∑–ª–∏ –ø–æ –∫–æ–ª—É
            const n_outer = outerFaceIds.length;
            const radius = Math.min(width, height) / 2 - 50;
            const centerX = width / 2;
            const centerY = height / 2;

            const outerNodeMap = new Map();
            outerFaceIds.forEach((id, i) => {
                const angle = (i / n_outer) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                outerNodeMap.set(id, {x, y});
            });
            
            // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –ø–æ–∑–∏—Ü—ñ—ó (–≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ - –≤ —Ü–µ–Ω—Ç—Ä)
            d3GraphNodes.forEach(n => {
                if (n.isOuter) {
                    const pos = outerNodeMap.get(n.id);
                    n.x = pos.x;
                    n.y = pos.y;
                } else {
                    n.x = centerX;
                    n.y = centerY;
                }
            });
            
            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ ID —Ä–µ–±–µ—Ä –∑–æ–≤–Ω—ñ—à–Ω—å–æ—ó –≥—Ä–∞–Ω—ñ
            const outerEdgeIds = new Set();
            for(let i = 0; i < outerFaceIds.length; i++) {
                const u = outerFaceIds[i];
                const v = outerFaceIds[(i + 1) % outerFaceIds.length];
                outerEdgeIds.add(`${u}-${v}`);
                outerEdgeIds.add(`${v}-${u}`);
            }

            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Å—Ç–∞–Ω
            const initialState = {
                nodes: d3GraphNodes, // –ú–∞—Å–∏–≤ –æ–±'—î–∫—Ç—ñ–≤ {id, x, y, isOuter}
                edges: d3GraphEdges, // –ú–∞—Å–∏–≤ –æ–±'—î–∫—Ç—ñ–≤ {source, target}
                outerEdgeIds: outerEdgeIds,
                subStep: 0, // 0 - highlight, 1 - move
                highlight: null,
                newPositions: {},
                explanation: explanation
            };
            
            tutteState.history = [initialState];
            tutteState.currentStep = 0;
            
            // –û–¥—Ä–∞–∑—É –º–∞–ª—é—î–º–æ
            switchStage('tutte');

            // –û–Ω–æ–≤–ª—é—î–º–æ –∫–Ω–æ–ø–∫–∏
            tutteNextBtn.property('disabled', false);
            tuttePrevBtn.property('disabled', false);
            tutteAutoBtn.property('disabled', false);
            tutteTogglePhysicsBtn.property('disabled', false); // –ö–Ω–æ–ø–∫–∞ —Ñ—ñ–∑–∏–∫–∏
        }
*/
function setupTutteLayout(graphData, mode) {
            tutteState = { history: [], currentStep: -1, adj: [], outerFaceIds: [], innerNodeIds: [] };
            tutteState.adj = buildAdjList(graphData);
            
            let outerFaceIds = [];
            let explanation = "";

            if (mode === '3-connected' || mode === 'component') {
                // !!! –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø: –°–ø–æ—á–∞—Ç–∫—É —à—É–∫–∞—î–º–æ —Ü–∏–∫–ª (–≥—Ä–∞–Ω—å) !!!
                // findCycleDFS –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ –∑–Ω–∞–π–¥–µ —Ü–∏–∫–ª (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, —Ç—Ä–∏–∫—É—Ç–Ω–∏–∫ —É K4),
                // —â–æ —î –∫–æ—Ä–µ–∫—Ç–Ω–æ—é –≥—Ä–∞–Ω–Ω—é –¥–ª—è 3-–∑–≤'—è–∑–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞.
                // –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –æ–ø—É–∫–ª–æ—ó –æ–±–æ–ª–æ–Ω–∫–∏ –±—É–ª–æ –ø–æ–º–∏–ª–∫–æ—é,
                // –æ—Å–∫—ñ–ª—å–∫–∏ –≤–æ–Ω–æ –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ *—Ñ—ñ–∑–∏—á–Ω–æ–≥–æ* —Å—Ç–∞–Ω—É, –∞ –Ω–µ *—Ç–æ–ø–æ–ª–æ–≥—ñ—ó*.
                outerFaceIds = findCycleDFS(graphData);

                // –ó–∞–ø–∞—Å–Ω–∏–π –≤–∞—Ä—ñ–∞–Ω—Ç (—è–∫—â–æ DFS –∑ —è–∫–æ—ó—Å—å –ø—Ä–∏—á–∏–Ω–∏ –Ω–µ —Å–ø—Ä–∞—Ü—é–≤–∞–≤)
                if (!outerFaceIds || outerFaceIds.length < 3) {
                    console.warn("findCycleDFS –Ω–µ –≤–¥–∞–ª–æ—Å—è –∑–Ω–∞–π—Ç–∏ —Ü–∏–∫–ª, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –æ–ø—É–∫–ª—É –æ–±–æ–ª–æ–Ω–∫—É —è–∫ –∑–∞–ø–∞—Å–Ω–∏–π –≤–∞—Ä—ñ–∞–Ω—Ç.");
                    // –°–ø—Ä–æ–±—É—î–º–æ –≤–∑—è—Ç–∏ –æ–ø—É–∫–ª—É –æ–±–æ–ª–æ–Ω–∫—É —è–∫ –æ—Å—Ç–∞–Ω–Ω—ñ–π —à–∞–Ω—Å
                    const points = graphData.nodes.map(n => [n.x, n.y]);
                    const delaunay = d3.Delaunay.from(points);
                    const hullIndices = Array.from(delaunay.hull);
                    outerFaceIds = hullIndices.map(idx => graphData.nodes[idx].id);
                }
                
                explanation = "–ö—Ä–æ–∫ 0: –§—ñ–∫—Å—É—î–º–æ –∑–æ–≤–Ω—ñ—à–Ω—é –≥—Ä–∞–Ω—å (—Ü–∏–∫–ª).<br>–†–µ—à—Ç–∞ –≤—É–∑–ª—ñ–≤ - '–≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ'.";
            
            } else if (mode === 'collapse') {
                // –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü—ñ—ó –∫–æ–ª–∞–ø—Å—É - —Ç–∞–∫–æ–∂ –±–µ—Ä–µ–º–æ –æ–ø—É–∫–ª—É –æ–±–æ–ª–æ–Ω–∫—É
                const points = graphData.nodes.map(n => [n.x, n.y]);
                const delaunay = d3.Delaunay.from(points);
                const hullIndices = Array.from(delaunay.hull);
                outerFaceIds = hullIndices.map(idx => graphData.nodes[idx].id);
                
                if (outerFaceIds.length < 3) {
                    const allDegrees = graphData.nodes.map(n => ({ id: n.id, degree: (tutteState.adj[n.id] || []).length }));
                    allDegrees.sort((a,b) => b.degree - a.degree);
                    outerFaceIds = allDegrees.slice(0, Math.min(allDegrees.length, 5)).map(n => n.id);
                }
                explanation = "–ö—Ä–æ–∫ 0: –§—ñ–∫—Å—É—î–º–æ –∑–æ–≤–Ω—ñ—à–Ω—ñ –≤—É–∑–ª–∏.<br>–ì—Ä–∞—Ñ –Ω–µ 3-–∑–≤'—è–∑–Ω–∏–π, –æ—á—ñ–∫—É—î—Ç—å—Å—è '–∫–æ–ª–∞–ø—Å'.";
            }
            
            if (outerFaceIds.length < 3) {
                tutteCommentaryEl.html("<span class='result non-planar'>–ü–æ–º–∏–ª–∫–∞: –ù–µ–º–æ–∂–ª–∏–≤–æ –∑–Ω–∞–π—Ç–∏ —Ü–∏–∫–ª –∑ 3+ –≤–µ—Ä—à–∏–Ω –¥–ª—è —É–∫–ª–∞–¥–∞–Ω–Ω—è.</span>");
                return;
            }

            tutteState.outerFaceIds = outerFaceIds;
            const outerSet = new Set(outerFaceIds);
            tutteState.innerNodeIds = graphData.nodes
                .map(n => n.id)
                .filter(id => !outerSet.has(id));

            // –°—Ç–≤–æ—Ä—é—î–º–æ D3-—Å—É–º—ñ—Å–Ω—ñ –¥–∞–Ω—ñ (–∫–æ–ø—ñ—ó)
            const d3GraphNodes = graphData.nodes.map(n => ({
                id: n.id,
                x: n.x, // –ü–æ—á–∞—Ç–∫–æ–≤—ñ –ø–æ–∑–∏—Ü—ñ—ó
                y: n.y,
                isOuter: outerSet.has(n.id)
            }));
            
            const d3GraphEdges = graphData.edges.map(e => ({
                source: e.source,
                target: e.target
            }));

            // –†–æ–∑–º—ñ—â—É—î–º–æ –∑–æ–≤–Ω—ñ—à–Ω—ñ –≤—É–∑–ª–∏ –ø–æ –∫–æ–ª—É
            const n_outer = outerFaceIds.length;
            const radius = Math.min(width, height) / 2 - 50;
            const centerX = width / 2;
            const centerY = height / 2;

            const outerNodeMap = new Map();
            outerFaceIds.forEach((id, i) => {
                const angle = (i / n_outer) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                outerNodeMap.set(id, {x, y});
            });
            
            // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –ø–æ–∑–∏—Ü—ñ—ó (–≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ - –≤ —Ü–µ–Ω—Ç—Ä)
            d3GraphNodes.forEach(n => {
                if (n.isOuter) {
                    const pos = outerNodeMap.get(n.id);
                    n.x = pos.x;
                    n.y = pos.y;
                } else {
                    n.x = centerX;
                    n.y = centerY;
                }
            });
            
            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ ID —Ä–µ–±–µ—Ä –∑–æ–≤–Ω—ñ—à–Ω—å–æ—ó –≥—Ä–∞–Ω—ñ
            const outerEdgeIds = new Set();
            for(let i = 0; i < outerFaceIds.length; i++) {
                const u = outerFaceIds[i];
                const v = outerFaceIds[(i + 1) % outerFaceIds.length];
                
                // –ü–µ—Ä–µ–∫–æ–Ω—É—î–º–æ—Å—è, —â–æ —Ü–µ —Ä–µ–±—Ä–æ *—Å–ø—Ä–∞–≤–¥—ñ* —ñ—Å–Ω—É—î –≤ –≥—Ä–∞—Ñ—ñ
                // (—Ü–µ –≤–∞–∂–ª–∏–≤–æ, —è–∫—â–æ –æ–ø—É–∫–ª–∞ –æ–±–æ–ª–æ–Ω–∫–∞ –Ω–µ –±—É–ª–∞ —Ü–∏–∫–ª–æ–º)
                if (tutteState.adj[u] && tutteState.adj[u].includes(v)) {
                   outerEdgeIds.add(`${u}-${v}`);
                   outerEdgeIds.add(`${v}-${u}`);
                }
            }

            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Å—Ç–∞–Ω
            const initialState = {
                nodes: d3GraphNodes, // –ú–∞—Å–∏–≤ –æ–±'—î–∫—Ç—ñ–≤ {id, x, y, isOuter}
                edges: d3GraphEdges, // –ú–∞—Å–∏–≤ –æ–±'—î–∫—Ç—ñ–≤ {source, target}
                outerEdgeIds: outerEdgeIds, // –¶–µ —Ç–µ–ø–µ—Ä Set
                subStep: 0, // 0 - highlight, 1 - move
                highlight: null,
                newPositions: {},
                explanation: explanation
            };
            
            tutteState.history = [initialState];
            tutteState.currentStep = 0;
            
            // –û–¥—Ä–∞–∑—É –º–∞–ª—é—î–º–æ
            switchStage('tutte');

            // –û–Ω–æ–≤–ª—é—î–º–æ –∫–Ω–æ–ø–∫–∏
            tutteNextBtn.property('disabled', false);
            tuttePrevBtn.property('disabled', false);
            tutteAutoBtn.property('disabled', false);
            tutteTogglePhysicsBtn.property('disabled', false); // –ö–Ω–æ–ø–∫–∞ —Ñ—ñ–∑–∏–∫–∏
        }
        function initTutteVisuals() {
            // –°–∫–∏–¥–∞—î–º–æ –≥–æ–ª–æ–≤–Ω—É —Å–∏–º—É–ª—è—Ü—ñ—é
            if(simulation) {
                simulation.stop();
                simulation = null;
            }
            // –°–∫–∏–¥–∞—î–º–æ —Å–∏–º—É–ª—è—Ü—ñ—é –¢—É—Ç—Ç–µ (–ø—Ä–æ –≤—Å—è–∫ –≤–∏–ø–∞–¥–æ–∫)
            if (tutteSimulation) {
                tutteSimulation.stop();
                tutteSimulation = null;
                tutteTogglePhysicsBtn.text("üîå –£–≤—ñ–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É");
            }
            
            svgEl.selectAll("*").remove();
            
            // –ì—Ä—É–ø–∏ –¥–ª—è –µ–ª–µ–º–µ–Ω—Ç—ñ–≤
            linkGroup = svgEl.append("g").attr("class", "links-group");
            nodeGroup = svgEl.append("g").attr("class", "nodes-group");
            labelGroup = svgEl.append("g").attr("class", "labels-group");
            tutteClusterGroup = svgEl.append("g").attr("class", "tutte-clusters-group");
            tutteCentroidGroup = svgEl.append("g").attr("class", "tutte-centroids-group");
        }


        function updateTutteView() {
            if (tutteState.currentStep < 0) return;
            const state = tutteState.history[tutteState.currentStep];
            if (!state) return;

            const { nodes, edges, highlight, newPositions, subStep, outerEdgeIds } = state;
            
            // d3Nodes –æ–Ω–æ–≤–ª—é—î—Ç—å—Å—è –∑ –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É –¥–ª—è drag-n-drop
            d3Nodes = nodes;

            // --- –õ–æ–≥—ñ–∫–∞ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü—ñ—ó (–¥–ª—è –∫–æ–ª–∞–ø—Å—É) ---
            let clusters = [];
            let clusteredNodeIds = new Set();
            
            if (state.explanation && state.explanation.includes("–∫–æ–ª–∞–ø—Å")) {
                const innerNodes = nodes.filter(n => !n.isOuter);
                const positions = innerNodes.map(n => `${n.x.toFixed(3)},${n.y.toFixed(3)}`);
                const posCounts = positions.reduce((acc, pos) => {
                    acc[pos] = (acc[pos] || 0) + 1;
                    return acc;
                }, {});

                const clusterPositions = Object.keys(posCounts).filter(pos => posCounts[pos] > 1);

                clusters = clusterPositions.map((pos, i) => {
                    const [x, y] = pos.split(',').map(Number);
                    const nodeIds = innerNodes
                        .filter(n => n.x.toFixed(3) === x.toFixed(3) && n.y.toFixed(3) === y.toFixed(3))
                        .map(n => n.id);
                    nodeIds.forEach(id => clusteredNodeIds.add(id));
                    return { id: `c${i}`, x, y, nodeIds };
                });
            }

            // --- 1. –ú–∞–ª—é—î–º–æ –†–µ–±—Ä–∞ ---
            const linkSelection = linkGroup.selectAll('.edge')
                .data(edges, d => `${d.source}-${d.target}`)
                .join('line')
                .attr('class', d => {
                    let c = 'edge ';
                    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –æ–±–∏–¥–≤–∞ –≤—É–∑–ª–∏ - –∑–æ–≤–Ω—ñ—à–Ω—ñ –Ü —á–∏ —Ä–µ–±—Ä–æ —î –Ω–∞ –∑–æ–≤–Ω—ñ—à–Ω—ñ–π –≥—Ä–∞–Ω—ñ
                    const sourceNode = nodes.find(n => n.id === d.source);
                    const targetNode = nodes.find(n => n.id === d.target);
                    
                    if (!sourceNode || !targetNode) return 'edge removed'; // –ù–∞ –≤–∏–ø–∞–¥–æ–∫ –ø–æ–º–∏–ª–∫–∏

                    const isOuter = sourceNode.isOuter && targetNode.isOuter;
                    if (isOuter && (outerEdgeIds.has(`${d.source}-${d.target}`) || outerEdgeIds.has(`${d.target}-${d.source}`))) {
                        c += 'tutte-outer';
                    }
                    
                    if (highlight && highlight.edges && highlight.edges.includes(`${d.source}-${d.target}`)) {
                        c += ' tutte-highlight';
                    }
                    // –•–æ–≤–∞—î–º–æ —Ä–µ–±—Ä–∞, —â–æ –≤–µ–¥—É—Ç—å –¥–æ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–æ–≤–∞–Ω–∏—Ö –≤—É–∑–ª—ñ–≤ (—è–∫—â–æ –≤–æ–Ω–∏ –Ω–µ –º—ñ–∂ –∫–ª–∞—Å—Ç–µ—Ä–∞–º–∏)
                     if (clusteredNodeIds.has(d.source) && clusteredNodeIds.has(d.target)) c += ' removed';
                     
                    return c;
                })
                .attr('x1', d => {
                    const node = nodes.find(n => n.id === d.source);
                    return node ? node.x : 0;
                })
                .attr('y1', d => {
                    const node = nodes.find(n => n.id === d.source);
                    return node ? node.y : 0;
                })
                .attr('x2', d => {
                    const node = nodes.find(n => n.id === d.target);
                    return node ? node.x : 0;
                })
                .attr('y2', d => {
                    const node = nodes.find(n => n.id === d.target);
                    return node ? node.y : 0;
                });

            // --- 2. –ú–∞–ª—é—î–º–æ –í–µ—Ä—à–∏–Ω–∏ ---
            // –ú–∞–ª—é—î–º–æ —Ç—ñ–ª—å–∫–∏ —Ç—ñ, —â–æ –ù–ï –≤ –∫–ª–∞—Å—Ç–µ—Ä–∞—Ö
            const nodeSelection = nodeGroup.selectAll('.node')
                .data(nodes.filter(n => !clusteredNodeIds.has(n.id)), d => d.id)
                .join('g')
                .attr('class', d => {
                    let c = 'node ';
                    if (d.isOuter) c += 'tutte-outer';
                    else c += 'tutte-inner';
                    if (highlight && highlight.node === d.id) c += ' tutte-highlight';
                    else if (highlight && highlight.neighbors && highlight.neighbors.includes(d.id)) c += ' tutte-neighbor';
                    return c;
                })
                .attr('transform', d => `translate(${d.x},${d.y})`);

            nodeSelection.selectAll('.node-circle').data(d => [d]).join('circle').attr('class', 'node-circle');
            
            // --- 3. –ú–∞–ª—é—î–º–æ –ú—ñ—Ç–∫–∏ ---
            // –¢–∞–∫–æ–∂ —Ö–æ–≤–∞—î–º–æ –º—ñ—Ç–∫–∏ –¥–ª—è –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–æ–≤–∞–Ω–∏—Ö
            labelGroup.selectAll('.node-label')
                .data(nodes.filter(n => !clusteredNodeIds.has(n.id)), d => d.id)
                .join('text')
                .attr('class', 'node-label')
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .text(d => d.id);

            // --- 4. –î–æ–¥–∞—î–º–æ/–û–Ω–æ–≤–ª—é—î–º–æ drag handler ---
             const drag = d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
            
            nodeSelection.call(drag); // –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ drag –¥–æ –≤—Å—ñ—Ö –≤–∏–¥–∏–º–∏—Ö –≤–µ—Ä—à–∏–Ω
            
            // --- 5. –ú–∞–ª—é—î–º–æ –ö–ª–∞—Å—Ç–µ—Ä–∏ (—è–∫—â–æ —î) ---
            const clusterPaths = tutteClusterGroup.selectAll('.tutte-cluster-path')
                .data(clusters, d => d.id)
                .join('path')
                .attr('class', 'tutte-cluster-path')
                .attr('d', d => {
                    // const points = d.nodeIds
                    //     .map(id => nodes.find(n => n.id === id))
                    //     .map(n => [n.x, n.Y]); // –í–æ–Ω–∏ –≤—Å—ñ –≤ –æ–¥–Ω—ñ–π —Ç–æ—á—Ü—ñ
                    // –®—Ç—É—á–Ω–æ —Å—Ç–≤–æ—Ä—é—î–º–æ –æ–±–ª–∞—Å—Ç—å –Ω–∞–≤–∫–æ–ª–æ —Ç–æ—á–∫–∏
                    const center = [d.x, d.y];
                    const radius = NODE_RADIUS * 1.5 * Math.sqrt(d.nodeIds.length); // –†–∞–¥—ñ—É—Å –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –∫-—Å—Ç—ñ
                    const angle = Math.PI * 2 / 6;
                    const poly = Array.from({length: 6}, (_, i) => [
                        center[0] + radius * Math.cos(angle * i),
                        center[1] + radius * Math.sin(angle * i)
                    ]);
                    return d3.polygonHull(poly);
                })
                .style('fill', 'var(--non-planar-color)')
                .style('opacity', 0.8)
                .style('stroke', 'white')
                .style('stroke-width', 2);
            
            const clusterLabels = tutteClusterGroup.selectAll('.tutte-cluster-label')
                .data(clusters, d => d.id)
                .join('text')
                .attr('class', 'tutte-cluster-label')
                .attr('x', d => d.x)
                .attr('y', d => d.y)
                .text(d => `(${d.nodeIds.length} –≤—É–∑–ª—ñ–≤)`);

            // --- 6. –ú–∞–ª—é—î–º–æ –¶–µ–Ω—Ç—Ä–æ—ó–¥–∏ (—è–∫—â–æ —î) ---
            tutteCentroidGroup.selectAll("*").remove(); // –û—á–∏—â—É—î–º–æ
            
            if (highlight && highlight.node && newPositions[highlight.node] && subStep === 0) {
                const node = nodes.find(n => n.id === highlight.node);
                const centroidPos = newPositions[highlight.node];
                
                // –õ—ñ–Ω—ñ—è –≤—ñ–¥ –≤—É–∑–ª–∞ –¥–æ —Ü–µ–Ω—Ç—Ä–æ—ó–¥–∞
                tutteCentroidGroup.append('line')
                    .attr('class', 'tutte-centroid-line')
                    .attr('x1', node.x)
                    .attr('y1', node.y)
                    .attr('x2', centroidPos.x)
                    .attr('y2', centroidPos.y);
                
                // "–¶—ñ–ª—å" - —Ü–µ–Ω—Ç—Ä–æ—ó–¥
                tutteCentroidGroup.append('circle')
                    .attr('class', 'tutte-centroid')
                    .attr('cx', centroidPos.x)
                    .attr('cy', centroidPos.y)
                    .attr('r', 8);
            }
            
            // 7. –û–Ω–æ–≤–ª—é—î–º–æ –∫–æ–º–µ–Ω—Ç–∞—Ä
            tutteCommentaryEl.html(state.explanation);
             if (window.MathJax && MathJax.typesetPromise) {
                MathJax.typesetPromise([tutteCommentaryEl.node()]).catch(err => console.error('MathJax Error:', err));
            }

            // 8. –û–Ω–æ–≤–ª—é—î–º–æ –∫–Ω–æ–ø–∫–∏
            tuttePrevBtn.property('disabled', tutteState.currentStep === 0);
        }

        //
        // !!! –¶–Ø –§–£–ù–ö–¶–Ü–Ø –û–ù–û–í–õ–ï–ù–ê (–í–ò–ü–†–ê–í–õ–ï–ù–ê –ü–û–ú–ò–õ–ö–ê SyntaxError) !!!
        //
        function runTutteStep(auto = false) {
            // –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø 3: –ó—É–ø–∏–Ω—è—î–º–æ —Å–∏–º—É–ª—è—Ü—ñ—é —Ñ—ñ–∑–∏–∫–∏, —è–∫—â–æ –≤–æ–Ω–∞ –∑–∞–ø—É—â–µ–Ω–∞,
            // –æ—Å–∫—ñ–ª—å–∫–∏ –∫—Ä–æ–∫ –¢—É—Ç—Ç–µ –ø–µ—Ä–µ–∑–∞–ø–∏—à–µ –ø–æ–∑–∏—Ü—ñ—ó.
            if (tutteSimulation) {
                tutteSimulation.stop();
                tutteSimulation = null;
                tutteTogglePhysicsBtn.text("üîå –£–≤—ñ–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É");
                tutteCommentaryEl.html("–§—ñ–∑–∏–∫—É –∑—É–ø–∏–Ω–µ–Ω–æ –¥–ª—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É –∫—Ä–æ–∫—É –¢—É—Ç—Ç–µ.");
            }

            if (tutteState.currentStep < 0) return;
            
            let currentState = tutteState.history[tutteState.currentStep];
            
            // –Ø–∫—â–æ –º–∏ –Ω–∞ –ø—ñ–¥–∫—Ä–æ—Ü—ñ 1 (–≤–∂–µ –ø–µ—Ä–µ—Å—É–Ω—É–ª–∏), —Ç–æ –≥–µ–Ω–µ—Ä—É—î–º–æ –Ω–æ–≤–∏–π –ø–æ–≤–Ω–∏–π –∫—Ä–æ–∫
            if (currentState.subStep === 1 || auto) {
                // –°—Ç–≤–æ—Ä—é—î–º–æ –Ω–æ–≤–∏–π —Å—Ç–∞–Ω –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–æ—Ç–æ—á–Ω–æ–≥–æ
                const newNodes = JSON.parse(JSON.stringify(currentState.nodes));
                const newPositions = {};
                let totalDelta = 0;

                // 1. –†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ –Ω–æ–≤—ñ –ø–æ–∑–∏—Ü—ñ—ó (—Ü–µ–Ω—Ç—Ä–æ—ó–¥–∏) –¥–ª—è –í–°–Ü–• –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ—Ö –≤—É–∑–ª—ñ–≤
                tutteState.innerNodeIds.forEach(id => {
                    const neighbors = tutteState.adj[id] || [];
                    let sumX = 0;
                    let sumY = 0;
                    
                    neighbors.forEach(neighborId => {
                        const neighborNode = newNodes.find(n => n.id === neighborId);
                        sumX += neighborNode.x;
                        sumY += neighborNode.y;
                    });
                    
                    if (neighbors.length > 0) {
                        newPositions[id] = { x: sumX / neighbors.length, y: sumY / neighbors.length };
                    } else {
                        // –Ü–∑–æ–ª—å–æ–≤–∞–Ω–∏–π –≤—É–∑–æ–ª - –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è –Ω–∞ –º—ñ—Å—Ü—ñ
                        const currentNode = newNodes.find(n => n.id === id);
                        newPositions[id] = { x: currentNode.x, y: currentNode.y };
                    }
                });
                
                // 2. –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –Ω–æ–≤—ñ –ø–æ–∑–∏—Ü—ñ—ó
                newNodes.forEach(n => {
                    if (!n.isOuter) {
                        const oldX = n.x, oldY = n.y;
                        n.x = newPositions[n.id].x;
                        n.y = newPositions[n.id].y;
                        totalDelta += Math.sqrt((n.x - oldX)**2 + (n.y - oldY)**2);
                    }
                });

                const explanation = auto 
                    ? `–ê–≤—Ç–æ-—ñ—Ç–µ—Ä–∞—Ü—ñ—è. –ó–∞–≥–∞–ª—å–Ω–µ –∑–º—ñ—â–µ–Ω–Ω—è: ${totalDelta.toFixed(2)}`
                    : `–ö—Ä–æ–∫ ${tutteState.history.length}: –í—Å—ñ –≤—É–∑–ª–∏ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–æ –≤ –±–∞—Ä—ñ—Ü–µ–Ω—Ç—Ä–∏. –ó–∞–≥–∞–ª—å–Ω–µ –∑–º—ñ—â–µ–Ω–Ω—è: ${totalDelta.toFixed(2)}`;

                const newState = {
                    nodes: newNodes,
                    edges: currentState.edges, // –†–µ–±—Ä–∞ –Ω–µ–∑–º—ñ–Ω–Ω—ñ
                    outerEdgeIds: currentState.outerEdgeIds,
                    subStep: 0, // –ü–æ—á–∏–Ω–∞—î–º–æ –∑ –ø—ñ–¥–∫—Ä–æ–∫—É 0 (–ø–æ–∫–∞–∑)
                    highlight: null, // –°–∫–∏–¥–∞—î–º–æ –ø—ñ–¥—Å–≤—ñ—Ç–∫—É
                    newPositions: {}, // –°–∫–∏–¥–∞—î–º–æ (–±—É–¥–µ –∑–∞–ø–æ–≤–Ω–µ–Ω–æ –Ω–∞ –Ω–∞—Å—Ç—É–ø–Ω–æ–º—É –∫—Ä–æ—Ü—ñ)
                    explanation: explanation
                };
                
                // –î–æ–¥–∞—î–º–æ –Ω–æ–≤–∏–π —Å—Ç–∞–Ω
                tutteState.history.push(newState);
                tutteState.currentStep = tutteState.history.length - 1;
                
            } 
            // –Ø–∫—â–æ –º–∏ –Ω–∞ –ø—ñ–¥–∫—Ä–æ—Ü—ñ 0 (–ø–æ–∫–∞–∑), –ø–µ—Ä–µ—Ö–æ–¥–∏–º–æ –Ω–∞ –ø—ñ–¥–∫—Ä–æ–∫ 1 (–ø–µ—Ä–µ—Å—É–≤–∞–Ω–Ω—è)
            // –ê–ë–û —Ü–µ –ø–µ—Ä—à–∏–π –∫—Ä–æ–∫ (currentStep == 0)
            else if (currentState.subStep === 0) {
                
                // --- –ü–ï–†–ï–†–û–ë–õ–ï–ù–û (—ñ –í–ò–ü–†–ê–í–õ–ï–ù–û SyntaxError) ---
                // –ö–æ–ª–∏ –º–∏ –Ω–∞ 0, –º–∏ —Å—Ç–≤–æ—Ä—é—î–º–æ –∫—Ä–æ–∫ 0 (highlight) + –∫—Ä–æ–∫ 1 (move)
                // –¥–ª—è *–≤—Å—ñ—Ö* –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ—Ö –≤—É–∑–ª—ñ–≤
                
                const nextHistory = [];
                
                // 1. –°—Ç–≤–æ—Ä—é—î–º–æ –∫—Ä–æ–∫ 0 (Highlight)
                const nodeToHighlight = tutteState.innerNodeIds[0];
                const neighbors = tutteState.adj[nodeToHighlight] || [];
                let sumX = 0, sumY = 0;
                neighbors.forEach(nid => {
                    const nn = currentState.nodes.find(n => n.id === nid);
                    sumX += nn.x; sumY += nn.y;
                });
                const centroid = (neighbors.length > 0)
                    ? { x: sumX / neighbors.length, y: sumY / neighbors.length }
                    : currentState.nodes.find(n => n.id === nodeToHighlight);
                
                currentState.highlight = { node: nodeToHighlight, neighbors: neighbors };
                currentState.newPositions = { [nodeToHighlight]: centroid };
                currentState.subStep = 0;
                currentState.explanation = `–ö—Ä–æ–∫ ${tutteState.history.length}.1a: –í—É–∑–æ–ª <strong>${nodeToHighlight}</strong>. <br>–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –±–∞—Ä—ñ—Ü–µ–Ω—Ç—Ä–∞ (–∂–æ–≤—Ç–∞ —Ç–æ—á–∫–∞).`;
                
                nextHistory.push(currentState); // –î–æ–¥–∞—î–º–æ –≤ —ñ—Å—Ç–æ—Ä—ñ—é (0)
                
                // 2. –°—Ç–≤–æ—Ä—é—î–º–æ –∫—Ä–æ–∫ 1 (Move)
                //let lastState = JSON.parse(JSON.stringify(currentState));
				let lastState = {
                    ...currentState,
                    nodes: JSON.parse(JSON.stringify(currentState.nodes)),
                    highlight: { ...currentState.highlight },
                    newPositions: { ...currentState.newPositions }
                };
				
                const nodeToMove = lastState.nodes.find(n => n.id === nodeToHighlight);
                nodeToMove.x = centroid.x;
                nodeToMove.y = centroid.y;
                lastState.subStep = 1;
                lastState.explanation = `–ö—Ä–æ–∫ ${tutteState.history.length}.1b: –í—É–∑–æ–ª <strong>${nodeToHighlight}</strong> –ø–µ—Ä–µ–º—ñ—â–µ–Ω–æ.`;
                
                nextHistory.push(lastState); // –î–æ–¥–∞—î–º–æ –≤ —ñ—Å—Ç–æ—Ä—ñ—é (1)
                
                // 3. –†–æ–±–∏–º–æ —Ü–µ –¥–ª—è —Ä–µ—à—Ç–∏ –≤—É–∑–ª—ñ–≤
                for(let i = 1; i < tutteState.innerNodeIds.length; i++) {
                    const nodeId = tutteState.innerNodeIds[i];
                    const prevNodePos = JSON.parse(JSON.stringify(lastState.nodes));
                    
                    const neighbors_i = tutteState.adj[nodeId] || [];
                    let sumX_i = 0, sumY_i = 0;
                    neighbors_i.forEach(nid => {
                        // –í–ê–ñ–õ–ò–í–û: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –ø–æ–∑–∏—Ü—ñ—ó –∑ *–ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ* –∫—Ä–æ–∫—É (currentState)
                        // –ù—ñ, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ *–ø–æ—Ç–æ—á–Ω—ñ* –ø–æ–∑–∏—Ü—ñ—ó (prevNodePos)
                        const nn = prevNodePos.find(n => n.id === nid);
                        sumX_i += nn.x; sumY_i += nn.y;
                    });
                    const centroid_i = (neighbors_i.length > 0)
                        ? { x: sumX_i / neighbors_i.length, y: sumY_i / neighbors_i.length }
                        : prevNodePos.find(n => n.id === nodeId);
                    
                    // –°—Ç–∞–Ω Highlight
                   // let highlightState_i = JSON.parse(JSON.stringify(lastState));
                    //highlightState_i.nodes = prevNodePos; // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Å—Ç–∞—Ä—ñ –ø–æ–∑–∏—Ü—ñ—ó
                    // –°—Ç–∞–Ω Highlight
                        let highlightState_i = {
                            ...lastState, // –¶–µ –ø–µ—Ä–µ–Ω–µ—Å–µ outerEdgeIds (Set) —è–∫ –ø–æ—Å–∏–ª–∞–Ω–Ω—è
                            nodes: prevNodePos // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Å—Ç–∞—Ä—ñ –ø–æ–∑–∏—Ü—ñ—ó
                        };
					
					highlightState_i.highlight = { node: nodeId, neighbors: neighbors_i };
                    highlightState_i.newPositions = { [nodeId]: centroid_i };
                    highlightState_i.subStep = 0;
                    highlightState_i.explanation = `–ö—Ä–æ–∫ ${tutteState.history.length}.${i+1}a: –í—É–∑–æ–ª <strong>${nodeId}</strong>.<br>–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –±–∞—Ä—ñ—Ü–µ–Ω—Ç—Ä–∞ (–∂–æ–≤—Ç–∞ —Ç–æ—á–∫–∞).`;
                    nextHistory.push(highlightState_i); // (2)
                    
                    // –°—Ç–∞–Ω Move
                   // let moveState_i = JSON.parse(JSON.stringify(highlightState_i));
                    // –°—Ç–∞–Ω Move
                        let moveState_i = {
                            ...highlightState_i, // –ü–µ—Ä–µ–Ω–æ—Å–∏–º–æ outerEdgeIds (Set)
                            nodes: JSON.parse(JSON.stringify(highlightState_i.nodes)) // –ì–ª–∏–±–æ–∫–∞ –∫–æ–ø—ñ—è *–ª–∏—à–µ* –≤—É–∑–ª—ñ–≤
                        };
					
					const nodeToMove_i = moveState_i.nodes.find(n => n.id === nodeId);
                    nodeToMove_i.x = centroid_i.x;
                    nodeToMove_i.y = centroid_i.y;
                    moveState_i.subStep = 1;
                    moveState_i.explanation = `–ö—Ä–æ–∫ ${tutteState.history.length}.${i+1}b: –í—É–∑–æ–ª <strong>${nodeId}</strong> –ø–µ—Ä–µ–º—ñ—â–µ–Ω–æ.`;
                    
                    nextHistory.push(moveState_i); // (3)
                    lastState = moveState_i;
                }
                
                // –ó–∞–º—ñ–Ω—é—î–º–æ –ø–æ—Ç–æ—á–Ω–∏–π "–ø—É—Å—Ç–∏–π" –∫—Ä–æ–∫ 0 –Ω–∞ –≤—Å—é –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å
                tutteState.history.pop(); // –í–∏–¥–∞–ª—è—î–º–æ —Å—Ç–∞—Ä–∏–π –∫—Ä–æ–∫ 0
                tutteState.history = [...tutteState.history, ...nextHistory];
                // –ü–µ—Ä–µ—Ö–æ–¥–∏–º–æ –Ω–∞ –ø–µ—Ä—à–∏–π –∑ –Ω–æ–≤–∏—Ö –∫—Ä–æ–∫—ñ–≤
                tutteState.currentStep = tutteState.history.length - nextHistory.length;
            }
            
            updateTutteView();
        }

        // –ö–µ—Ä—É–≤–∞–Ω–Ω—è –∫—Ä–æ–∫–∞–º–∏ –¢—É—Ç—Ç–µ
        //tutteNextBtn.on('click', () => runTutteStep());
		
        tutteNextBtn.on('click', () => {
            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –º–∏ –ù–ï –≤ –∫—ñ–Ω—Ü—ñ –∑–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω–æ—ó —ñ—Å—Ç–æ—Ä—ñ—ó
            if (tutteState.currentStep < tutteState.history.length - 1) {
                // 1. –Ø–∫—â–æ —î "–Ω–∞—Å—Ç—É–ø–Ω–∏–π" –∫—Ä–æ–∫, –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ—Ö–æ–¥–∏–º–æ –¥–æ –Ω—å–æ–≥–æ
                tutteState.currentStep++;
                updateTutteView();
            } else {
                // 2. –Ø–∫—â–æ –º–∏ –≤ –∫—ñ–Ω—Ü—ñ, *—Ç—ñ–ª—å–∫–∏ —Ç–æ–¥—ñ* –≥–µ–Ω–µ—Ä—É—î–º–æ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –∫—Ä–æ–∫ (–∞–±–æ —Å–µ—Ä—ñ—é –∫—Ä–æ–∫—ñ–≤)
                runTutteStep(false);
                // (—Ñ—É–Ω–∫—Ü—ñ—è runTutteStep —Å–∞–º–∞ –æ–Ω–æ–≤–∏—Ç—å –ª—ñ—á–∏–ª—å–Ω–∏–∫ —Ç–∞ –≤–∏–≥–ª—è–¥)
            }
        });

        tuttePrevBtn.on('click', () => {
             // –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø 3: –¢–∞–∫–æ–∂ –∑—É–ø–∏–Ω—è—î–º–æ —Ñ—ñ–∑–∏–∫—É –ø—Ä–∏ –∫—Ä–æ—Ü—ñ –Ω–∞–∑–∞–¥
            if (tutteSimulation) {
                tutteSimulation.stop();
                tutteSimulation = null;
                tutteTogglePhysicsBtn.text("üîå –£–≤—ñ–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É");
            }
            if (tutteState.currentStep <= 0) return;
            tutteState.currentStep--;
            updateTutteView();
        });
        
        //
        // !!! –¶–Ø –§–£–ù–ö–¶–Ü–Ø –û–ù–û–í–õ–ï–ù–ê (–í–ò–ü–†–ê–í–õ–ï–ù–ê –ü–û–ú–ò–õ–ö–ê –ó –†–ï–ë–†–ê–ú–ò) !!!
        //
        tutteTogglePhysicsBtn.on('click', () => {
            if (tutteSimulation) {
                // –§—ñ–∑–∏–∫–∞ –£–í–Ü–ú–ö–ù–ï–ù–ê, –≤–∏–º–∏–∫–∞—î–º–æ —ó—ó
                tutteSimulation.stop();
                tutteSimulation = null;
                tutteTogglePhysicsBtn.text("üîå –£–≤—ñ–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É");
                tutteCommentaryEl.html("–§—ñ–∑–∏–∫—É –∑—É–ø–∏–Ω–µ–Ω–æ.");
            } else {
                // –§—ñ–∑–∏–∫–∞ –í–ò–ú–ö–ù–ï–ù–ê, –≤–º–∏–∫–∞—î–º–æ —ó—ó
                tutteTogglePhysicsBtn.text("üîå –í–∏–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É");
                tutteCommentaryEl.html("–§—ñ–∑–∏–∫–∞ —É–≤—ñ–º–∫–Ω–µ–Ω–∞. –í–Ω—É—Ç—Ä—ñ—à–Ω—ñ –≤—É–∑–ª–∏ '—Ä–æ–∑—Å–ª–∞–±–ª—è—é—Ç—å—Å—è'.");

                const state = tutteState.history[tutteState.currentStep];
                const nodes = state.nodes; // –¶–µ –º–∞—Å–∏–≤ –æ–±'—î–∫—Ç—ñ–≤ {id, x, y, ...}
                const edges = state.edges; // –¶–µ –º–∞—Å–∏–≤ –æ–±'—î–∫—Ç—ñ–≤ {source: id, target: id}
                
                // –°—Ç–≤–æ—Ä—é—î–º–æ d3-—Å—É–º—ñ—Å–Ω—ñ —Ä–µ–±—Ä–∞ (–∑ –æ–±'—î–∫—Ç–∞–º–∏, –∞ –Ω–µ ID)
                const d3EdgesTutte = edges.map(e => ({ 
                    source: nodes.find(n => n.id === e.source), 
                    target: nodes.find(n => n.id === e.target) 
                }));

                // –§—ñ–∫—Å—É—î–º–æ –∑–æ–≤–Ω—ñ—à–Ω—ñ –≤—É–∑–ª–∏
                nodes.forEach(n => {
                    if (n.isOuter) {
                        n.fx = n.x;
                        n.fy = n.y;
                    } else {
                        // –î–æ–∑–≤–æ–ª—è—î–º–æ –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–º —Ä—É—Ö–∞—Ç–∏—Å—å
                        n.fx = null;
                        n.fy = null;
                    }
                });

                tutteSimulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(d3EdgesTutte).distance(50).strength(0.1))
                    .force("charge", d3.forceManyBody().strength(-100))
                    .force("collision", d3.forceCollide().radius(NODE_RADIUS * 1.5))
                    .on("tick", () => {
                        // –ù–∞ –∫–æ–∂–Ω–æ–º—É —Ç—ñ–∫—É –º–∏ *–∑–º—É—à–µ–Ω—ñ* –≤—Ä—É—á–Ω—É –æ–Ω–æ–≤–ª—é–≤–∞—Ç–∏
                        // –ø–æ–∑–∏—Ü—ñ—ó, –æ—Å–∫—ñ–ª—å–∫–∏ updateTutteView –Ω–µ –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è
                        
                        // –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ –æ–±–º–µ–∂–µ–Ω–Ω—è (—Ñ—ñ–∫—Å—É—î–º–æ –∑–æ–≤–Ω—ñ—à–Ω—ñ –≤—É–∑–ª–∏)
                        nodes.forEach(n => {
                            if (n.isOuter) {
                                n.x = n.fx;
                                n.y = n.fy;
                            }
                        });

                        // –†—É—á–Ω–µ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è SVG (—Ç—ñ–ª—å–∫–∏ –ø–æ–∑–∏—Ü—ñ–π)
                        nodeGroup.selectAll('.node')
                            .attr("transform", d => `translate(${d.x},${d.y})`);
                        labelGroup.selectAll('.node-label')
                            .attr("transform", d => `translate(${d.x},${d.y})`);
                        
                        // !!! –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø –¢–£–¢ !!!
                        // –î–∞–Ω—ñ 'd' –Ω–∞ —Ä–µ–±—Ä–∞—Ö - —Ü–µ {source: id, target: id}
                        // –ú–∏ –º–∞—î–º–æ –∑–Ω–∞–π—Ç–∏ –≤—É–∑–ª–∏ –≤ –º–∞—Å–∏–≤—ñ 'nodes', —è–∫–∏–π –æ–Ω–æ–≤–ª—é—î—Ç—å—Å—è
                        linkGroup.selectAll('.edge')
                            .attr("x1", d => {
                                const node = nodes.find(n => n.id === d.source);
                                return node ? node.x : 0;
                            })
                            .attr("y1", d => {
                                const node = nodes.find(n => n.id === d.source);
                                return node ? node.y : 0;
                            })
                            .attr("x2", d => {
                                const node = nodes.find(n => n.id === d.target);
                                return node ? node.x : 0;
                            })
                            .attr("y2", d => {
                                const node = nodes.find(n => n.id === d.target);
                                return node ? node.y : 0;
                            });
                    });
            }
        });


        tutteAutoBtn.on('click', async () => {
            // –ó—É–ø–∏–Ω—è—î–º–æ —Ñ—ñ–∑–∏–∫—É, —è–∫—â–æ –≤–æ–Ω–∞ —î
             if (tutteSimulation) {
                tutteSimulation.stop();
                tutteSimulation = null;
                tutteTogglePhysicsBtn.text("üîå –£–≤—ñ–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É");
            }
            
            tutteNextBtn.property('disabled', true);
            tuttePrevBtn.property('disabled', true);
            tutteAutoBtn.property('disabled', true);
            
            for (let i = 0; i < 10; i++) {
                runTutteStep(true); // –ó–∞–ø—É—Å–∫–∞—î–º–æ 1 –ø–æ–≤–Ω—É —ñ—Ç–µ—Ä–∞—Ü—ñ—é
                updateTutteView();
                
                // –í—ñ–∑—É–∞–ª—å–Ω–∞ –ø–∞—É–∑–∞
                if (i < 9) {
                     await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            tutteNextBtn.property('disabled', false);
            tuttePrevBtn.property('disabled', false);
            tutteAutoBtn.property('disabled', false);
        });

        // ====================================================================
        // --- –ê–õ–ì–û–†–ò–¢–ú–ò: –ü–õ–ê–ù–ê–†–ù–Ü–°–¢–¨ (–í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø K3,3) ---
        // ====================================================================


// ====================================================================
        // --- –ê–õ–ì–û–†–ò–¢–ú–ò: –ü–õ–ê–ù–ê–†–ù–Ü–°–¢–¨ (–†–ï–ê–õ–Ü–ó–ê–¶–Ü–Ø –ó –ë–ï–ö–¢–†–ï–ö–Ü–ù–ì–û–ú) ---
        // ====================================================================
        
        // –î–æ–ø–æ–º—ñ–∂–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø–æ–±—É–¥–æ–≤–∏ —Å–ø–∏—Å–∫—É —Å—É–º—ñ–∂–Ω–æ—Å—Ç—ñ
        function buildAdjList(graph) {
             const adj = {};
             graph.nodes.forEach(n => adj[n.id || n] = []); // –ü—Ä–∞—Ü—é—î —ñ –∑ {id} —ñ –∑ [id]
             graph.edges.forEach(edge => {
                const s = edge.source.id || edge.source;
                const t = edge.target.id || edge.target;
                (adj[s] = adj[s] || []).push(t);
                (adj[t] = adj[t] || []).push(s);
             });
             return adj;
        }

        /**
         * –ó–Ω–∞—Ö–æ–¥–∏—Ç—å –≤—Å—ñ –ø—Ä–æ—Å—Ç—ñ —à–ª—è—Ö–∏ (–±–µ–∑ —Ü–∏–∫–ª—ñ–≤) –≤—ñ–¥ start –¥–æ end, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ DFS.
         * @param {number} start - –ü–æ—á–∞—Ç–∫–æ–≤–∏–π –≤—É–∑–æ–ª
         * @param {number} end - –ö—ñ–Ω—Ü–µ–≤–∏–π –≤—É–∑–æ–ª
         * @param {Object} adj - –°–ø–∏—Å–æ–∫ —Å—É–º—ñ–∂–Ω–æ—Å—Ç—ñ
         * @param {Set<number>} terminals - –¢–µ—Ä–º—ñ–Ω–∞–ª–∏ (K5/K3,3 –≤—É–∑–ª–∏)
         * @param {Set<number>} avoidInternalNodes - –ó–∞–π–Ω—è—Ç—ñ *–≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ* –≤—É–∑–ª–∏
         * @returns {Array<Array<number>>} - –ú–∞—Å–∏–≤ —à–ª—è—Ö—ñ–≤
         */
      /**
         * –ó–Ω–∞—Ö–æ–¥–∏—Ç—å –≤—Å—ñ –ø—Ä–æ—Å—Ç—ñ —à–ª—è—Ö–∏ (–±–µ–∑ —Ü–∏–∫–ª—ñ–≤) –≤—ñ–¥ start –¥–æ end, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ DFS.
         * –¶—è –≤–µ—Ä—Å—ñ—è —Å—É–≤–æ—Ä–æ –∑–∞–±–æ—Ä–æ–Ω—è—î –ø—Ä–æ—Ö–æ–¥–∏—Ç–∏ —á–µ—Ä–µ–∑ *—ñ–Ω—à—ñ* —Ç–µ—Ä–º—ñ–Ω–∞–ª–∏.
         * @param {number} start - –ü–æ—á–∞—Ç–∫–æ–≤–∏–π –≤—É–∑–æ–ª
         * @param {number} end - –ö—ñ–Ω—Ü–µ–≤–∏–π –≤—É–∑–æ–ª
         * @param {Object} adj - –°–ø–∏—Å–æ–∫ —Å—É–º—ñ–∂–Ω–æ—Å—Ç—ñ
         * @param {Set<number>} terminals - *–í—Å—ñ* —Ç–µ—Ä–º—ñ–Ω–∞–ª–∏ (K5/K3,3 –≤—É–∑–ª–∏)
         * @param {Set<number>} avoidInternalNodes - –ó–∞–π–Ω—è—Ç—ñ *–≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ* –≤—É–∑–ª–∏
         * @returns {Array<Array<number>>} - –ú–∞—Å–∏–≤ —à–ª—è—Ö—ñ–≤
         */
        function findAllSimplePaths(start, end, adj, terminals, avoidInternalNodes) {
            const allPaths = [];

            function findPathsRecursive(currentNode, currentPath) {
                if (!adj[currentNode]) return; // –¢—É–ø–∏–∫

                for (const neighbor of adj[currentNode]) {
                    
                    // –£–º–æ–≤–∞ 1: –¶–µ –∫—ñ–Ω–µ—Ü—å —à–ª—è—Ö—É?
                    if (neighbor === end) {
                        allPaths.push([...currentPath, end]);
                        continue; // –ó–Ω–∞–π—à–ª–∏, –∞–ª–µ —à—É–∫–∞—î–º–æ –¥–∞–ª—ñ (–º–æ–∂–ª–∏–≤–æ, —î —ñ–Ω—à—ñ —à–ª—è—Ö–∏)
                    }

                    // –£–º–æ–≤–∞ 2: –¶–µ –≤—É–∑–æ–ª, —á–µ—Ä–µ–∑ —è–∫–∏–π –ù–ï –ú–û–ñ–ù–ê –ø—Ä–æ—Ö–æ–¥–∏—Ç–∏?
                    if (
                        currentPath.includes(neighbor) ||           // 1. –í–∂–µ —î –≤ —à–ª—è—Ö—É (—Ü–∏–∫–ª)
                        terminals.has(neighbor) ||                // 2. –¶–µ *—ñ–Ω—à–∏–π* —Ç–µ—Ä–º—ñ–Ω–∞–ª (!!! –ö–õ–Æ–ß–û–í–ï –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø !!!)
                        avoidInternalNodes.has(neighbor)        // 3. –¶–µ –∑–∞–π–Ω—è—Ç–∏–π *–≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π* –≤—É–∑–æ–ª
                    ) {
                        continue; // –¶–µ–π —à–ª—è—Ö –Ω–µ–¥—ñ–π—Å–Ω–∏–π
                    }

                    // –Ø–∫—â–æ –≤—Å–µ –û–ö (—Ü–µ –∑–≤–∏—á–∞–π–Ω–∏–π, –≤—ñ–ª—å–Ω–∏–π, –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π –≤—É–∑–æ–ª), –π–¥–µ–º–æ –¥–∞–ª—ñ
                    currentPath.push(neighbor);
                    findPathsRecursive(neighbor, currentPath);
                    currentPath.pop(); // Backtrack
                }
            }

            // –ü–æ—á–∏–Ω–∞—î–º–æ –ø–æ—à—É–∫ –∑ –ø–æ—á–∞—Ç–∫–æ–≤–æ—ó —Ç–æ—á–∫–∏
            findPathsRecursive(start, [start]);
            return allPaths;
        }

        /**
         * –†–µ–∫—É—Ä—Å–∏–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –∑ –±–µ–∫—Ç—Ä–µ–∫—ñ–Ω–≥–æ–º –¥–ª—è –ø–æ—à—É–∫—É K *–≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ-–Ω–µ–ø–µ—Ä–µ—Ç–∏–Ω–Ω–∏—Ö* —à–ª—è—Ö—ñ–≤.
         * @param {Array<Array<number>>} pairsToFind - –°–ø–∏—Å–æ–∫ –ø–∞—Ä, —è–∫—ñ —Ç—Ä–µ–±–∞ –∑'—î–¥–Ω–∞—Ç–∏, e.g., [[1,6], [1,7], ...]
         * @param {Object} adj - –°–ø–∏—Å–æ–∫ —Å—É–º—ñ–∂–Ω–æ—Å—Ç—ñ
         * @param {Set<number>} terminals - –ù–∞–±—ñ—Ä "—Ç–µ—Ä–º—ñ–Ω–∞–ª—å–Ω–∏—Ö" –≤—É–∑–ª—ñ–≤ (K5/K3,3)
         * @param {Set<number>} usedInternalNodes - –ú–Ω–æ–∂–∏–Ω–∞ *–≤–∂–µ* –∑–∞–π–Ω—è—Ç–∏—Ö –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ—Ö –≤—É–∑–ª—ñ–≤
         * @param {Object} foundPaths - –û–±'—î–∫—Ç { "1-6": [...] } –∑—ñ –∑–Ω–∞–π–¥–µ–Ω–∏–º–∏ —à–ª—è—Ö–∞–º–∏
         * @returns {Object|null} - –û–±'—î–∫—Ç 'foundPaths' —É —Ä–∞–∑—ñ —É—Å–ø—ñ—Ö—É, –∞–±–æ null
         */
        function findDisjointPathsRecursive(pairsToFind, adj, terminals, usedInternalNodes, foundPaths) {
            // –ë–∞–∑–æ–≤–∏–π –≤–∏–ø–∞–¥–æ–∫: –≤—Å—ñ –ø–∞—Ä–∏ –∑'—î–¥–Ω–∞–Ω–æ
            if (pairsToFind.length === 0) {
                return foundPaths;
            }

            const [start, end] = pairsToFind[0];
            const remainingPairs = pairsToFind.slice(1);
            const pathKey = `${start}-${end}`;

            // 1. –ó–Ω–∞–π—Ç–∏ *–≤—Å—ñ* –º–æ–∂–ª–∏–≤—ñ —à–ª—è—Ö–∏ –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ—ó –ø–∞—Ä–∏
            const allPossiblePaths = findAllSimplePaths(start, end, adj, terminals, usedInternalNodes);

            // 2. –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∫–æ–∂–µ–Ω —à–ª—è—Ö
            for (const path of allPossiblePaths) {
                // 3. –í–∏–∑–Ω–∞—á–∏—Ç–∏, —è–∫—ñ *–Ω–æ–≤—ñ* –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ –≤—É–∑–ª–∏ —Ü–µ–π —à–ª—è—Ö –∑–∞–π–º–∞—î
                const internalNodesInThisPath = path.slice(1, -1)
                    .filter(node => !terminals.has(node));
                
                // 4. –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π –Ω–∞–±—ñ—Ä –∑–∞–π–Ω—è—Ç–∏—Ö –≤—É–∑–ª—ñ–≤
                const newUsedNodes = new Set([...usedInternalNodes, ...internalNodesInThisPath]);
                
                // 5. –û–Ω–æ–≤–∏—Ç–∏ –∑–Ω–∞–π–¥–µ–Ω—ñ —à–ª—è—Ö–∏
                const newFoundPaths = { ...foundPaths, [pathKey]: path };

                // 6. –†–µ–∫—É—Ä—Å–∏–≤–Ω–∏–π –≤–∏–∫–ª–∏–∫
                const result = findDisjointPathsRecursive(remainingPairs, adj, terminals, newUsedNodes, newFoundPaths);

                // 7. –Ø–∫—â–æ —Ä–µ–∫—É—Ä—Å—ñ—è —É—Å–ø—ñ—à–Ω–∞ - –º–∏ –∑–Ω–∞–π—à–ª–∏!
                if (result) {
                    return result;
                }
                
                // 8. –Ø–∫—â–æ –Ω—ñ - —Ü–∏–∫–ª 'for' –ø—Ä–æ–¥–æ–≤–∂—É—î—Ç—å—Å—è, –ø—Ä–æ–±—É—é—á–∏ —ñ–Ω—à–∏–π —à–ª—è—Ö (–∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –±–µ–∫—Ç—Ä–µ–∫—ñ–Ω–≥)
            }

            // 9. –Ø–∫—â–æ –∂–æ–¥–µ–Ω —à–ª—è—Ö –Ω–µ –ø—Ä–∏–∑–≤—ñ–≤ –¥–æ —É—Å–ø—ñ—Ö—É
            return null;
        }


        // –û–Ω–æ–≤–ª–µ–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è, —â–æ –≤–∏–∫–ª–∏–∫–∞—î "–≤–∏—Ä—ñ—à—É–≤–∞—á"
        function findK5Paths(vertices, graph, adj) {
            const terminals = new Set(vertices);
            const pairsToFind = [];
            for (let i = 0; i < vertices.length; i++) {
                for (let j = i + 1; j < vertices.length; j++) {
                    pairsToFind.push([vertices[i], vertices[j]]);
                }
            }

            // –ü–æ—á–∏–Ω–∞—î–º–æ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–∏–π –ø–æ—à—É–∫
            return findDisjointPathsRecursive(
                pairsToFind,       // 10 –ø–∞—Ä
                adj,               // —Å–ø–∏—Å–æ–∫ —Å—É–º—ñ–∂–Ω–æ—Å—Ç—ñ
                terminals,         // 5 –≤—É–∑–ª—ñ–≤ K5
                new Set(),         // –ø–æ—á–∞—Ç–∫–æ–≤–æ –∑–∞–π–Ω—è—Ç–∏—Ö 0
                {}                 // –ø–æ—á–∞—Ç–∫–æ–≤–æ –∑–Ω–∞–π–¥–µ–Ω–æ 0
            );
        }

        // –û–Ω–æ–≤–ª–µ–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è, —â–æ –≤–∏–∫–ª–∏–∫–∞—î "–≤–∏—Ä—ñ—à—É–≤–∞—á"
        function findK33Paths(setA, setB, graph, adj) {
            const terminals = new Set([...setA, ...setB]);
            const pairsToFind = [];
            for (let a of setA) {
                for (let b of setB) {
                    pairsToFind.push([a, b]);
                }
            }

            // –ü–æ—á–∏–Ω–∞—î–º–æ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–∏–π –ø–æ—à—É–∫
            return findDisjointPathsRecursive(
                pairsToFind,       // 9 –ø–∞—Ä
                adj,               // —Å–ø–∏—Å–æ–∫ —Å—É–º—ñ–∂–Ω–æ—Å—Ç—ñ
                terminals,         // 6 –≤—É–∑–ª—ñ–≤ K3,3
                new Set(),         // –ø–æ—á–∞—Ç–∫–æ–≤–æ –∑–∞–π–Ω—è—Ç–∏—Ö 0
                {}                 // –ø–æ—á–∞—Ç–∫–æ–≤–æ –∑–Ω–∞–π–¥–µ–Ω–æ 0
            );
        }



        // --- –î–æ–ø–æ–º—ñ–∂–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è: –ü–æ—à—É–∫ —Ü–∏–∫–ª—É (DFS) ---
        function findCycleDFS(graph) {
            const adj = buildAdjList(graph);
            const nodes = graph.nodes.map(n => n.id);
            if (nodes.length === 0) return [];
            
            const visited = new Set();
            const parent = new Map();
            let cycle = null;
            
            function dfs(u, p) {
                if (cycle) return; // –¶–∏–∫–ª –≤–∂–µ –∑–Ω–∞–π–¥–µ–Ω–æ
                
                visited.add(u);
                parent.set(u, p);
                
                const neighbors = adj[u] || [];
                for (const v of neighbors) {
                    if (cycle) return;
                    
                    if (v === p) continue; // –ù–µ –π–¥–µ–º–æ –Ω–∞–∑–∞–¥ –¥–æ –±–∞—Ç—å–∫–∞
                    
                    if (visited.has(v)) {
                        // –ó–Ω–∞–π—à–ª–∏ —Ü–∏–∫–ª!
                        cycle = [v, u];
                        let curr = u;
                        while(parent.get(curr) !== v) {
                            curr = parent.get(curr);
                            cycle.push(curr);
                        }
                        cycle.push(v); // –ó–∞–º–∏–∫–∞—î–º–æ
                        cycle = cycle.slice(1); // –ü—Ä–∏–±–∏—Ä–∞—î–º–æ –¥—É–±–ª—ñ–∫–∞—Ç
                        return;
                    } else {
                        dfs(v, u);
                    }
                }
            }
            
            // –ó–∞–ø—É—Å–∫–∞—î–º–æ DFS –∑ –ø–µ—Ä—à–æ—ó –≤–µ—Ä—à–∏–Ω–∏ (–∞–±–æ –±—É–¥—å-—è–∫–æ—ó)
            for (const nodeId of nodes) {
                if (!visited.has(nodeId)) {
                    dfs(nodeId, null);
                }
                if (cycle) break; // –ó—É–ø–∏–Ω—è—î–º–æ, —è–∫—â–æ –∑–Ω–∞–π—à–ª–∏
            }
           
            return cycle || []; // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ —Ü–∏–∫–ª –∞–±–æ –ø—É—Å—Ç–∏–π –º–∞—Å–∏–≤
        }
        
        // --- –†–µ—Å–∞–π–∑ ---
        function handleResize() {
            width = svgContainer.node().getBoundingClientRect().width;
            height = Math.max(500, window.innerHeight * 0.7);
            svgEl.attr("width", width).attr("height", height);
            
            if (simulation) {
                simulation.force("center", d3.forceCenter(width / 2, height / 2)).restart();
            }
            if (currentStage === 'tutte' && tutteState.currentStep >= 0) {
                 // –ü–æ—Ç—Ä—ñ–±–Ω–æ –ø–µ—Ä–µ–±—É–¥—É–≤–∞—Ç–∏ –¢—É—Ç—Ç–µ, –±–æ –ø–æ–∑–∏—Ü—ñ—ó —Ñ—ñ–∫—Å–æ–≤–∞–Ω—ñ
                 tutteCommentaryEl.html("<span class='result'>–†–æ–∑–º—ñ—Ä –≤—ñ–∫–Ω–∞ –∑–º—ñ–Ω–µ–Ω–æ. –ü–æ—Ç—Ä—ñ–±–Ω–æ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–∏ —É–∫–ª–∞–¥–∞–Ω–Ω—è –¢—É—Ç—Ç–µ.</span>");
                 tutteNextBtn.property('disabled', true);
                 tuttePrevBtn.property('disabled', true);
                 tutteAutoBtn.property('disabled', true);
                 
                 // –ó—É–ø–∏–Ω—è—î–º–æ —Å–∏–º—É–ª—è—Ü—ñ—é –¢—É—Ç—Ç–µ
                 if (tutteSimulation) {
                    tutteSimulation.stop();
                    tutteSimulation = null;
                    tutteTogglePhysicsBtn.text("üîå –£–≤—ñ–º–∫–Ω—É—Ç–∏ —Ñ—ñ–∑–∏–∫—É");
                 }
            }
        }
        
        const resizeObserver = new ResizeObserver(handleResize);
        resizeObserver.observe(svgContainer.node());

        // --- –ü–æ—á–∞—Ç–∫–æ–≤–∏–π –∑–∞–ø—É—Å–∫ ---
        handleResize();
        resetToPlanarityStage();

    </script>
  
  
  
</body>
</html>